{
  List<Updateable> master_results=new ArrayList<>();
  List<Updateable> worker_results=new ArrayList<>();
  long ts_start=System.currentTimeMillis();
  int iterations=Integer.parseInt(props.getProperty("app.iteration.count"));
  log.info("Starting Epochs (" + iterations + ")...");
  for (int x=0; x < iterations; x++) {
    for (int worker_id=0; worker_id < workers.size(); worker_id++) {
      Updateable result=workers.get(worker_id).compute();
      worker_results.add(result);
    }
    Updateable master_result=this.master.compute(worker_results,master_results);
    for (int worker_id=0; worker_id < workers.size(); worker_id++) {
      workers.get(worker_id).update(master_result);
    }
    log.info("Complete " + iterations + " Iterations Per Worker.");
    if (null != this.props.getProperty("app.output.path")) {
      String output_path=this.props.getProperty("app.output.path");
      log.info("Writing the output to: " + output_path);
      try {
        Path out=new Path(output_path);
        FileSystem fs=out.getFileSystem(defaultConf);
        FSDataOutputStream fos;
        fos=fs.create(out);
        master.complete(fos);
        fos.flush();
        fos.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
 else {
      log.info("Not Firing Master::Complete() function due to no output path in conf");
    }
  }
}
