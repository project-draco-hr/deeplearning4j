{
  if (network.layers != null && network.layers.length > 0) {
    this.layers=new NeuralNetwork[nLayers];
    for (int i=0; i < layers.length; i++)     this.getLayers()[i]=network.getLayers()[i].clone();
  }
  this.normalizeByInputRows=network.normalizeByInputRows;
  this.useAdaGrad=network.useAdaGrad;
  this.hiddenLayerSizes=network.hiddenLayerSizes;
  if (network.logLayer != null)   this.logLayer=network.logLayer.clone();
  this.nIns=network.nIns;
  this.nLayers=network.nLayers;
  this.nOuts=network.nOuts;
  this.rng=network.rng;
  this.dist=network.dist;
  this.activation=network.activation;
  this.useRegularization=network.useRegularization;
  this.columnMeans=network.columnMeans;
  this.columnStds=network.columnStds;
  this.columnSums=network.columnSums;
  this.errorTolerance=network.errorTolerance;
  this.renderWeightsEveryNEpochs=network.renderWeightsEveryNEpochs;
  this.forceNumEpochs=network.forceNumEpochs;
  this.input=network.input;
  this.l2=network.l2;
  this.fanIn=network.fanIn;
  this.labels=network.labels;
  this.momentum=network.momentum;
  this.learningRateUpdate=network.learningRateUpdate;
  this.shouldBackProp=network.shouldBackProp;
  this.weightTransforms=network.weightTransforms;
  this.sparsity=network.sparsity;
  this.toDecode=network.toDecode;
  this.visibleBiasTransforms=network.visibleBiasTransforms;
  this.hiddenBiasTransforms=network.hiddenBiasTransforms;
  this.dropOut=network.dropOut;
  this.optimizationAlgorithm=network.optimizationAlgorithm;
  this.lossFunction=network.lossFunction;
  if (network.sigmoidLayers != null && network.sigmoidLayers.length > 0) {
    this.sigmoidLayers=new HiddenLayer[network.sigmoidLayers.length];
    for (int i=0; i < sigmoidLayers.length; i++)     this.getSigmoidLayers()[i]=network.getSigmoidLayers()[i].clone();
  }
}
