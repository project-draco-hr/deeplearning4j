{
  ret.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);
  ret.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS,false);
  ret.configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY,true);
  ret.enable(SerializationFeature.INDENT_OUTPUT);
  Reflections reflections=new Reflections();
  Set<Class<? extends Layer>> subTypes=reflections.getSubTypesOf(Layer.class);
  AnnotatedClass ac=AnnotatedClass.construct(Layer.class,ret.getSerializationConfig().getAnnotationIntrospector(),null);
  Collection<NamedType> types=ret.getSubtypeResolver().collectAndResolveSubtypes(ac,ret.getSerializationConfig(),ret.getSerializationConfig().getAnnotationIntrospector());
  Set<Class<?>> registeredSubtypes=new HashSet<>();
  for (  NamedType nt : types) {
    registeredSubtypes.add(nt.getType());
  }
  List<NamedType> toRegister=new ArrayList<>();
  for (  Class<? extends Layer> c : subTypes) {
    if (Modifier.isAbstract(c.getModifiers()) || Modifier.isInterface(c.getModifiers())) {
      continue;
    }
    if (!registeredSubtypes.contains(c)) {
      String name;
      if (ClassUtils.isInnerClass(c)) {
        Class<?> c2=c.getDeclaringClass();
        name=c2.getSimpleName() + "$" + c.getSimpleName();
      }
 else {
        name=c.getSimpleName();
      }
      toRegister.add(new NamedType(c,name));
      log.debug("Registering custom Layer class for JSON serialization: {}",c);
    }
  }
  ret.registerSubtypes(toRegister.toArray(new NamedType[toRegister.size()]));
}
