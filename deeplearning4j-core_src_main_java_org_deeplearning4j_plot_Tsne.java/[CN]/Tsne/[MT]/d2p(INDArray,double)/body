{
  int n=d.rows();
  final INDArray p=zeros(n,n);
  final INDArray beta=ones(n,1);
  final double logU=Math.log(u);
  log.info("Calculating probabilities of data similarities..");
  ExecutorService service=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  for (int i=0; i < n; i++) {
    if (i % 500 == 0)     log.info("Handled " + i + " records");
    final int j=i;
    service.submit(new Runnable(){
      @Override public void run(){
        double betaMin=Float.NEGATIVE_INFINITY;
        double betaMax=Float.POSITIVE_INFINITY;
        NDArrayIndex[] range=new NDArrayIndex[]{NDArrayIndex.concat(NDArrayIndex.interval(0,j),NDArrayIndex.interval(j + 1,d.columns()))};
        INDArray row=d.slice(j).get(range);
        Pair<INDArray,INDArray> pair=hBeta(row,beta.getDouble(j));
        INDArray hDiff=pair.getFirst().sub(logU);
        int tries=0;
        while (BooleanIndexing.and(abs(hDiff),Conditions.greaterThan(tolerance)) && tries < 50) {
          if (BooleanIndexing.and(hDiff,Conditions.greaterThan(0))) {
            if (Double.isInfinite(betaMax))             beta.putScalar(j,beta.getDouble(j) * 2.0);
 else             beta.putScalar(j,(beta.getDouble(j) + betaMax) / 2.0);
            betaMin=beta.getDouble(j);
          }
 else {
            if (Double.isInfinite(betaMin))             beta.putScalar(j,beta.getDouble(j) / 2.0);
 else             beta.putScalar(j,(beta.getDouble(j) + betaMin) / 2.0);
            betaMax=beta.getDouble(j);
          }
          pair=hBeta(row,beta.getDouble(j));
          hDiff=pair.getFirst().subi(logU);
          tries++;
        }
        p.slice(j).put(range,pair.getSecond());
      }
    }
);
  }
  try {
    service.shutdown();
    service.awaitTermination(1,TimeUnit.DAYS);
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  log.info("Mean value of sigma " + sqrt(beta.rdiv(1)).mean(Integer.MAX_VALUE));
  BooleanIndexing.applyWhere(p,Conditions.isNan(),new Value(realMin));
  INDArray permute=p.transpose();
  INDArray pOut=p.add(permute);
  BooleanIndexing.applyWhere(pOut,Conditions.isNan(),new Value(realMin));
  pOut.divi(pOut.sum(Integer.MAX_VALUE));
  BooleanIndexing.applyWhere(pOut,Conditions.lessThan(1e-12),new Value(1e-12));
  return pOut;
}
