{
  int n=d.rows();
  final INDArray p=zeros(n,n);
  final INDArray beta=ones(n,1);
  final double logU=Math.log(u);
  log.info("Calculating probabilities of data similarities..");
  for (int i=0; i < n; i++) {
    if (i % 500 == 0)     log.info("Handled " + i + " records");
    final int j=i;
    double betaMin=Float.NEGATIVE_INFINITY;
    double betaMax=Float.POSITIVE_INFINITY;
    NDArrayIndex[] range=new NDArrayIndex[]{NDArrayIndex.concat(NDArrayIndex.interval(0,i),NDArrayIndex.interval(i + 1,d.columns()))};
    INDArray row=d.slice(j).get(range);
    Pair<INDArray,INDArray> pair=hBeta(row,beta.getDouble(j));
    INDArray hDiff=pair.getFirst().sub(logU);
    int tries=0;
    while (BooleanIndexing.and(abs(hDiff),Conditions.greaterThan(tolerance)) && tries < 50) {
      if (BooleanIndexing.and(hDiff,Conditions.greaterThan(0))) {
        if (Double.isInfinite(betaMax))         beta.putScalar(j,beta.getDouble(j) * 2.0);
 else         beta.putScalar(j,(beta.getDouble(j) + betaMax) / 2.0);
        betaMin=beta.getDouble(j);
      }
 else {
        if (Double.isInfinite(betaMin))         beta.putScalar(j,beta.getDouble(j) / 2.0);
 else         beta.putScalar(j,(beta.getDouble(j) + betaMin) / 2.0);
        betaMax=beta.getDouble(j);
      }
      pair=hBeta(row,beta.getDouble(j));
      hDiff=pair.getFirst().subi(logU);
      tries++;
    }
    p.slice(j).put(range,pair.getSecond());
  }
  log.info("Mean value of sigma " + sqrt(beta.rdiv(1)).mean(Integer.MAX_VALUE));
  BooleanIndexing.applyWhere(p,Conditions.isNan(),new Value(realMin));
  INDArray permute=p.transpose();
  INDArray pOut=p.add(permute);
  BooleanIndexing.applyWhere(pOut,Conditions.isNan(),new Value(realMin));
  pOut.divi(pOut.sum(Integer.MAX_VALUE));
  pOut=Transforms.max(pOut,1e-12f);
  return pOut;
}
