{
  int n=d.rows();
  final INDArray p=zeros(n,n);
  final INDArray beta=ones(n,1);
  final double logU=(double)Math.log(u);
  log.info("Calculating probabilities of data similarities..");
  for (int i=0; i < n; i++) {
    if (i % 500 == 0)     log.info("Handled " + i + " records");
    final int j=i;
    double betaMin=Float.NEGATIVE_INFINITY;
    double betaMax=Float.POSITIVE_INFINITY;
    INDArray row=d.slice(j).get(NDArrayIndex.interval(1,d.columns()));
    Pair<INDArray,INDArray> pair=hBeta(row,beta.getDouble(j));
    INDArray hDiff=pair.getFirst().sub(logU);
    int tries=0;
    while (BooleanIndexing.and(abs(hDiff),Conditions.greaterThan(tolerance)) && tries < 50) {
      if (BooleanIndexing.and(hDiff,Conditions.greaterThan(0))) {
        betaMin=beta.getDouble(j);
        if (Double.isInfinite(betaMax))         beta.putScalar(j,beta.getDouble(j) * 2);
 else         beta.putScalar(j,(beta.getDouble(j) + betaMax) / 2);
      }
 else {
        betaMax=beta.getDouble(j);
        if (Double.isInfinite(betaMin))         beta.putScalar(j,beta.getDouble(j) / 2);
 else         beta.putScalar(j,(beta.getDouble(j) + betaMin) / 2);
      }
      pair=hBeta(d.slice(j).get(NDArrayIndex.interval(1,d.columns())),beta.getDouble(j));
      hDiff=pair.getFirst().subi(logU);
      tries++;
    }
    p.slice(j).put(new NDArrayIndex[]{NDArrayIndex.interval(1,d.columns())},pair.getSecond());
  }
  doAlongDiagonal(p,new Function<Number,Number>(){
    @Override public Number apply(    Number input){
      return 0;
    }
  }
);
  INDArray pOut=p.add(p.transpose());
  pOut.divi(p.sum(Integer.MAX_VALUE));
  pOut=Transforms.max(pOut,1e-12f);
  BooleanIndexing.applyWhere(pOut,Conditions.isNan(),new Value(realMin));
  log.info("Mean value of sigma " + sqrt(beta.rdiv(1).mean(Integer.MAX_VALUE)));
  return pOut;
}
