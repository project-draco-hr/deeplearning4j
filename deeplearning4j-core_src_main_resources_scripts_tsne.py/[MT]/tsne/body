def tsne(X=np.array([]), no_dims=2, initial_dims=50, perplexity=30.0):
    'Runs t-SNE on the dataset in the NxD array X to reduce its dimensionality to no_dims dimensions.\n    The syntaxis of the function is Y = tsne.tsne(X, no_dims, perplexity), where X is an NxD NumPy array.'
    if (X.dtype != 'float64'):
        print 'Error: array X should have type float64.'
        return (-1)
    X = pca(X, initial_dims)
    (n, d) = X.shape
    max_iter = 1000
    initial_momentum = 0.5
    final_momentum = 0.8
    eta = 500
    min_gain = 0.01
    Y = np.random.randn(n, no_dims)
    dY = np.zeros((n, no_dims))
    iY = np.zeros((n, no_dims))
    gains = np.ones((n, no_dims))
    P = x2p(X, 1e-05, perplexity)
    P = (P + np.transpose(P))
    P = (P / np.sum(P))
    P *= 4
    P = np.maximum(P, 1e-12)
    for iter in range(max_iter):
        sum_Y = np.sum(np.square(Y), 1)
        num = (1 / (1 + np.add(np.add(((-2) * np.dot(Y, Y.T)), sum_Y).T, sum_Y)))
        num[(range(n), range(n))] = 0
        Q = (num / np.sum(num))
        Q = np.maximum(Q, 1e-12)
        PQ = (P - Q)
        for i in range(n):
            dY[i, :] = np.sum((np.tile((PQ[:, i] * num[:, i]), (no_dims, 1)).T * (Y[i, :] - Y)), 0)
        if (iter < 20):
            momentum = initial_momentum
        else:
            momentum = final_momentum
        gains = (((gains + 0.2) * ((dY > 0) != (iY > 0))) + ((gains * 0.8) * ((dY > 0) == (iY > 0))))
        gains[(gains < min_gain)] = min_gain
        iY = ((momentum * iY) - (eta * (gains * dY)))
        Y += iY
        Y -= np.tile(np.mean(Y, 0), (n, 1))
        if (((iter + 1) % 10) == 0):
            C = np.sum((P * np.log((P / Q))))
            print 'Iteration ', (iter + 1), ': error is ', C
        if (iter == 100):
            P /= 4
    return Y
