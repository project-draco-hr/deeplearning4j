{
  List<Integer> is=new ArrayList<>();
  List<INDArray> xs=new ArrayList<>();
  INDArray r=network.getBackPropRGradient(x0).subi(b);
  INDArray y=r.div(preCon);
  Float deltaNew=(Float)r.mul(y).sum(Integer.MAX_VALUE).element();
  INDArray p=y.neg();
  INDArray x=x0;
  for (int iterationCount=0; iterationCount < numIterations; iterationCount++) {
    INDArray Ap=network.getBackPropRGradient(p);
    Float pAp=(Float)Ap.mul(p).sum(Integer.MAX_VALUE).element();
    if (pAp < 0) {
      log.info("Negative slope: " + pAp + " breaking");
    }
    Float val=0.5f * NDArrays.getBlasWrapper().dot(b.neg().add(r).transpose(),x);
    log.info("Iteration on conjugate gradient " + iterationCount + " with value "+ val);
    Float alpha=deltaNew / pAp;
    x.addi(p.mul(alpha));
    INDArray rNew=r.add(Ap.mul(alpha));
    INDArray yNew=rNew.div(preCon);
    Float deltaOld=deltaNew;
    deltaNew=(Float)rNew.mul(yNew).sum(Integer.MAX_VALUE).element();
    Float beta=deltaNew / deltaOld;
    p=yNew.neg().add(p.mul(beta));
    r=rNew;
    is.add(iterationCount);
    xs.add(x.dup());
  }
  return new Pair<>(is,xs);
}
