{
  INDArray gradient;
  INDArray searchDirection;
  INDArray parameters=null;
  model.validateInput();
  Pair<Gradient,Double> pair=gradientAndScore();
  score=pair.getSecond();
  if (searchState.isEmpty()) {
    searchState.put(GRADIENT_KEY,pair.getFirst().gradient(conf.getVariables()));
    setupSearchState(pair);
  }
 else {
    searchState.put(GRADIENT_KEY,pair.getFirst().gradient(conf.getVariables()));
  }
  preProcessLine();
  for (int i=0; i < conf.getNumIterations(); i++) {
    gradient=(INDArray)searchState.get(GRADIENT_KEY);
    searchDirection=(INDArray)searchState.get(SEARCH_DIR);
    parameters=(INDArray)searchState.get(PARAMS_KEY);
    try {
      step=lineMaximizer.optimize(parameters,gradient,searchDirection);
    }
 catch (    InvalidStepException e) {
      log.warn("Invalid step...continuing another iteration: {}",e.getMessage());
      step=0.0;
    }
    if (step != 0.0) {
      stepFunction.step(parameters,searchDirection,step);
      model.setParams(parameters);
    }
 else {
      log.debug("Step size returned by line search is 0.0.");
    }
    oldScore=score;
    pair=gradientAndScore();
    postStep(pair.getFirst().gradient(conf.getVariables()));
    score=pair.getSecond();
    for (    IterationListener listener : iterationListeners)     listener.iterationDone(model,i);
    for (    TerminationCondition condition : terminationConditions) {
      if (condition.terminate(score,oldScore,new Object[]{pair.getFirst().gradient()})) {
        log.debug("Hit termination condition on iteration {}: score={}, oldScore={}, condition={}",i,score,oldScore,condition);
        return true;
      }
    }
    this.iteration++;
  }
  return true;
}
