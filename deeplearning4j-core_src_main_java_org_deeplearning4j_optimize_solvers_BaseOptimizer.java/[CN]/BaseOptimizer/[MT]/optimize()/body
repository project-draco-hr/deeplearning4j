{
  model.validateInput();
  Pair<Gradient,Double> pair=gradientAndScore();
  setupSearchState(pair);
  score=model.score();
  INDArray gradient=(INDArray)searchState.get(GRADIENT_KEY);
  INDArray searchDirection=(INDArray)searchState.get(SEARCH_DIR);
  boolean testLineSearch=preFirstStepProcess(gradient);
  if (testLineSearch) {
    try {
      INDArray parameters=(INDArray)searchState.get(PARAMS_KEY);
      step=lineMaximizer.optimize(parameters,gradient,searchDirection);
    }
 catch (    InvalidStepException e) {
      log.warn("Invalid step...continuing another iteration");
    }
    gradient=(INDArray)searchState.get(GRADIENT_KEY);
    postFirstStep(gradient);
    if (step == 0.0) {
      log.warn("Unable to step in direction");
      return false;
    }
  }
  preProcessLine(gradient);
  searchDirection=(INDArray)searchState.get(SEARCH_DIR);
  for (int i=0; i < conf.getNumIterations(); i++) {
    try {
      INDArray parameters=(INDArray)searchState.get(PARAMS_KEY);
      step=lineMaximizer.optimize(parameters,gradient,searchDirection);
    }
 catch (    InvalidStepException e) {
      log.warn("Invalid step...continuing another iteration: {}",e.getMessage());
    }
    oldScore=score;
    pair=gradientAndScore();
    setupSearchState(pair);
    score=pair.getSecond();
    for (    IterationListener listener : iterationListeners)     listener.iterationDone(model,i);
    for (    TerminationCondition condition : terminationConditions) {
      if (condition.terminate(score,oldScore,new Object[]{gradient})) {
        log.debug("Hit termination condition: score={}, oldScore={}, condition={}",score,oldScore,condition);
        return true;
      }
    }
    postStep();
    this.iteration++;
    for (    TerminationCondition condition : terminationConditions)     if (condition.terminate(score,oldScore,new Object[]{gradient}))     return true;
  }
  return true;
}
