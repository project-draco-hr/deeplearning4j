{
  if (initCalled)   return;
  Map<String,org.deeplearning4j.nn.conf.graph.GraphVertex> nodeMap=configuration.getVertices();
  List<String> networkInputNames=configuration.getNetworkInputs();
  Map<String,List<String>> vertexInputs=configuration.getVertexInputs();
  this.vertices=new GraphVertex[networkInputNames.size() + configuration.getVertices().size()];
  Map<String,Integer> allNamesReverse=new HashMap<>();
  int i=0;
  for (  String name : networkInputNames) {
    GraphVertex gv=new InputVertex(this,name,i,null);
    allNamesReverse.put(name,i);
    vertices[i++]=gv;
  }
  int numLayers=0;
  List<Layer> tempLayerList=new ArrayList<>();
  for (  Map.Entry<String,org.deeplearning4j.nn.conf.graph.GraphVertex> nodeEntry : nodeMap.entrySet()) {
    org.deeplearning4j.nn.conf.graph.GraphVertex n=nodeEntry.getValue();
    String name=nodeEntry.getKey();
    GraphVertex gv=n.instantiate(this,name,i);
    if (gv.hasLayer()) {
      numLayers++;
      tempLayerList.add(gv.getLayer());
    }
    allNamesReverse.put(name,i);
    vertices[i++]=gv;
  }
  layers=tempLayerList.toArray(new Layer[numLayers]);
  verticesMap=new HashMap<>();
  for (  GraphVertex gv : vertices) {
    verticesMap.put(gv.getVertexName(),gv);
  }
  Map<String,List<String>> verticesOutputTo=new HashMap<>();
  for (  GraphVertex gv : vertices) {
    String vertexName=gv.getVertexName();
    List<String> vertexInputNames;
    vertexInputNames=vertexInputs.get(vertexName);
    if (vertexInputNames == null)     continue;
    for (    String s : vertexInputNames) {
      List<String> list=verticesOutputTo.get(s);
      if (list == null) {
        list=new ArrayList<>();
        verticesOutputTo.put(s,list);
      }
      list.add(vertexName);
    }
  }
  for (  GraphVertex gv : vertices) {
    String vertexName=gv.getVertexName();
    int vertexIndex=gv.getVertexIndex();
    List<String> vertexInputNames;
    vertexInputNames=vertexInputs.get(vertexName);
    if (vertexInputNames == null)     continue;
    VertexIndices[] inputIndices=new VertexIndices[vertexInputNames.size()];
    for (int j=0; j < vertexInputNames.size(); j++) {
      String inName=vertexInputNames.get(j);
      int inputVertexIndex=allNamesReverse.get(inName);
      GraphVertex inputVertex=vertices[inputVertexIndex];
      List<String> inputVertexOutputsTo=verticesOutputTo.get(inName);
      int outputNumberOfInput=inputVertexOutputsTo.indexOf(vertexName);
      if (outputNumberOfInput == -1)       throw new IllegalStateException("Could not find vertex " + vertexIndex + " in the list of outputs "+ "for vertex "+ inputVertex+ "; error in graph structure?");
      inputIndices[j]=new VertexIndices(inputVertexIndex,outputNumberOfInput);
    }
    gv.setInputVertices(inputIndices);
  }
  for (  GraphVertex gv : vertices) {
    String vertexName=gv.getVertexName();
    List<String> thisVertexOutputsTo=verticesOutputTo.get(vertexName);
    if (thisVertexOutputsTo == null || thisVertexOutputsTo.size() == 0)     continue;
    VertexIndices[] outputIndices=new VertexIndices[thisVertexOutputsTo.size()];
    int j=0;
    for (    String s : thisVertexOutputsTo) {
      GraphVertex next=verticesMap.get(s);
      List<String> nextVertexInputNames;
      nextVertexInputNames=vertexInputs.get(s);
      int outputVertexInputNumber=nextVertexInputNames.indexOf(vertexName);
      int outputVertexIndex=allNamesReverse.get(s);
      outputIndices[j++]=new VertexIndices(outputVertexIndex,outputVertexInputNumber);
    }
    gv.setOutputVertices(outputIndices);
  }
  topologicalOrder=topologicalSortOrder();
  initCalled=true;
}
