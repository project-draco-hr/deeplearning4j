{
  Map<String,Layer> layerMap=new HashMap<>();
  for (  Map.Entry<String,NeuralNetConfiguration> entry : configuration.getLayers().entrySet()) {
    String layerName=entry.getKey();
    NeuralNetConfiguration layerConf=entry.getValue();
    Layer layer=LayerFactories.getFactory(layerConf).create(layerConf,null,-1);
    layerMap.put(layerName,layer);
  }
  Map<String,GraphNode> nodeMap=configuration.getGraphNodes();
  List<String> networkInputNames=configuration.getNetworkInputs();
  Map<String,List<String>> layerInputs=configuration.getLayerInputs();
  Map<String,List<String>> graphNodeInputs=configuration.getGraphNodeInputs();
  int nVertices=layerMap.size() + nodeMap.size() + networkInputNames.size();
  this.vertices=new GraphVertex[nVertices];
  Map<String,Integer> allNamesReverse=new HashMap<>();
  int i=0;
  for (  String name : networkInputNames) {
    GraphVertex gv=new GraphVertex(this,name,i,null);
    allNamesReverse.put(name,i);
    vertices[i++]=gv;
  }
  numLayers=0;
  List<Layer> tempLayerList=new ArrayList<>();
  for (  Map.Entry<String,Layer> layerEntry : layerMap.entrySet()) {
    Layer l=layerEntry.getValue();
    tempLayerList.add(l);
    InputPreProcessor preProcessor=configuration.getInputPreProcessors().get(layerEntry.getKey());
    String name=layerEntry.getKey();
    GraphVertex gv=new GraphVertex(this,name,i,null,null,l,preProcessor);
    allNamesReverse.put(name,i);
    vertices[i++]=gv;
    numLayers++;
  }
  layers=tempLayerList.toArray(new Layer[numLayers]);
  for (  Map.Entry<String,GraphNode> nodeEntry : nodeMap.entrySet()) {
    GraphNode n=nodeEntry.getValue();
    String name=nodeEntry.getKey();
    GraphVertex gv=new GraphVertex(this,name,i,null,null,n);
    allNamesReverse.put(name,i);
    vertices[i++]=gv;
  }
  verticesMap=new HashMap<>();
  for (  GraphVertex gv : vertices) {
    verticesMap.put(gv.getVertexName(),gv);
  }
  Map<String,List<String>> verticesOutputTo=new HashMap<>();
  for (  GraphVertex gv : vertices) {
    String vertexName=gv.getVertexName();
    List<String> vertexInputNames;
    if (gv.getLayer() != null) {
      vertexInputNames=layerInputs.get(vertexName);
    }
 else     if (gv.getGraphNode() != null) {
      vertexInputNames=graphNodeInputs.get(vertexName);
    }
 else {
      vertexInputNames=null;
    }
    if (vertexInputNames == null)     continue;
    for (    String s : vertexInputNames) {
      List<String> list=verticesOutputTo.get(s);
      if (list == null) {
        list=new ArrayList<>();
        verticesOutputTo.put(s,list);
      }
      list.add(vertexName);
    }
  }
  for (  GraphVertex gv : vertices) {
    String vertexName=gv.getVertexName();
    int vertexIndex=gv.getVertexIndex();
    List<String> vertexInputNames;
    if (gv.getLayer() != null) {
      vertexInputNames=layerInputs.get(vertexName);
    }
 else     if (gv.getGraphNode() != null) {
      vertexInputNames=graphNodeInputs.get(vertexName);
    }
 else {
      vertexInputNames=null;
    }
    if (vertexInputNames == null)     continue;
    VertexIndices[] inputIndices=new VertexIndices[vertexInputNames.size()];
    for (int j=0; j < vertexInputNames.size(); j++) {
      String inName=vertexInputNames.get(j);
      int inputVertexIndex=allNamesReverse.get(inName);
      GraphVertex inputVertex=vertices[inputVertexIndex];
      List<String> inputVertexOutputsTo=verticesOutputTo.get(inName);
      int outputNumberOfInput=inputVertexOutputsTo.indexOf(vertexName);
      if (outputNumberOfInput == -1)       throw new IllegalStateException("Could not find vertex " + vertexIndex + " in the list of outputs "+ "for vertex "+ inputVertex+ "; error in graph structure?");
      inputIndices[j]=new VertexIndices(inputVertexIndex,outputNumberOfInput);
    }
    gv.setInputVertices(inputIndices);
  }
  for (  GraphVertex gv : vertices) {
    String vertexName=gv.getVertexName();
    List<String> thisVertexOutputsTo=verticesOutputTo.get(vertexName);
    if (thisVertexOutputsTo == null || thisVertexOutputsTo.size() == 0)     continue;
    VertexIndices[] outputIndices=new VertexIndices[thisVertexOutputsTo.size()];
    int j=0;
    for (    String s : thisVertexOutputsTo) {
      GraphVertex next=verticesMap.get(s);
      List<String> nextVertexInputNames;
      if (next.hasLayer())       nextVertexInputNames=layerInputs.get(s);
 else       nextVertexInputNames=graphNodeInputs.get(s);
      int outputVertexInputNumber=nextVertexInputNames.indexOf(vertexName);
      int outputVertexIndex=allNamesReverse.get(s);
      outputIndices[j++]=new VertexIndices(outputVertexIndex,outputVertexInputNumber);
    }
    gv.setOutputVertices(outputIndices);
  }
  topologicalOrder=topologicalSortOrder();
}
