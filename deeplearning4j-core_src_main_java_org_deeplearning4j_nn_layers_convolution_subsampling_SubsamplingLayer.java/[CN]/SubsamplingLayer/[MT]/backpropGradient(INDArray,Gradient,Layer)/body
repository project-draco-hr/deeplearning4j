{
  int n=epsilon.size(0);
  int c=epsilon.size(1);
  int outH=epsilon.size(2);
  int outW=epsilon.size(3);
  INDArray reshapeEpsilon, reshapeGradient, retE, retG;
  int inputHeight=input().size(-2);
  int inputWidth=input().size(-1);
  Gradient retGradient=new DefaultGradient();
  retGradient.gradientForVariable().put(ConvolutionParamInitializer.BIAS_KEY,gradient.getGradientFor("b"));
switch (conf.getPoolingType()) {
case MAX:
    retE=Nd4j.zeros(n,c,conf.getKernelSize()[0],conf.getKernelSize()[1],outH,outW);
  reshapeEpsilon=Nd4j.rollAxis(retE.reshape(n,c,-1,outH,outW),2);
retG=Nd4j.zeros(n,c,conf.getKernelSize()[0],conf.getKernelSize()[1],outH,outW);
reshapeGradient=Nd4j.rollAxis(retG.reshape(n,c,-1,outH,outW),2);
Iterator<int[]> iter=new NdIndexIterator(n,c,outH,outW);
while (iter.hasNext()) {
int[] next=iter.next();
INDArrayIndex[] indexes=NDArrayIndex.indexesFor(next);
reshapeEpsilon.get(indexes).put(indexes,epsilon.get(indexes));
reshapeGradient.get(indexes).put(indexes,gradient.getGradientFor("W").get(indexes));
}
reshapeEpsilon=Convolution.col2im(reshapeEpsilon,conf.getStride(),conf.getPadding(),inputHeight,inputWidth);
retGradient.gradientForVariable().put(ConvolutionParamInitializer.WEIGHT_KEY,reshapeGradient);
return new Pair<>(retGradient,reshapeEpsilon);
case AVG:
retE=epsilon.get(NDArrayIndex.all(),NDArrayIndex.all(),NDArrayIndex.newAxis(),NDArrayIndex.newAxis(),NDArrayIndex.newAxis());
reshapeEpsilon=Nd4j.tile(retE,1,1,conf.getKernelSize()[0],conf.getKernelSize()[1],1,1);
reshapeEpsilon=Convolution.col2im(reshapeEpsilon,conf.getStride(),conf.getPadding(),inputHeight,inputWidth);
reshapeEpsilon.divi(ArrayUtil.prod(conf.getKernelSize()));
retG=epsilon.get(NDArrayIndex.all(),NDArrayIndex.all(),NDArrayIndex.newAxis(),NDArrayIndex.newAxis(),NDArrayIndex.newAxis());
reshapeGradient=Nd4j.tile(retG,1,1,conf.getKernelSize()[0],conf.getKernelSize()[1],1,1);
reshapeGradient=Convolution.col2im(reshapeGradient,conf.getStride(),conf.getPadding(),inputHeight,inputWidth);
reshapeGradient.divi(ArrayUtil.prod(conf.getKernelSize()));
retGradient.gradientForVariable().put(ConvolutionParamInitializer.WEIGHT_KEY,reshapeGradient);
return new Pair<>(retGradient,reshapeEpsilon);
case NONE:
return new Pair<>(gradient,epsilon);
default :
throw new IllegalStateException("Un supported pooling type");
}
}
