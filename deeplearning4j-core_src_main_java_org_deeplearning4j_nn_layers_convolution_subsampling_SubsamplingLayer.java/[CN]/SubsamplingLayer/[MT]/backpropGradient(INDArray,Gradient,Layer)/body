{
  INDArray z=preOutput(input,true);
  INDArray error=Nd4j.create(conf.getFilterSize());
  if (layer.conf().getPoolingType() == PoolingType.AVG) {
    int[] filterSize=conf.getFilterSize();
    int currLayerFeatureMaps=ConvolutionUtils.numFeatureMap(conf);
    int forwardLayerFeatureMaps=ConvolutionUtils.numFeatureMap(convLayer.conf());
    if (filterSize.length < 4)     throw new IllegalStateException("Illegal filter size found ");
    for (int i=0; i < forwardLayerFeatureMaps; i++) {
      for (int j=0; j < currLayerFeatureMaps; j++) {
        INDArray featureMapError=Nd4j.create(filterSize[0],1,filterSize[filterSize.length - 2],filterSize[filterSize.length - 1]);
        INDArray rotatedFilter=Nd4j.rot(convLayer.getParam(ConvolutionParamInitializer.CONVOLUTION_WEIGHTS).get(NDArrayIndex.all(),NDArrayIndex.all()).slice(i).slice(j));
        INDArray forwardError=z.slice(j);
        featureMapError.addi(Nd4j.getConvolution().convn(forwardError,rotatedFilter,Convolution.Type.FULL));
        error.putSlice(i,featureMapError);
      }
    }
  }
 else   if (layer.conf().getPoolingType() == PoolingType.MAX) {
    int[] filterSize=conf.getFilterSize();
    int currLayerFeatureMaps=ConvolutionUtils.numFeatureMap(conf);
    int forwardLayerFeatureMaps=ConvolutionUtils.numFeatureMap(convLayer.conf());
    if (filterSize.length < 4)     throw new IllegalStateException("Illegal filter size found ");
    for (int i=0; i < forwardLayerFeatureMaps; i++) {
      for (int j=0; j < currLayerFeatureMaps; j++) {
        INDArray featureMapError=Nd4j.create(filterSize[0],1,filterSize[filterSize.length - 2],filterSize[filterSize.length - 1]);
        INDArray rotatedFilter=Nd4j.rot(convLayer.getParam(ConvolutionParamInitializer.CONVOLUTION_WEIGHTS).get(NDArrayIndex.all(),NDArrayIndex.all()).slice(i).slice(j));
        INDArray forwardError=z.slice(j);
        featureMapError.addi(Nd4j.getConvolution().convn(forwardError,rotatedFilter,Convolution.Type.FULL));
        error.putSlice(i,featureMapError);
      }
    }
  }
 else {
    throw new IllegalArgumentException("Convolution type is not average and max");
  }
  Gradient ret=new DefaultGradient();
  ret.gradientForVariable().put(ConvolutionParamInitializer.CONVOLUTION_WEIGHTS,error);
  return new Pair<>(ret,z);
}
