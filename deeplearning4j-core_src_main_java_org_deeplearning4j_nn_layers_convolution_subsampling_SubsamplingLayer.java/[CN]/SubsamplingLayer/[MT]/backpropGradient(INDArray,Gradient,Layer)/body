{
  Gradient ret=new DefaultGradient();
  int height=epsilon.size(-2);
  int width=epsilon.size(-1);
switch (conf.getPoolingType()) {
case MAX:
    int n=epsilon.size(0);
  int c=epsilon.size(1);
int outH=epsilon.size(2);
int outW=epsilon.size(3);
INDArray ret2=Nd4j.zeros(n,c,conf.getKernelSize()[0],conf.getKernelSize()[1],outH,outW);
INDArray reverse=Nd4j.rollAxis(ret2.reshape(n,c,-1,outH,outW),2);
for (int i=0; i < epsilon.tensorssAlongDimension(2); i++) {
INDArray epsilonI=epsilon.tensorAlongDimension(i,2);
ret2.slice(maxIndexes.getInt(i)).putSlice(maxIndexes.getInt(i),epsilonI);
}
reverse.assign(epsilon);
INDArray finalRet=Convolution.col2im(reverse,conf.getStride(),conf.getPadding(),width,height);
ret.gradientForVariable().put(ConvolutionParamInitializer.CONVOLUTION_WEIGHTS,finalRet);
return new Pair<>(ret,finalRet);
case AVG:
INDArray tiled=Nd4j.tile(epsilon.get(NDArrayIndex.all(),NDArrayIndex.all(),NDArrayIndex.newAxis(),NDArrayIndex.newAxis()),1,1,conf.getKernelSize()[0],conf.getKernelSize()[1],1,1);
INDArray convolution=Convolution.col2im(tiled,conf.getStride(),conf.getPadding(),height,width);
convolution.divi(ArrayUtil.prod(conf.getKernelSize()));
ret.gradientForVariable().put(ConvolutionParamInitializer.CONVOLUTION_WEIGHTS,convolution);
return new Pair<>(ret,convolution);
case NONE:
return new Pair<>(gradient,epsilon);
default :
throw new IllegalStateException("Un supported pooling type");
}
}
