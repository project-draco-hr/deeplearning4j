{
  int inputHeight=input().size(-2);
  int inputWidth=input().size(-1);
  INDArray reshapeEpsilon, retE, reshaped;
  Gradient retGradient=new DefaultGradient();
switch (layerConf().getPoolingType()) {
case MAX:
    int n=epsilon.size(0);
  int c=epsilon.size(1);
int outH=epsilon.size(2);
int outW=epsilon.size(3);
retE=Nd4j.zeros(n,c,layerConf().getKernelSize()[0],layerConf().getKernelSize()[1],outH,outW);
reshaped=retE.reshape(n,c,-1,outH,outW);
reshapeEpsilon=Nd4j.rollAxis(reshaped,2);
final INDArray finalEps=epsilon;
final INDArray reshapedEps=reshapeEpsilon;
Shape.iterate(0,4,new int[]{n,c,outH,outW},new int[4],new CoordinateFunction(){
@Override public void process(int[]... coord){
int[] i=coord[0];
double epsGet=finalEps.getDouble(i);
int idx=maxIndexes.getInt(i);
INDArray sliceToGetFrom=reshapedEps.get(NDArrayIndex.point(idx));
sliceToGetFrom.putScalar(i,epsGet);
}
}
);
reshapeEpsilon=Convolution.col2im(retE,layerConf().getStride(),layerConf().getPadding(),inputHeight,inputWidth);
return new Pair<>(retGradient,reshapeEpsilon);
case AVG:
retE=epsilon.get(NDArrayIndex.all(),NDArrayIndex.all(),NDArrayIndex.newAxis(),NDArrayIndex.newAxis());
reshapeEpsilon=Nd4j.tile(retE,1,1,layerConf().getKernelSize()[0],layerConf().getKernelSize()[1],1,1);
reshapeEpsilon=Convolution.col2im(reshapeEpsilon,layerConf().getStride(),layerConf().getPadding(),inputHeight,inputWidth);
reshapeEpsilon.divi(ArrayUtil.prod(layerConf().getKernelSize()));
return new Pair<>(retGradient,reshapeEpsilon);
case NONE:
return new Pair<>(retGradient,epsilon);
default :
throw new IllegalStateException("Un supported pooling type");
}
}
