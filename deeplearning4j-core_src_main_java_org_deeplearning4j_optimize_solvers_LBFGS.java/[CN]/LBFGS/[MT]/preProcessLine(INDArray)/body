{
  INDArray oldParameters=(INDArray)searchState.get("oldparams");
  INDArray params=(INDArray)searchState.get(PARAMS_KEY);
  oldParameters.assign(params.sub(oldParameters));
  INDArray oldGradient=(INDArray)searchState.get("oldgradient");
  INDArray gradient=(INDArray)searchState.get(GRADIENT_KEY);
  oldGradient.subi(gradient);
  double sy=Nd4j.getBlasWrapper().dot(oldParameters,oldGradient) + Nd4j.EPS_THRESHOLD;
  double yy=Transforms.pow(oldGradient,2).sum(Integer.MAX_VALUE).getDouble(0) + Nd4j.EPS_THRESHOLD;
  double gamma=sy / yy;
  LinkedList<Double> rho=(LinkedList<Double>)searchState.get("rho");
  rho.add(1.0 / sy);
  LinkedList<INDArray> s=(LinkedList<INDArray>)searchState.get("s");
  s.add(oldParameters);
  LinkedList<INDArray> y=(LinkedList<INDArray>)searchState.get("y");
  y.add(oldGradient);
  if (s.size() != y.size())   throw new IllegalStateException("S and y mis matched sizes");
  INDArray alpha=(INDArray)searchState.get("alpha");
  for (int i=s.size() - 1; i >= 0; i--) {
    if (s.get(i).length() != gradient.length())     throw new IllegalStateException("Gradient and s length not equal");
    if (i >= alpha.length())     break;
    if (i > rho.size())     throw new IllegalStateException("I > rho size");
    alpha.putScalar(i,rho.get(i) * Nd4j.getBlasWrapper().dot(gradient,s.get(i)));
    if (alpha.data().dataType() == DataBuffer.DOUBLE)     Nd4j.getBlasWrapper().axpy(-1.0 * alpha.getDouble(i),gradient,y.get(i));
 else     Nd4j.getBlasWrapper().axpy(-1.0f * alpha.getFloat(i),gradient,y.get(i));
  }
  gradient.muli(gamma);
  for (int i=0; i < y.size(); i++) {
    if (i >= alpha.length())     break;
    double beta=rho.get(i) * Nd4j.getBlasWrapper().dot(y.get(i),gradient);
    if (alpha.data().dataType() == DataBuffer.DOUBLE)     Nd4j.getBlasWrapper().axpy(alpha.getDouble(i) * beta,gradient,s.get(i));
 else     Nd4j.getBlasWrapper().axpy(alpha.getFloat(i) * (float)beta,gradient,s.get(i));
  }
  oldParameters.assign(params);
  oldGradient.assign(gradient);
  gradient.muli(-1);
}
