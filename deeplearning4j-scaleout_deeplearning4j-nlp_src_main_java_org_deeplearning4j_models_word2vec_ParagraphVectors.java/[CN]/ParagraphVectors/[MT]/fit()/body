{
  boolean loaded=buildVocab();
  if (!loaded && saveVocab)   cache.saveVocab();
  if (stopWords == null)   readStopWords();
  log.info("Training paragraph vectors multithreaded");
  if (sentenceIter != null)   sentenceIter.reset();
  if (docIter != null)   docIter.reset();
  final int[] docs=vectorizer.index().allDocs();
  final AtomicInteger numSentencesProcessed=new AtomicInteger(0);
  totalWords=vectorizer.numWordsEncountered();
  totalWords*=numIterations;
  log.info("Processing sentences...");
  List<Thread> work=new ArrayList<>();
  final AtomicInteger processed=new AtomicInteger(0);
  for (int i=0; i < Runtime.getRuntime().availableProcessors(); i++) {
    Thread t=new Thread(new Runnable(){
      @Override public void run(){
        final AtomicLong nextRandom=new AtomicLong(5);
        while (true) {
          if (processed.get() >= docs.length)           break;
          List<VocabWord> job=jobQueue.poll();
          if (job == null)           continue;
          trainSentence(job,numSentencesProcessed,nextRandom);
          processed.incrementAndGet();
        }
      }
    }
);
    t.setName("worker" + i);
    t.setDaemon(true);
    t.start();
    work.add(t);
  }
  final List<VocabWord> batch=new ArrayList<>(batchSize);
  final AtomicLong nextRandom=new AtomicLong(5);
  final AtomicInteger doc=new AtomicInteger(0);
  final int numDocs=vectorizer.index().numDocuments();
  ExecutorService exec=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  for (int i=0; i < numIterations; i++)   vectorizer.index().eachDoc(new Function<List<VocabWord>,Void>(){
    @Nullable @Override public Void apply(    @Nullable List<VocabWord> input){
      addWords(input,nextRandom,batch);
      try {
        while (!jobQueue.offer(batch,1,TimeUnit.MILLISECONDS)) {
          Thread.sleep(1);
        }
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
      doc.incrementAndGet();
      if (doc.get() > 0 && doc.get() % 10000 == 0)       log.info("Doc " + doc.get() + " done so far out of "+ numDocs);
      batch.clear();
      return null;
    }
  }
,exec);
  if (!jobQueue.isEmpty()) {
    jobQueue.add(new ArrayList<>(batch));
    batch.clear();
  }
  for (int i=0; i < work.size(); i++)   jobQueue.add(new ArrayList<VocabWord>());
  for (  Thread t : work)   try {
    t.join();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  for (int i=0; i < numIterations; i++) {
    log.info("Training on " + docs.length);
  }
}
