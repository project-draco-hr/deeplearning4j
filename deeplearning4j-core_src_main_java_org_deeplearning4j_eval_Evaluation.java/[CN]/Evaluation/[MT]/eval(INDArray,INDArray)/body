{
  numRowCounter+=realOutcomes.shape()[0];
  if (confusion == null) {
    log.warn("Creating confusion matrix based on classes passed in . Will assume the label distribution passed in is indicative of the overall dataset");
    Set<Integer> classes=new HashSet<>();
    for (int i=0; i < realOutcomes.rows(); i++) {
      classes.add(Nd4j.getBlasWrapper().iamax(realOutcomes.slice(i)));
    }
    confusion=new ConfusionMatrix<>(new ArrayList<>(classes));
  }
  if (realOutcomes.length() != guesses.length())   throw new IllegalArgumentException("Unable to evaluate. Outcome matrices not same length");
  for (int i=0; i < realOutcomes.rows(); i++) {
    INDArray currRow=realOutcomes.getRow(i);
    INDArray guessRow=guesses.getRow(i);
    int currMax;
{
      double max=currRow.getDouble(0);
      currMax=0;
      for (int col=1; col < currRow.columns(); col++) {
        if (currRow.getDouble(col) > max) {
          max=currRow.getDouble(col);
          currMax=col;
        }
      }
    }
    int guessMax;
{
      double max=guessRow.getDouble(0);
      guessMax=0;
      for (int col=1; col < guessRow.columns(); col++) {
        if (guessRow.getDouble(col) > max) {
          max=guessRow.getDouble(col);
          guessMax=col;
        }
      }
    }
    addToConfusion(currMax,guessMax);
    if (currMax == guessMax) {
      incrementTruePositives(guessMax);
      for (      Integer clazz : confusion.getClasses()) {
        if (clazz != guessMax)         trueNegatives.incrementCount(clazz,1.0);
      }
    }
 else {
      incrementFalseNegatives(currMax);
      incrementFalsePositives(guessMax);
      for (      Integer clazz : confusion.getClasses()) {
        if (clazz != guessMax && clazz != currMax)         trueNegatives.incrementCount(clazz,1.0);
      }
    }
  }
}
