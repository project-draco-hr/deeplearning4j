{
  int[][] oldShapeAndStride=getNonOneStridesAndShape();
  int[] oldShape=oldShapeAndStride[0];
  int[] oldStride=oldShapeAndStride[1];
  int newNd=shape.length;
  int oldNd=oldShapeAndStride[0].length;
  int np, op;
  int nk;
  if (ArrayUtil.prod(shape) != ArrayUtil.prod(oldShape))   return null;
  if (ArrayUtil.prod(shape) == 0)   return null;
  int[] newStrides=new int[oldStride.length];
  int ni=0, oi=0, nj=1, oj=1;
  for (; ni < newNd && oi < oldNd; ni=nj++, oi=oj++) {
    np=shape[ni];
    op=oldShape[oi];
    while (np != op) {
      if (np < op)       np*=shape[nj++];
 else       op*=oldShape[oj++];
    }
    for (int ok=oi; ok < oj - 1; ok++) {
      if (ordering == NDArrayFactory.FORTRAN) {
        if (oldStride[ok + 1] != oldStride[ok] * oldStride[ok])         return null;
      }
 else {
        if (oldStride[ok] != oldShape[ok + 1] * oldStride[ok + 1])         return null;
      }
    }
  }
  return NDArrays.getStrides(shape,ordering);
}
