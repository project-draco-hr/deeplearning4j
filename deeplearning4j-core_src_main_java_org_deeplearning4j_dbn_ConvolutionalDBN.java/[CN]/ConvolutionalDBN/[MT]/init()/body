{
  if (!(rng instanceof SynchronizedRandomGenerator))   rng=new SynchronizedRandomGenerator(rng);
  if (getnLayers() < 1)   throw new IllegalStateException("Unable to createComplex network layers; number specified is less than 1");
  if (this.dist == null)   dist=new NormalDistribution(rng,0,.01,NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
  this.layers=new NeuralNetwork[getnLayers()];
  int nInY, nInX, nInFM, nFm=-1;
  for (int i=0; i < getnLayers(); i++) {
    ConvolutionalRBM prevLayer=(ConvolutionalRBM)getLayers()[i];
    if (i == 0) {
      nInY=input.rows();
      nInX=input.columns();
      nInFM=input.slices();
    }
 else {
      nInX=prevLayer.getFmSize()[1];
      nInY=prevLayer.getFmSize()[0];
      nInFM=prevLayer.getFmSize()[0];
    }
    nFm=this.nFm[i];
    INDArray filterSize=ArrayUtil.toNDArray(this.filterSizes[i]);
    INDArray fmSize=ArrayUtil.toNDArray(new int[]{nInY,nInX}).sub(filterSize).add(1);
    float prodFilterSize=ArrayUtil.prod(this.filterSizes[i]);
    INDArray stride=ArrayUtil.toNDArray(this.stride[i]);
    float fanIn=nInFM * prodFilterSize;
    float fanOut=nFm * prodFilterSize;
    float range=2 * (float)FastMath.sqrt(6 / fanIn + fanOut);
    INDArray W=NDArrays.rand(new int[]{(int)filterSize.getScalar(0).element(),(int)filterSize.getScalar(1).element(),nInFM,nFm},dist).mul(range);
    ConvolutionalRBM r=new ConvolutionalRBM.Builder().withDistribution(getDist()).withDropOut(getDropOut()).withOptmizationAlgo(getOptimizationAlgorithm()).withFilterSize(ArrayUtil.toInts(filterSize)).withInput(input).numberOfVisible(1).useAdaGrad(isUseAdaGrad()).normalizeByInputRows(normalizeByInputRows).numHidden(1).withHBias(NDArrays.zeros(nFm,1)).withMomentum(getMomentum()).withL2(getL2()).useRegularization(isUseRegularization()).withRandom(rng).withLossFunction(getLossFunction()).withFmSize(ArrayUtil.toInts(fmSize)).withStride(this.stride[i]).withNumFilters(new int[]{nFm,nFm}).withSparseGain(sparseGain).withSparsity(getSparsity()).withWeights(W).build();
    this.layers[i]=r;
    DownSamplingLayer d=new DownSamplingLayer.Builder().dist(dist).withStride(this.stride[i]).withFmSize(Transforms.floor(ArrayUtil.toNDArray(r.getFmSize()).div(stride))).numFeatureMaps(nFm).withBias(r.gethBias()).withRng(rng).build();
    this.sigmoidLayers[i]=d;
  }
  ConvolutionalRBM r=(ConvolutionalRBM)getLayers()[getLayers().length - 1];
  int nFmIn=r.getNumFilters()[0];
  int nOuts=r.getFmSize()[0] * r.getFmSize()[1] * nFmIn;
  this.outputLayer=new OutputLayer.Builder().useAdaGrad(useAdaGrad).optimizeBy(getOptimizationAlgorithm()).normalizeByInputRows(normalizeByInputRows).useRegularization(useRegularization).numberOfInputs(nFmIn).numberOfOutputs(nOuts).withL2(l2).build();
  synchonrizeRng();
  applyTransforms();
  initCalled=true;
}
