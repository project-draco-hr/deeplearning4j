{
  ActivationFunction a=getSigmoidLayers()[0].getActivationFunction();
  ActivationFunction softMaxDerivative=Activations.softMaxRows();
  List<INDArray> activations=feedForward();
  INDArray error=labels.sub(activations.get(activations.size() - 1)).neg().mul(softMaxDerivative.applyDerivative(activations.get(activations.size() - 1)));
  INDArray es=outputLayer.getW().transpose().mmul(error);
  DownSamplingLayer d=(DownSamplingLayer)getSigmoidLayers()[getSigmoidLayers().length - 1];
  ConvolutionalRBM rbm=(ConvolutionalRBM)getLayers()[getnLayers() - 1];
  INDArray[] errorSignals=new INDArray[getnLayers()];
  INDArray[] biasGradients=new INDArray[getnLayers()];
  INDArray layerErrorSignal=NDArrays.zeros(d.getFeatureMap().shape());
  errorSignals[errorSignals.length - 1]=es;
  int nMap=layerErrorSignal.size(0) * layerErrorSignal.size(1);
  for (int i=0; i < rbm.getNumFilters()[0]; i++) {
    INDArray subSlice=es.get(NDArrayIndex.interval(i * nMap,(i + 1) * nMap),NDArrayIndex.interval(0,es.columns()));
    INDArray reshaped=subSlice.reshape(d.getFeatureMap().shape());
    layerErrorSignal.putSlice(i,reshaped);
  }
  errorSignals[errorSignals.length - 2]=layerErrorSignal;
  for (int i=getnLayers() - 2; i >= 0; i--) {
    DownSamplingLayer layer=(DownSamplingLayer)getSigmoidLayers()[i];
    ConvolutionalRBM r2=(ConvolutionalRBM)getLayers()[i];
    DownSamplingLayer forwardDownSamplingLayer=(DownSamplingLayer)getSigmoidLayers()[i + 1];
    ConvolutionalRBM forwardRBM=(ConvolutionalRBM)getLayers()[i + 1];
    int[] stride=forwardRBM.getStride();
    INDArray propErrorSignal=NDArrays.zeros(d.getFeatureMap().shape());
    for (int k=0; k < layer.getNumFeatureMaps(); k++) {
      INDArray rotFilter=NDArrays.rot(forwardRBM.getW().slice(i).slice(k));
      INDArray tensor=errorSignals[i + 1];
      INDArray currEs=tensor.slice(k);
      propErrorSignal.addi(Convolution.convn(currEs,rotFilter,Convolution.Type.FULL));
    }
    errorSignals[i]=propErrorSignal;
    INDArray mapSize=forwardRBM.getFeatureMap();
    INDArray rbmEs=NDArrays.zeros(mapSize.shape());
    for (int k=0; k < rbm.getNumFilters()[0]; k++) {
      INDArray propEs=Transforms.upSample(forwardDownSamplingLayer.getFeatureMap().slice(k),ArrayUtil.toNDArray(new int[]{stride[0],stride[1],1,1})).divi(ArrayUtil.prod(stride));
      rbmEs.putSlice(k,propEs);
    }
    errorSignals[i - 1]=rbmEs;
  }
  for (int i=getnLayers() - 2; i >= 0; i--) {
    ConvolutionalRBM r2=(ConvolutionalRBM)getLayers()[i];
    ConvolutionalRBM prevRBM=(ConvolutionalRBM)getLayers()[i - 1];
    INDArray errorSignal=errorSignals[i - 1];
    INDArray biasGradient=NDArrays.create(1,r2.getNumFilters()[0]);
    for (int j=0; j < r2.getNumFilters()[0]; j++) {
      INDArray es2=errorSignal.slice(j);
      for (int k=0; k < prevRBM.getNumFilters()[0]; k++) {
        INDArray flipped=NDArrays.reverse(prevRBM.getFeatureMap().slice(k));
        INDArray dedFilter=Convolution.convn(flipped,es2,Convolution.Type.VALID);
        r2.getdWeights().put(j,k,dedFilter);
      }
      biasGradient.put(j,es.sum(1).div(errorSignal.slices()).sum(Integer.MAX_VALUE));
    }
    biasGradients[i]=biasGradient;
  }
  for (int i=0; i < biasGradients.length; i++) {
    deltaRet.add(errorSignals[i]);
  }
  deltaRet.add(errorSignals[errorSignals.length - 1].mmul(outputLayer.getInput()));
}
