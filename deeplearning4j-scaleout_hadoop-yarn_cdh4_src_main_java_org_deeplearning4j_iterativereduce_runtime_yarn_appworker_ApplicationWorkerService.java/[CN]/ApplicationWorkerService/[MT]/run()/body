{
  Thread.currentThread().setName("ApplicationWorkerService Thread - " + Utils.getWorkerId(workerId));
  if (!initializeService())   return -1;
  LOG.info("Worker " + Utils.getWorkerId(workerId) + " initialized");
  recordParser.setFile(workerConf.getSplit().getPath().toString(),workerConf.getSplit().getOffset(),workerConf.getSplit().getLength());
  recordParser.parse();
  LOG.debug("Launching periodic update thread");
  updateExecutor=Executors.newSingleThreadExecutor();
  updateExecutor.execute(new PeridoicUpdateThread());
  currentState=WorkerState.STARTED;
  int countTotal=0;
  int countCurrent=0;
  int currentIteration=0;
  int lastUpdate=0;
  computable.setRecordParser(recordParser);
  for (currentIteration=0; currentIteration < workerConf.getIterations(); currentIteration++) {
    LOG.debug("Beginning iteration " + (currentIteration + 1) + "/"+ workerConf.getIterations());
synchronized (currentState) {
      currentState=WorkerState.RUNNING;
    }
    recordParser.reset();
    countTotal++;
    countCurrent++;
synchronized (progressCounters) {
      progressCounters.put("countTotal",countTotal);
      progressCounters.put("countCurrent",countCurrent);
      progressCounters.put("currentIteration",currentIteration);
    }
    long mWorkerStart=System.currentTimeMillis();
    T workerUpdate=computable.compute();
    mWorkerExecutions++;
    mWorkerTime+=(System.currentTimeMillis() - mWorkerStart);
    try {
synchronized (currentState) {
        ByteBuffer bytes=workerUpdate.toBytes();
        bytes.rewind();
        LOG.info("Sending an update to master");
        currentState=WorkerState.UPDATE;
        if (!masterService.update(workerId,bytes))         LOG.warn("The master rejected our update");
        mUpdates++;
      }
    }
 catch (    AvroRemoteException ex) {
      LOG.error("Unable to send update message to master",ex);
      return -1;
    }
    int nextUpdate;
    try {
      LOG.info("Completed a batch, waiting on an update from master");
      nextUpdate=waitOnMasterUpdate(lastUpdate);
    }
 catch (    InterruptedException ex) {
      LOG.warn("Interrupted while waiting on master",ex);
      return -1;
    }
catch (    AvroRemoteException ex) {
      LOG.error("Got an error while waiting on updates from master",ex);
      return -1;
    }
    try {
      ByteBuffer b=masterService.fetch(workerId,nextUpdate);
      b.rewind();
      T masterUpdate=updateable.newInstance();
      masterUpdate.fromBytes(b);
      computable.update(masterUpdate);
      lastUpdate=nextUpdate;
      LOG.info("Requested to fetch an update from master" + ", workerId=" + Utils.getWorkerId(workerId) + ", requestedUpdatedId="+ nextUpdate+ ", lastUpdate="+ lastUpdate+ ", responseLength="+ b.limit());
    }
 catch (    AvroRemoteException ex) {
      LOG.error("Got exception while fetching an update from master",ex);
      return -1;
    }
catch (    Exception ex) {
      LOG.error("Got exception while processing update from master",ex);
      return -1;
    }
    countCurrent=0;
  }
  reportMetrics();
  T finalUpdate=computable.getResults();
  if (finalUpdate != null) {
    try {
      LOG.info("Sending final update to master");
      masterService.update(workerId,finalUpdate.toBytes());
    }
 catch (    AvroRemoteException ex) {
      LOG.warn("Failed to send final update to master",ex);
    }
  }
  LOG.info("Completed processing, notfiying master that we're done");
  masterService.complete(workerId,createProgressReport());
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException ex) {
  }
  nettyTransceiver.close();
  updateExecutor.shutdownNow();
  LOG.debug("Returning with code 0");
  return 0;
}
