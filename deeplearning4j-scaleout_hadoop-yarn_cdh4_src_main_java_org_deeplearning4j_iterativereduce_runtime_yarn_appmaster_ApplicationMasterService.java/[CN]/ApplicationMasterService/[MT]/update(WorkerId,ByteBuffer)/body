{
  WorkerState workerState;
synchronized (workersState) {
    workerState=workersState.get(workerId);
    if (workerState != null) {
      if (workerState != WorkerState.RUNNING && workerState != WorkerState.STARTED) {
        LOG.debug("Received an erroneous update" + ", workerId=" + Utils.getWorkerId(workerId) + ", workerState="+ workerState+ ", length="+ data.limit());
        return false;
      }
    }
  }
  LOG.info("Received update, workerId=" + Utils.getWorkerId(workerId) + ", workerState="+ workerState+ ", length="+ data.limit());
synchronized (masterState) {
    if (MasterState.WAITING == masterState) {
      LOG.debug("Initial update for this round, initializing update map");
      if (workersUpdate == null)       workersUpdate=new HashMap<WorkerId,T>();
      workersUpdate.clear();
      masterState=MasterState.UPDATING;
    }
  }
  if (workersUpdate.containsKey(workerId)) {
    LOG.warn("Received a duplicate update for, workerId=" + Utils.getWorkerId(workerId) + ", ignoring this update");
    return false;
  }
  T update;
  try {
    update=updateable.newInstance();
    update.fromBytes(data);
  }
 catch (  Exception ex) {
    LOG.warn("Unable to instantiate a computable object",ex);
    return false;
  }
synchronized (workersState) {
    workersUpdate.put(workerId,update);
    workersState.put(workerId,WorkerState.UPDATE);
    if (workersUpdate.size() == expectedUpdates.get()) {
      LOG.info("Received updates from all workers, spawing local compute thread");
      Thread updateThread=new Thread(new Runnable(){
        @Override public void run(){
          long startTime, endTime;
          startTime=System.currentTimeMillis();
          T result=computable.compute(workersUpdate.values(),masterUpdates.values());
          endTime=System.currentTimeMillis();
          LOG.info("Computed local update in " + (endTime - startTime) + "ms");
          expectedUpdates.set(workersCompleted.getCount());
          mMasterExecutions++;
          mMasterTime+=(endTime - startTime);
synchronized (masterUpdates) {
            currentUpdateId++;
            masterUpdates.put(currentUpdateId,result);
            LOG.info("Adding master update for " + currentUpdateId + "");
            masterState=MasterState.WAITING;
          }
        }
      }
);
      updateThread.setName("Compute thread");
      updateThread.start();
    }
  }
  mUpdates++;
  return true;
}
