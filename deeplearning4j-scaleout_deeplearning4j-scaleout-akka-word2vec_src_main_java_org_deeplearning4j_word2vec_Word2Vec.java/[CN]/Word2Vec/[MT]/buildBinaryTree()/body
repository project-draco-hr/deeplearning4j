{
  PriorityQueue<VocabWord> heap=new PriorityQueue<>(vocab.values());
  int i=0;
  while (heap.size() > 1) {
    VocabWord min1=heap.poll();
    VocabWord min2=heap.poll();
    VocabWord add=new VocabWord(min1.getWordFrequency() + min2.getWordFrequency(),layerSize);
    int index=(vocab.size() + i);
    add.setIndex(index);
    add.setLeft(min1);
    add.setRight(min2);
    min1.setCode(0);
    min2.setCode(1);
    min1.setParent(add);
    min2.setParent(add);
    heap.add(add);
    i++;
  }
  Triple<VocabWord,int[],int[]> triple=new Triple<>(heap.poll(),new int[]{},new int[]{});
  Stack<Triple<VocabWord,int[],int[]>> stack=new Stack<>();
  stack.add(triple);
  while (!stack.isEmpty()) {
    triple=stack.pop();
    int[] codes=triple.getSecond();
    int[] points=triple.getThird();
    VocabWord node=triple.getFirst();
    if (node == null) {
      log.info("Node was null");
      continue;
    }
    if (node.getIndex() < vocab.size()) {
      node.setCodes(codes);
      node.setPoints(points);
    }
 else {
      int[] copy=plus(points,node.getIndex() - vocab.size());
      points=copy;
      triple.setThird(points);
      stack.add(new Triple<>(node.getLeft(),plus(codes,0),points));
      stack.add(new Triple<>(node.getRight(),plus(codes,1),points));
    }
  }
  log.info("Built tree");
}
