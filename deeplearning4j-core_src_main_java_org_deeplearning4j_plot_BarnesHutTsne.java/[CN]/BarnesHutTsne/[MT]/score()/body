{
  int QT_NO_DIMS=2;
  QuadTree tree=new QuadTree(y);
  INDArray buff=Nd4j.create(QT_NO_DIMS);
  AtomicDouble sum_Q=new AtomicDouble(0.0);
  for (int n=0; n < y.rows(); n++)   tree.computeNonEdgeForces(n,theta,buff,sum_Q);
  double C=.0, Q;
  for (int n=0; n < y.rows(); n++) {
    int begin=rows.getInt(n);
    int end=rows.getInt(n + 1);
    for (int i=begin; i < end; i++) {
      buff.assign(y.slice(n));
      buff.subi(y.slice(cols.getInt(i)));
      Q=Nd4j.getBlasWrapper().dot(buff,buff);
      Q=(1.0 / (1.0 + Q)) / sum_Q.doubleValue();
      double val=vals.getDouble(i,0);
      double add=Math.log((val + Double.MIN_VALUE) / (Q + Double.MAX_VALUE));
      if (Double.isNaN(add) || Double.isInfinite(add))       add=Nd4j.EPS_THRESHOLD;
      C+=val * add;
    }
  }
  return C;
}
