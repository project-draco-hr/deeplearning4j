{
  int QT_NO_DIMS=2;
  QuadTree tree=new QuadTree(y);
  INDArray buff=Nd4j.create(QT_NO_DIMS);
  AtomicDouble sum_Q=new AtomicDouble(0.0);
  for (int n=0; n < N; n++)   tree.computeNonEdgeForces(n,theta,buff,sum_Q);
  double C=.0;
  INDArray linear=y.linearView();
  for (int n=0; n < N; n++) {
    int begin=rows.getInt(n);
    int end=rows.getInt(n + 1);
    int ind1=n * QT_NO_DIMS;
    for (int i=begin; i < end; i++) {
      int ind2=cols.getInt(i) * QT_NO_DIMS;
      buff.assign(linear.get(NDArrayIndex.interval(ind1,ind1 + QT_NO_DIMS)));
      buff.subi(linear.get(NDArrayIndex.interval(ind2,ind2 + QT_NO_DIMS)));
      double Q=pow(buff,2).sum(Integer.MAX_VALUE).getDouble(0);
      Q=(1.0 / (1.0 + Q)) / sum_Q.doubleValue();
      double val=vals.getDouble(i);
      double add=Math.log((val + Double.MIN_VALUE) / (Q + Double.MAX_VALUE));
      if (Double.isNaN(add) || Double.isInfinite(add))       add=Nd4j.EPS_THRESHOLD;
      C+=val * add;
    }
  }
  return C;
}
