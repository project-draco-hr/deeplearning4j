{
  N=d.rows();
  final int k=(int)(3 * u);
  if (u > k)   throw new IllegalStateException("Illegal k value " + k + "greater than "+ u);
  rows=zeros(N + 1);
  cols=zeros(N * k);
  vals=zeros(N * k);
  for (int n=0; n < N; n++)   rows.putScalar(n + 1,rows.getDouble(n) + k);
  final INDArray beta=ones(N,1);
  final double logU=FastMath.log(u);
  final List<VpTreePointINDArray> list=VpTreePointINDArray.dataPoints(d);
  final VpTreeNode<VpTreePointINDArray> tree=VpTreeNode.buildVpTree(list);
  log.info("Calculating probabilities of data similarities...");
  for (int i=0; i < N; i++) {
    if (i % 500 == 0)     log.info("Handled " + i + " records");
    double betaMin=-Double.MAX_VALUE;
    double betaMax=Double.MAX_VALUE;
    Counter<VpTreePointINDArray> c=tree.findNearByPointsWithDistancesK(list.get(i),k + 1);
    double betas=beta.getDouble(i);
    INDArray cArr=toNDArray(c);
    Pair<INDArray,Double> pair=computeGaussianKernel(cArr,beta.getDouble(i),k);
    INDArray currP=pair.getFirst();
    double hDiff=pair.getSecond() - logU;
    int tries=0;
    boolean found=false;
    while (!found && tries < 200) {
      if (hDiff < tolerance && -hDiff < tolerance)       found=true;
 else {
        if (hDiff > 0) {
          betaMin=betas;
          if (betaMax == Double.MAX_VALUE || betaMax == -Double.MAX_VALUE)           betas*=2;
 else           betas=(betas + betaMax) / 2.0;
        }
 else {
          betaMax=betas;
          if (betaMin == -Double.MAX_VALUE || betaMin == Double.MAX_VALUE)           betas/=2.0;
 else           betas=(betas + betaMin) / 2.0;
        }
        pair=computeGaussianKernel(cArr,betas,k);
        hDiff=pair.getSecond() - logU;
        tries++;
      }
    }
    currP.divi(currP.sum(Integer.MAX_VALUE));
    INDArray indices=toIndex(c,k);
    for (int l=0; l < k; l++) {
      cols.putScalar(rows.getInt(i) + l,indices.getDouble(l + 1));
      vals.putScalar(rows.getInt(i) + l,currP.getDouble(l));
    }
  }
  return vals;
}
