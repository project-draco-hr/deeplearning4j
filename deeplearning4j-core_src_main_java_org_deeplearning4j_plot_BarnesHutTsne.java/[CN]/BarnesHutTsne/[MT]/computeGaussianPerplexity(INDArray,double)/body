{
  int N=d.rows();
  final int k=(int)(3 * u);
  rows=zeros(N + 1);
  cols=zeros(N,k);
  vals=zeros(N,k);
  for (int n=1; n < N; n++)   rows.putScalar(n,rows.getDouble(n - 1) + k);
  final INDArray beta=ones(N,1);
  final double logU=Math.log(u);
  final List<VpTreePointINDArray> list=VpTreePointINDArray.dataPoints(d);
  final VpTreeNode<VpTreePointINDArray> tree=VpTreeNode.buildVpTree(list);
  log.info("Calculating probabilities of data similarities...");
  for (int i=0; i < N; i++) {
    if (i % 500 == 0)     log.info("Handled " + i + " records");
    final int j=i;
    double betaMin=Double.NEGATIVE_INFINITY;
    double betaMax=Double.POSITIVE_INFINITY;
    Counter<VpTreePointINDArray> c=tree.findNearByPointsWithDistancesK(list.get(j),k + 1);
    INDArray cArr=toNDArray(c);
    Pair<INDArray,Double> pair=computeGaussianKernel(cArr,beta.getDouble(j));
    INDArray currP=pair.getFirst();
    double hDiff=pair.getSecond() - logU;
    int tries=0;
    boolean found=false;
    while (!found && tries < 50) {
      if (hDiff < tolerance && -hDiff < tolerance)       found=true;
 else {
        if (hDiff > 0) {
          if (Double.isInfinite(betaMax))           beta.putScalar(j,beta.getDouble(j) * 2.0);
 else           beta.putScalar(j,(beta.getDouble(j) + betaMax) / 2.0);
          betaMin=beta.getDouble(j);
        }
 else {
          if (Double.isInfinite(betaMin))           beta.putScalar(j,beta.getDouble(j) / 2.0);
 else           beta.putScalar(j,(beta.getDouble(j) + betaMin) / 2.0);
          betaMax=beta.getDouble(j);
        }
        pair=computeGaussianKernel(toNDArray(c),beta.getDouble(j));
        hDiff=pair.getSecond() - logU;
        tries++;
      }
    }
    INDArray currPAssign=currP.div(currP.sum(Integer.MAX_VALUE));
    INDArray indices=toIndex(c);
    for (int l=0; l < indices.length(); l++) {
      cols.putScalar(new int[]{rows.getInt(n),l},indices.getDouble(l));
      vals.putScalar(new int[]{rows.getInt(n),l},currPAssign.getDouble(l));
    }
    cols.slice(j).put(new NDArrayIndex[]{NDArrayIndex.interval(0,indices.length())},indices);
  }
  return vals;
}
