{
  WeightLookupTable lookupTable;
  VocabCache cache;
  List<File> vectorPaths=new ArrayList<>();
  File rootDir=new File("." + UUID.randomUUID().toString());
  if (!rootDir.mkdirs())   throw new IllegalStateException("Unable to create directory for word vectors");
  if (binary) {
    DataInputStream dis=null;
    BufferedInputStream bis=null;
    double len;
    float vector;
    int words, size=0;
    try {
      bis=new BufferedInputStream(new FileInputStream(path));
      dis=new DataInputStream(bis);
      words=Integer.parseInt(readString(dis));
      size=Integer.parseInt(readString(dis));
      cache=new InMemoryLookupCache(false);
      lookupTable=new InMemoryLookupTable.Builder().cache(cache).vectorLength(size).build();
      String word;
      float[] vectors;
      for (int i=0; i < words; i++) {
        word=readString(dis);
        if (word.isEmpty())         continue;
        vectors=new float[size];
        len=0;
        for (int j=0; j < size; j++) {
          vector=readFloat(dis);
          len+=vector * vector;
          vectors[j]=vector;
        }
        len=Math.sqrt(len);
        for (int j=0; j < size; j++)         vectors[j]/=len;
        File write=new File(rootDir,String.valueOf(i));
        vectorPaths.add(write);
        writeVector(vectors,write);
        cache.addWordToIndex(cache.numWords(),word);
        cache.addToken(new VocabWord(1,word));
        cache.putVocabWord(word);
        dis.read();
      }
    }
  finally {
      bis.close();
      dis.close();
    }
    Word2Vec ret=new Word2Vec();
    lookupTable.resetWeights();
    for (int i=0; i < vectorPaths.size(); i++) {
      float[] read=readVec(vectorPaths.get(i),size);
      lookupTable.putVector(cache.wordAtIndex(i),Nd4j.create(read));
      vectorPaths.get(i).delete();
    }
    ret.setVocab(cache);
    ret.setLookupTable(lookupTable);
    rootDir.delete();
    return ret;
  }
 else {
    BufferedReader reader=new BufferedReader(new FileReader(new File(path)));
    String line=reader.readLine();
    String[] initial=line.split(" ");
    int words=Integer.parseInt(initial[0]);
    int layerSize=Integer.parseInt(initial[1]);
    cache=new InMemoryLookupCache();
    while ((line=reader.readLine()) != null) {
      String[] split=line.split(" ");
      String word=split[0];
      if (word.isEmpty())       continue;
      float[] buffer=new float[layerSize];
      for (int i=1; i < split.length; i++) {
        buffer[i - 1]=Float.parseFloat(split[i]);
      }
      File vecFile=new File(rootDir,String.valueOf(cache.numWords()));
      writeVector(buffer,vecFile);
      vectorPaths.add(vecFile);
      cache.addWordToIndex(cache.numWords(),word);
      cache.addToken(new VocabWord(1,word));
      cache.putVocabWord(word);
    }
    lookupTable=new InMemoryLookupTable.Builder().cache(cache).vectorLength(layerSize).build();
    lookupTable.resetWeights();
    for (int i=0; i < words; i++) {
      float[] read=readVec(vectorPaths.get(i),layerSize);
      lookupTable.putVector(cache.wordAtIndex(i),Nd4j.create(read));
      vectorPaths.get(i).delete();
    }
    Word2Vec ret=new Word2Vec();
    ret.setVocab(cache);
    ret.setLookupTable(lookupTable);
    reader.close();
    rootDir.delete();
    return ret;
  }
}
