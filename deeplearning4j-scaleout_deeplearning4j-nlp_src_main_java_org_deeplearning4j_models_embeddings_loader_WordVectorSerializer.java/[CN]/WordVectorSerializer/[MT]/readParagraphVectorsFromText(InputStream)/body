{
  try {
    BufferedReader reader=new BufferedReader(new InputStreamReader(stream));
    ArrayList<String> labels=new ArrayList<>();
    ArrayList<INDArray> arrays=new ArrayList<>();
    VocabCache<VocabWord> vocabCache=new AbstractCache.Builder<VocabWord>().build();
    String line="";
    while ((line=reader.readLine()) != null) {
      String[] split=line.split(" ");
      VocabWord word=new VocabWord(1.0,split[1]);
      if (split[0].equals("L")) {
        word.setSpecial(true);
        word.markAsLabel(true);
        labels.add(word.getLabel());
      }
 else       if (split[0].equals("E")) {
        word.setSpecial(false);
        word.markAsLabel(false);
      }
 else       throw new IllegalStateException("Source stream doesn't looks like ParagraphVectors serialized model");
      word.setIndex(vocabCache.numWords());
      vocabCache.addToken(word);
      vocabCache.addWordToIndex(word.getIndex(),word.getLabel());
      vocabCache.putVocabWord(word.getLabel());
      INDArray row=Nd4j.create(1,split.length - 2);
      for (int i=2; i < split.length; i++) {
        row.putScalar(i - 2,Float.parseFloat(split[i]));
      }
      arrays.add(row);
    }
    INDArray syn=Nd4j.create(new int[]{arrays.size(),arrays.get(0).columns()});
    for (int i=0; i < syn.rows(); i++) {
      syn.putRow(i,arrays.get(i));
    }
    InMemoryLookupTable<VocabWord> lookupTable=(InMemoryLookupTable<VocabWord>)new InMemoryLookupTable.Builder<VocabWord>().vectorLength(arrays.get(0).columns()).useAdaGrad(false).cache(vocabCache).build();
    Nd4j.clearNans(syn);
    lookupTable.setSyn0(syn);
    LabelsSource source=new LabelsSource(labels);
    ParagraphVectors vectors=new ParagraphVectors.Builder().labelsSource(source).vocabCache(vocabCache).lookupTable(lookupTable).modelUtils(new BasicModelUtils<VocabWord>()).build();
    return vectors;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}
