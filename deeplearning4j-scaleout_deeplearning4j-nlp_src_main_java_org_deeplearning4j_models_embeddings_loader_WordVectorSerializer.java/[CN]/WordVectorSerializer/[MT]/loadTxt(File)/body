{
  BufferedReader reader=new BufferedReader(new FileReader(vectorsFile));
  VocabCache cache=new AbstractCache<>();
  LineIterator iter=IOUtils.lineIterator(reader);
  String line=null;
  boolean hasHeader=false;
  if (iter.hasNext()) {
    line=iter.nextLine();
    if (!line.contains(" ")) {
      log.info("Skipping first line");
      hasHeader=true;
    }
  }
  if (hasHeader) {
    iter.close();
    iter=IOUtils.lineIterator(reader);
    iter.nextLine();
  }
  List<INDArray> arrays=new ArrayList<>();
  while (iter.hasNext()) {
    if (line.isEmpty())     line=iter.nextLine();
    String[] split=line.split(" ");
    String word=split[0];
    VocabWord word1=new VocabWord(1.0,word);
    word1.setIndex(cache.numWords());
    cache.addToken(word1);
    cache.addWordToIndex(word1.getIndex(),word);
    cache.putVocabWord(word);
    INDArray row=Nd4j.create(Nd4j.createBuffer(split.length - 1));
    for (int i=1; i < split.length; i++) {
      row.putScalar(i - 1,Float.parseFloat(split[i]));
    }
    arrays.add(row);
    line="";
  }
  INDArray syn=Nd4j.create(new int[]{arrays.size(),arrays.get(0).columns()});
  for (int i=0; i < syn.rows(); i++) {
    syn.putRow(i,arrays.get(i));
  }
  InMemoryLookupTable lookupTable=(InMemoryLookupTable)new InMemoryLookupTable.Builder().vectorLength(arrays.get(0).columns()).useAdaGrad(false).cache(cache).build();
  Nd4j.clearNans(syn);
  lookupTable.setSyn0(syn);
  iter.close();
  return new Pair<>(lookupTable,cache);
}
