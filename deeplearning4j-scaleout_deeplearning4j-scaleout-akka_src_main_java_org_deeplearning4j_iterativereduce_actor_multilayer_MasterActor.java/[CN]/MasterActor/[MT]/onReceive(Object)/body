{
  if (message instanceof DistributedPubSubMediator.SubscribeAck || message instanceof DistributedPubSubMediator.UnsubscribeAck) {
    DistributedPubSubMediator.SubscribeAck ack=(DistributedPubSubMediator.SubscribeAck)message;
    mediator.tell(new DistributedPubSubMediator.Publish(ClusterListener.TOPICS,message),getSelf());
    log.info("Subscribed " + ack.toString());
  }
 else   if (message instanceof WorkerState) {
    WorkerState s=(WorkerState)message;
    if (s.getWorkerId() != null) {
      this.addWorker(s);
      getSender().tell(Ack.getInstance(),getSelf());
    }
  }
 else   if (message instanceof DoneMessage) {
    log.info("Received done message");
    UpdateableImpl masterResults=null;
    if (!updates.isEmpty()) {
      masterResults=this.compute(updates,updates);
      stateTracker.setCurrent(masterResults);
      epochsComplete++;
      updates.clear();
    }
 else     masterResults=this.getMasterResults();
    if (pretrain && stateTracker.currentJobs().isEmpty()) {
      log.info("Switching to finetune mode");
      pretrain=false;
      stateTracker.moveToFinetune();
      SerializationUtils.saveObject(masterResults.get(),new File("pretrain-model.bin"));
      batchActor.tell(ResetMessage.getInstance(),getSelf());
      batchActor.tell(new MoreWorkMessage(masterResults),getSelf());
    }
 else     if (stateTracker.currentJobs().isEmpty()) {
      isDone=true;
      log.info("Done training!");
    }
  }
 else   if (message instanceof ClearWorker) {
    log.info("Removing worker with id " + ((ClearWorker)message).getId());
    ClearWorker clear=(ClearWorker)message;
    Map<String,WorkerState> workers=stateTracker.currentWorkers();
    WorkerState clear2=workers.get(clear.getId());
    if (clear != null)     stateTracker.clearWorker(clear2);
  }
 else   if (message instanceof String) {
    Map<String,WorkerState> workers=stateTracker.currentWorkers();
    WorkerState state=workers.get(message.toString());
    if (state == null) {
      state=new WorkerState(message.toString());
      state.setAvailable(true);
      addWorker(state);
      log.info("Worker " + state.getWorkerId() + " available for work");
    }
 else {
      state.setAvailable(true);
      log.info("Worker " + state.getWorkerId() + " available for work");
    }
    getSender().tell(Ack.getInstance(),getSelf());
  }
 else   if (message instanceof UpdateableImpl) {
    UpdateableImpl up=(UpdateableImpl)message;
    updates.add(up);
    log.info("Num updates so far " + updates.size() + " and partition size is "+ partition);
    List<Job> currentJobs=stateTracker.currentJobs();
    if (updates.size() >= partition || everyWorkerAvailable() || currentJobs.isEmpty())     nextIteration();
  }
 else   if (message instanceof List || message instanceof DataSet) {
    if (message instanceof List) {
      List<DataSet> list=(List<DataSet>)message;
      splitListIntoRows(list);
      sendToWorkers(list);
    }
 else     if (message instanceof DataSet) {
      DataSet pair=(DataSet)message;
      List<DoubleMatrix> inputs=pair.getFirst().rowsAsList();
      List<DoubleMatrix> labels=pair.getSecond().rowsAsList();
      List<DataSet> pairs=new ArrayList<>();
      for (int i=0; i < inputs.size(); i++) {
        pairs.add(new DataSet(inputs.get(i),labels.get(i)));
      }
      sendToWorkers(pairs);
    }
  }
 else   unhandled(message);
}
