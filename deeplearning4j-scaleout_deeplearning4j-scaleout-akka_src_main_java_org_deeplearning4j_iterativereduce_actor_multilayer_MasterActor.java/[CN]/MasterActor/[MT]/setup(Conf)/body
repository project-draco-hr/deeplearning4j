{
  log.info("Starting workers");
  ActorSystem system=context().system();
  RoundRobinPool pool=new RoundRobinPool(Runtime.getRuntime().availableProcessors());
  Props p=pool.props(WorkerActor.propsFor(conf,stateTracker));
  p=ClusterSingletonManager.defaultProps(p,"master",PoisonPill.getInstance(),"master");
  system.actorOf(p,"worker");
  try {
    Thread.sleep(30000);
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  log.info("Broadcasting initial master network");
  BaseMultiLayerNetwork network=this.network == null ? new BaseMultiLayerNetwork.Builder<>().numberOfInputs(conf.getnIn()).numberOfOutPuts(conf.getnOut()).withClazz(conf.getMultiLayerClazz()).hiddenLayerSizes(conf.getLayerSizes()).renderWeights(conf.getRenderWeightEpochs()).useRegularization(conf.isUseRegularization()).withSparsity(conf.getSparsity()).useAdGrad(conf.isUseAdaGrad()).withMultiLayerGradientListeners(conf.getMultiLayerGradientListeners()).withGradientListeners(conf.getGradientListeners()).build() : this.network;
  if (conf.getColumnMeans() != null)   network.setColumnMeans(conf.getColumnMeans());
  if (conf.getColumnStds() != null)   network.setColumnStds(conf.getColumnStds());
  UpdateableImpl masterResults=new UpdateableImpl(network);
  try {
    this.stateTracker.setCurrent(masterResults);
  }
 catch (  Exception e1) {
    throw new RuntimeException(e1);
  }
  mediator.tell(new DistributedPubSubMediator.Publish(BROADCAST,masterResults),getSelf());
  ensureNoLeftOvers=context().system().scheduler().schedule(Duration.create(1,TimeUnit.MINUTES),Duration.create(1,TimeUnit.MINUTES),new Runnable(){
    @Override public void run(){
      try {
        List<Job> currentJobs=stateTracker.currentJobs();
        Collection<WorkerState> availableWorkers=stateTracker.currentWorkers().values();
        log.info("Status check on next iteration");
        if (!updates.isEmpty() && currentJobs.isEmpty() || everyWorkerAvailable()) {
          log.info("Forcing next iteration");
          nextIteration();
        }
 else {
          for (          Job j : currentJobs) {
            mediator.tell(new DistributedPubSubMediator.Publish(j.getWorkerId(),NeedsStatus.getInstance()),getSelf());
            if (stateTracker.workerAvailable(j.getWorkerId())) {
              log.info("Out of sync job and worker list; removing job " + j.getWorkerId());
              stateTracker.jobDone(j);
            }
          }
        }
        log.info("Available workers " + availableWorkers);
        log.info("Current jobs left " + currentJobs);
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
    }
  }
,context().dispatcher());
  ensureDistribution=context().system().scheduler().schedule(Duration.create(1,TimeUnit.MINUTES),Duration.create(1,TimeUnit.MINUTES),new Runnable(){
    @Override public void run(){
      while (!stateTracker.jobsToRedistribute().isEmpty()) {
        Job remove=needsToBeRedistributed.remove(0);
        try {
          stateTracker.requeueJob(remove);
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
  }
,context().dispatcher());
}
