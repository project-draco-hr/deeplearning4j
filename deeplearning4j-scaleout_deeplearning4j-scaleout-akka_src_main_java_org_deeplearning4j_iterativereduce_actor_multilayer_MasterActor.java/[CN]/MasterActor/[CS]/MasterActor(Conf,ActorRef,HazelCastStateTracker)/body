{
  super(conf,batchActor,stateTracker);
  setup(conf);
  forceNextPhase=context().system().scheduler().schedule(Duration.create(10,TimeUnit.SECONDS),Duration.create(10,TimeUnit.SECONDS),new Runnable(){
    @Override public void run(){
      try {
        List<Job> currentJobs=stateTracker.currentJobs();
        log.info("Status check on next iteration");
        if (stateTracker.getCurrent() == null) {
          try {
            log.info("State tracker did not have a network; reinitializing");
            if (network == null)             stateTracker.setCurrent(new UpdateableImpl(network));
          }
 catch (          Exception e) {
            throw new RuntimeException(e);
          }
        }
        List<UpdateableImpl> updates=stateTracker.updates();
        if (updates.size() >= stateTracker.workers().size() || currentJobs.isEmpty())         nextBatch();
 else         log.info("Still waiting on next batch, so far we have updates of size: " + updates.size() + " out of "+ stateTracker.workers().size());
        log.info("Current jobs left " + currentJobs);
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
    }
  }
,context().dispatcher());
  this.clearStateWorkers=context().system().scheduler().schedule(Duration.create(1,TimeUnit.MINUTES),Duration.create(1,TimeUnit.MINUTES),new Runnable(){
    @Override public void run(){
      try {
        long now=System.currentTimeMillis();
        Map<String,Long> heartbeats=MasterActor.this.stateTracker.getHeartBeats();
        for (        String key : heartbeats.keySet()) {
          long lastChecked=heartbeats.get(key);
          long diff=now - lastChecked;
          long seconds=TimeUnit.MILLISECONDS.toSeconds(diff);
          if (seconds >= 30) {
            log.info("Removing stale worker " + key);
            MasterActor.this.stateTracker.removeWorker(key);
          }
        }
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
    }
  }
,context().dispatcher());
}
