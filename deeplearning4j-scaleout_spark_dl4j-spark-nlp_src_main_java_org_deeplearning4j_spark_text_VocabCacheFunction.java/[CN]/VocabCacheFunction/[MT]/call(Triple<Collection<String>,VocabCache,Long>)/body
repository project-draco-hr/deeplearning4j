{
  Set<String> encountered=new HashSet<>();
  long wordsEncountered=v1.getThird() + v1.getFirst().size();
  VocabCache cache=v1.getSecond();
  for (  String token : v1.getFirst()) {
    if (stopWords.getValue().contains(token))     token="STOP";
    if (token.isEmpty())     continue;
    String oldToken=token;
    if (token.isEmpty())     token=oldToken;
    cache.incrementWordCount(token);
    if (!encountered.contains(token)) {
      cache.incrementDocCount(token,1);
      encountered.add(token);
    }
    VocabWord token2;
    if (cache.hasToken(token))     token2=cache.tokenFor(token);
 else {
      token2=new VocabWord(1.0,token);
      cache.addToken(token2);
    }
    if (!Util.matchesAnyStopWord(stopWords.getValue(),token) && token != null && !token.isEmpty()) {
      if (!cache.containsWord(token) && cache.wordFrequency(token) >= minWordFrequency) {
        int idx=cache.numWords();
        token2.setIndex(idx);
        cache.putVocabWord(token);
      }
 else       if (Util.matchesAnyStopWord(stopWords.getValue(),token) && token != null && !token.isEmpty()) {
        token="STOP";
        if (!cache.containsWord(token) && cache.wordFrequency(token) >= minWordFrequency) {
          int idx=cache.numWords();
          token2.setIndex(idx);
          cache.putVocabWord(token);
        }
      }
    }
  }
  return new Pair<>(cache,wordsEncountered);
}
