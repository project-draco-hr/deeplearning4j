{
  rng=new MersenneTwister(seed);
  if (randomFeatureVectors) {
    initRandomWordVectors(trainingTrees);
  }
  MultiDimensionalSet<String,String> binaryProductions=MultiDimensionalSet.hashSet();
  if (simplifiedModel) {
    binaryProductions.add("","");
  }
 else {
    throw new UnsupportedOperationException("Not yet implemented");
  }
  Set<String> unaryProductions=new HashSet<>();
  if (simplifiedModel) {
    unaryProductions.add("");
  }
 else {
    throw new UnsupportedOperationException("Not yet implemented");
  }
  identity=DoubleMatrix.eye(numHidden);
  binaryTransform=MultiDimensionalMap.newTreeBackedMap();
  binaryTensors=MultiDimensionalMap.newTreeBackedMap();
  binaryClassification=MultiDimensionalMap.newTreeBackedMap();
  for (  Pair<String,String> binary : binaryProductions) {
    String left=basicCategory(binary.getFirst());
    String right=basicCategory(binary.getSecond());
    if (binaryTransform.contains(left,right)) {
      continue;
    }
    binaryTransform.put(left,right,randomTransformMatrix());
    if (useTensors) {
      binaryTensors.put(left,right,randomBinaryTensor());
    }
    if (!combineClassification) {
      binaryClassification.put(left,right,randomClassificationMatrix());
    }
  }
  numBinaryMatrices=binaryTransform.size();
  binaryTransformSize=numHidden * (2 * numHidden + 1);
  if (useTensors) {
    binaryTensorSize=numHidden * numHidden * numHidden* 4;
  }
 else {
    binaryTensorSize=0;
  }
  binaryClassificationSize=(combineClassification) ? 0 : numOuts * (numHidden + 1);
  unaryClassification=new TreeMap<>();
  for (  String unary : unaryProductions) {
    unary=basicCategory(unary);
    if (unaryClassification.containsKey(unary)) {
      continue;
    }
    unaryClassification.put(unary,randomClassificationMatrix());
  }
  numUnaryMatrices=unaryClassification.size();
  unaryClassificationSize=numOuts * (numHidden + 1);
}
