{
  Nd4j.getRandom().setSeed(12345L);
  int[] miniBatchSizes={5,1,5,1};
  int[] timeSeriesLengths={9,9,1,1};
  for (int x=0; x < miniBatchSizes.length; x++) {
    int miniBatchSize=miniBatchSizes[x];
    int hiddenLayerSize=7;
    int timeSeriesLength=timeSeriesLengths[x];
    FeedForwardToRnnPreProcessor proc=new FeedForwardToRnnPreProcessor();
    NeuralNetConfiguration nnc=new NeuralNetConfiguration.Builder().layer(new org.deeplearning4j.nn.conf.layers.DenseLayer.Builder().nIn(hiddenLayerSize).build()).build();
    DenseLayer layer=LayerFactories.getFactory(nnc.getLayer()).create(nnc);
    layer.setInputMiniBatchSize(miniBatchSize);
    INDArray activations2d=Nd4j.rand(miniBatchSize * timeSeriesLength,hiddenLayerSize);
    INDArray activations3d=proc.preProcess(activations2d,layer);
    assertArrayEquals(activations3d.shape(),new int[]{miniBatchSize,hiddenLayerSize,timeSeriesLength});
    int nRows2D=miniBatchSize * timeSeriesLength;
    for (int i=0; i < nRows2D; i++) {
      int time=i % timeSeriesLength;
      int example=i / timeSeriesLength;
      INDArray row2d=activations2d.getRow(i);
      INDArray row3d=activations3d.tensorAlongDimension(time,1,0).getRow(example);
      assertTrue(row2d.equals(row3d));
    }
    INDArray epsilon2d=proc.backprop(activations3d,layer);
    assertTrue(epsilon2d.equals(activations2d));
  }
}
