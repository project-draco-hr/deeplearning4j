{
  final CountDownLatch c=new CountDownLatch(iterate.size());
  List<Future<E>> futures=new ArrayList<>();
  for (  final E e : iterate) {
    Future<E> f=Futures.future(new Callable<E>(){
      /** 
 * Computes a result, or throws an exception if unable to do so.
 * @return computed result
 * @throws Exception if unable to compute a result
 */
      @Override public E call() throws Exception {
        loop.run(e,otherArgs);
        return e;
      }
    }
,actorSystem.dispatcher());
    f.onComplete(new OnComplete<E>(){
      @Override public void onComplete(      Throwable throwable,      E e) throws Throwable {
        if (throwable != null)         log.warn("Error occurred processing data",throwable);
        if (postDone != null)         postDone.run(e,otherArgs);
        c.countDown();
      }
    }
,actorSystem.dispatcher());
    futures.add(f);
  }
  Future<Iterable<E>> seq=Futures.sequence(futures,actorSystem.dispatcher());
  while (!seq.isCompleted()) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}
