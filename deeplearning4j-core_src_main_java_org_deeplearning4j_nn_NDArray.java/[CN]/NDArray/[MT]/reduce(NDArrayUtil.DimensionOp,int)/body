{
  if (isScalar())   return this;
  if (isVector())   return NDArray.scalar(reduceVector(op,this));
  int[] shape=ArrayUtil.removeIndex(this.shape,dimension);
  if (dimension == 0) {
    double[] data2=new double[ArrayUtil.prod(shape)];
    int dataIter=0;
    int numTimes=ArrayUtil.prod(shape);
    for (int offset=this.offset; offset < numTimes; offset++) {
      double reduce=op(dimension,offset,op);
      data2[dataIter++]=reduce;
    }
    return new NDArray(data2,shape);
  }
 else {
    double[] data2=new double[ArrayUtil.prod(shape)];
    int dataIter=0;
    int[] sliceIndices=endsForSlices();
    int currOffset=0;
    int numTimes=ArrayUtil.prod(shape);
    for (int offset=this.offset; offset < numTimes; offset++) {
      if (dataIter >= data2.length)       break;
      Pair<Double,Boolean> pair=op(dimension,offset,op,sliceIndices[currOffset]);
      double reduce=pair.getFirst();
      data2[dataIter++]=reduce;
      if (pair.getSecond()) {
        offset=sliceIndices[currOffset];
        numTimes+=sliceIndices[currOffset];
        currOffset++;
      }
    }
    return new NDArray(data2,shape);
  }
}
