{
  INDArray output=Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform(conf().getLayer().getActivationFunction(),preOut.dup()));
  INDArray outSubLabels=output.sub(getLabels2d());
  Gradient gradient=new DefaultGradient();
  INDArray weightGradView=gradientViews.get(DefaultParamInitializer.WEIGHT_KEY);
  INDArray biasGradView=gradientViews.get(DefaultParamInitializer.BIAS_KEY);
  gradient.gradientForVariable().put(DefaultParamInitializer.WEIGHT_KEY,weightGradView);
  gradient.gradientForVariable().put(DefaultParamInitializer.BIAS_KEY,biasGradView);
  if (maskArray != null) {
    outSubLabels.muliColumnVector(maskArray);
  }
  Triple<Gradient,INDArray,INDArray> triple;
switch (layerConf().getLossFunction()) {
case NEGATIVELOGLIKELIHOOD:
case MCXENT:
    Nd4j.gemm(input,outSubLabels,weightGradView,true,false,1.0,0.0);
  biasGradView.assign(outSubLabels.sum(0));
triple=new Triple<>(gradient,outSubLabels,output);
break;
case XENT:
Nd4j.gemm(input,outSubLabels.div(output.mul(output.rsub(1))),weightGradView,true,false,1.0,0.0);
biasGradView.assign(outSubLabels.sum(0));
triple=new Triple<>(gradient,outSubLabels,output);
break;
case MSE:
INDArray delta=outSubLabels.mul(derivativeActivation(preOut));
Nd4j.gemm(input,delta,weightGradView,true,false,1.0,0.0);
biasGradView.assign(delta.sum(0));
triple=new Triple<>(gradient,delta,output);
break;
case EXPLL:
Nd4j.gemm(input,labels.rsub(1).divi(output),weightGradView,true,false,1.0,0.0);
biasGradView.assign(outSubLabels.sum(0));
triple=new Triple<>(gradient,outSubLabels,output);
break;
case RMSE_XENT:
INDArray squaredrmseXentDiff=pow(outSubLabels,2.0);
INDArray sqrt=sqrt(squaredrmseXentDiff);
Nd4j.gemm(input,sqrt,weightGradView,true,false,1.0,0.0);
biasGradView.assign(outSubLabels.sum(0));
triple=new Triple<>(gradient,outSubLabels,output);
break;
case SQUARED_LOSS:
Nd4j.gemm(input,outSubLabels.mul(outSubLabels),weightGradView,true,false,1.0,0.0);
biasGradView.assign(outSubLabels.sum(0));
triple=new Triple<>(gradient,outSubLabels,output);
break;
default :
throw new IllegalStateException("Invalid loss function: " + layerConf().getLossFunction());
}
return triple;
}
