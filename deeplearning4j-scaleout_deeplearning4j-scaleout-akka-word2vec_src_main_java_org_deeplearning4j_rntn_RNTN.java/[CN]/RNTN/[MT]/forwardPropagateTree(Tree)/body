{
  FloatMatrix nodeVector;
  FloatMatrix classification;
  if (tree.isLeaf()) {
    throw new AssertionError("We should not have reached leaves in forwardPropagate");
  }
 else   if (tree.isPreTerminal()) {
    classification=getUnaryClassification(tree.label());
    String word=tree.children().get(0).value();
    FloatMatrix wordVector=getFeatureVector(word);
    if (wordVector == null) {
      wordVector=featureVectors.get(UNKNOWN_FEATURE);
    }
    nodeVector=activationFunction.apply(wordVector);
  }
 else   if (tree.children().size() == 1) {
    throw new AssertionError("Non-preterminal nodes of size 1 should have already been collapsed");
  }
 else   if (tree.children().size() == 2) {
    Tree left=tree.firstChild(), right=tree.lastChild();
    forwardPropagateTree(left);
    forwardPropagateTree(right);
    String leftCategory=tree.children().get(0).label();
    String rightCategory=tree.children().get(1).label();
    FloatMatrix W=getBinaryTransform(leftCategory,rightCategory);
    classification=getBinaryClassification(leftCategory,rightCategory);
    FloatMatrix leftVector=tree.children().get(0).vector();
    FloatMatrix rightVector=tree.children().get(1).vector();
    FloatMatrix childrenVector=appendBias(leftVector,rightVector);
    if (useFloatTensors) {
      FloatTensor floatT=getBinaryFloatTensor(leftCategory,rightCategory);
      FloatMatrix floatTensorIn=FloatMatrix.concatHorizontally(leftVector,rightVector);
      FloatMatrix floatTensorOut=floatT.bilinearProducts(floatTensorIn);
      nodeVector=activationFunction.apply(W.mmul(childrenVector).add(floatTensorOut));
    }
 else     nodeVector=activationFunction.apply(W.mmul(childrenVector));
  }
 else {
    throw new AssertionError("Tree not correctly binarized");
  }
  FloatMatrix inputWithBias=appendBias(nodeVector);
  FloatMatrix preAct=classification.mmul(inputWithBias);
  FloatMatrix predictions=outputActivation.apply(preAct);
  tree.setPrediction(predictions);
  tree.setVector(nodeVector);
}
