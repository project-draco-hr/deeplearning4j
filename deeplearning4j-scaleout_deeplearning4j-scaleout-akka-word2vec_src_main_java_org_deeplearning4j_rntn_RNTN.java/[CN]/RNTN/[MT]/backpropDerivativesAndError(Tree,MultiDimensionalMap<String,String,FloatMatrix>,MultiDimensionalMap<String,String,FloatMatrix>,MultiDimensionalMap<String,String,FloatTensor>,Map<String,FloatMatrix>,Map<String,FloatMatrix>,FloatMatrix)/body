{
  if (tree.isLeaf()) {
    return;
  }
  FloatMatrix currentVector=tree.vector();
  String category=tree.label();
  category=basicCategory(category);
  FloatMatrix goldLabel=new FloatMatrix(numOuts,1);
  int goldClass=tree.goldLabel();
  if (goldClass >= 0) {
    goldLabel.put(goldClass,1.0f);
  }
  Float nodeWeight=classWeights.get(goldClass);
  if (nodeWeight == null)   nodeWeight=1.0f;
  FloatMatrix predictions=tree.prediction();
  FloatMatrix deltaClass=goldClass >= 0 ? SimpleBlas.scal(nodeWeight,predictions.sub(goldLabel)) : new FloatMatrix(predictions.rows,predictions.columns);
  FloatMatrix localCD=deltaClass.mmul(appendBias(currentVector).transpose());
  float error=-(MatrixFunctions.log(predictions).muli(goldLabel).sum());
  error=error * nodeWeight;
  tree.setError(error);
  if (tree.isPreTerminal()) {
    unaryCD.put(category,unaryCD.get(category).add(localCD));
    String word=tree.children().get(0).label();
    word=getVocabWord(word);
    FloatMatrix currentVectorDerivative=activationFunction.apply(currentVector);
    FloatMatrix deltaFromClass=getUnaryClassification(category).transpose().mmul(deltaClass);
    deltaFromClass=deltaFromClass.get(interval(0,numHidden),interval(0,1)).mul(currentVectorDerivative);
    FloatMatrix deltaFull=deltaFromClass.add(deltaUp);
    wordVectorD.put(word,wordVectorD.get(word).add(deltaFull));
  }
 else {
    String leftCategory=basicCategory(tree.children().get(0).label());
    String rightCategory=basicCategory(tree.children().get(1).label());
    if (combineClassification) {
      unaryCD.put("",unaryCD.get("").add(localCD));
    }
 else {
      binaryCD.put(leftCategory,rightCategory,binaryCD.get(leftCategory,rightCategory).add(localCD));
    }
    FloatMatrix currentVectorDerivative=activationFunction.applyDerivative(currentVector);
    FloatMatrix deltaFromClass=getBinaryClassification(leftCategory,rightCategory).transpose().mmul(deltaClass);
    FloatMatrix mult=deltaFromClass.get(interval(0,numHidden),interval(0,1));
    deltaFromClass=mult.muli(currentVectorDerivative);
    FloatMatrix deltaFull=deltaFromClass.add(deltaUp);
    FloatMatrix leftVector=tree.children().get(0).vector();
    FloatMatrix rightVector=tree.children().get(1).vector();
    FloatMatrix childrenVector=appendBias(leftVector,rightVector);
    FloatMatrix add=binaryTD.get(leftCategory,rightCategory);
    FloatMatrix W_df=deltaFromClass.mmul(childrenVector.transpose());
    binaryTD.put(leftCategory,rightCategory,add.add(W_df));
    FloatMatrix deltaDown;
    if (useFloatTensors) {
      FloatTensor Wt_df=getFloatTensorGradient(deltaFull,leftVector,rightVector);
      binaryFloatTensorTD.put(leftCategory,rightCategory,binaryFloatTensorTD.get(leftCategory,rightCategory).add(Wt_df));
      deltaDown=computeFloatTensorDeltaDown(deltaFull,leftVector,rightVector,getBinaryTransform(leftCategory,rightCategory),getBinaryFloatTensor(leftCategory,rightCategory));
    }
 else {
      deltaDown=getBinaryTransform(leftCategory,rightCategory).transpose().mmul(deltaFull);
    }
    FloatMatrix leftDerivative=activationFunction.apply(leftVector);
    FloatMatrix rightDerivative=activationFunction.apply(rightVector);
    FloatMatrix leftDeltaDown=deltaDown.get(interval(0,deltaFull.rows),interval(0,1));
    FloatMatrix rightDeltaDown=deltaDown.get(interval(deltaFull.rows,deltaFull.rows * 2),interval(0,1));
    backpropDerivativesAndError(tree.children().get(0),binaryTD,binaryCD,binaryFloatTensorTD,unaryCD,wordVectorD,leftDerivative.mul(leftDeltaDown));
    backpropDerivativesAndError(tree.children().get(1),binaryTD,binaryCD,binaryFloatTensorTD,unaryCD,wordVectorD,rightDerivative.mul(rightDeltaDown));
  }
}
