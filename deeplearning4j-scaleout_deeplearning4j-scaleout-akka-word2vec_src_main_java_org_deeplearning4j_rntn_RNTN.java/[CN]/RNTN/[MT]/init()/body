{
  if (rng == null)   rng=new MersenneTwister(123);
  MultiDimensionalSet<String,String> binaryProductions=MultiDimensionalSet.hashSet();
  if (simplifiedModel) {
    binaryProductions.add("","");
  }
 else {
    throw new UnsupportedOperationException("Not yet implemented");
  }
  Set<String> unaryProductions=new HashSet<>();
  if (simplifiedModel) {
    unaryProductions.add("");
  }
 else {
    throw new UnsupportedOperationException("Not yet implemented");
  }
  identity=FloatMatrix.eye(numHidden);
  binaryTransform=MultiDimensionalMap.newTreeBackedMap();
  binaryFloatTensors=MultiDimensionalMap.newTreeBackedMap();
  binaryClassification=MultiDimensionalMap.newTreeBackedMap();
  for (  Pair<String,String> binary : binaryProductions) {
    String left=basicCategory(binary.getFirst());
    String right=basicCategory(binary.getSecond());
    if (binaryTransform.contains(left,right)) {
      continue;
    }
    binaryTransform.put(left,right,randomTransformMatrix());
    if (useFloatTensors) {
      binaryFloatTensors.put(left,right,randomBinaryFloatTensor());
    }
    if (!combineClassification) {
      binaryClassification.put(left,right,randomClassificationMatrix());
    }
  }
  numBinaryMatrices=binaryTransform.size();
  binaryTransformSize=numHidden * (2 * numHidden + 1);
  if (useFloatTensors) {
    binaryFloatTensorSize=numHidden * numHidden * numHidden* 4;
  }
 else {
    binaryFloatTensorSize=0;
  }
  binaryClassificationSize=(combineClassification) ? 0 : numOuts * (numHidden + 1);
  unaryClassification=new TreeMap<>();
  for (  String unary : unaryProductions) {
    unary=basicCategory(unary);
    if (unaryClassification.containsKey(unary)) {
      continue;
    }
    unaryClassification.put(unary,randomClassificationMatrix());
  }
  featureVectors.put(UNKNOWN_FEATURE,randomWordVector());
  numUnaryMatrices=unaryClassification.size();
  unaryClassificationSize=numOuts * (numHidden + 1);
  classWeights=new HashMap<>();
}
