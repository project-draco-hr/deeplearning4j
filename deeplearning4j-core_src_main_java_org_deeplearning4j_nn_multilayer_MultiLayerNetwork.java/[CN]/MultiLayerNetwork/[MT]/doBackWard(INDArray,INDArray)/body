{
  setInput(input);
  this.labels=labels;
  if (!(getOutputLayer() instanceof OutputLayer)) {
    log.warn("Warning: final layer isn't output layer. You can ignore this message if you just intend on using a a deep neural network with no output layer.");
    return;
  }
  OutputLayer output=(OutputLayer)getOutputLayer();
  if (labels == null)   throw new IllegalStateException("No labels found");
  INDArray outputValue=output.getParam("W").sum(Integer.MAX_VALUE);
  if (outputValue.getFloat(0) == 0f) {
    throw new IllegalStateException("Output layer weights cannot be intialized to zero when using backprop.");
  }
  ;
  output.setLabels(labels);
  for (int i=0; i < getLayerWiseConfigurations().getConf(0).getNumIterations(); i++) {
    int numLayers=getnLayers() - 1;
    List<Gradient> weightUpdates=new ArrayList<>();
    Pair<List<INDArray>,List<INDArray>> zsAndActivations=zsAndActivations();
    List<INDArray> activations=zsAndActivations.getSecond();
    List<INDArray> zs=zsAndActivations.getFirst();
    INDArray outputActivation=activations.get(activations.size() - 1);
    INDArray activationDeriv=zs.get(zs.size() - 1);
    INDArray delta=outputActivation.sub(labels).transpose();
    Gradient nextGradients=new DefaultGradient();
    nextGradients.gradientForVariable().put(DefaultParamInitializer.WEIGHT_KEY,delta.mmul(activationDeriv).transpose());
    nextGradients.gradientForVariable().put(DefaultParamInitializer.BIAS_KEY,delta.transpose());
    weightUpdates.add(nextGradients);
    for (int j=numLayers - 1; j > 0; j--) {
      INDArray currZ=zs.get(j);
      Layer nextLayer=getLayers()[j + 1];
      INDArray currActivation=activations.get(j);
      nextGradients=getLayers()[j].backwardGradient(currZ,nextLayer,nextGradients,currActivation);
      weightUpdates.add(nextGradients);
    }
    Collections.reverse(weightUpdates);
    for (int k=0; k < numLayers; k++) {
      Gradient update=weightUpdates.get(k);
      GradientAdjustment.updateGradientAccordingToParams(getLayers()[k].conf(),i,update,input.slices(),getLayers()[k].getOptimizer().adaGradForVariables(),getLayers()[k].getOptimizer().getLastStep(),getLayers()[k]);
      getLayers()[k].update(update);
    }
    for (    IterationListener listener : listeners)     listener.iterationDone(getOutputLayer(),i);
  }
}
