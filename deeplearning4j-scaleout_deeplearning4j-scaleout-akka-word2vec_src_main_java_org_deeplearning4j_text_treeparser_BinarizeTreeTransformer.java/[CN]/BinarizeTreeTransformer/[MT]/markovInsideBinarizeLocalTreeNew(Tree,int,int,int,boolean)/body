{
  Tree result;
  List<Tree> children=t.children();
  if (starting) {
    if (left == headLoc && right == headLoc) {
      return t;
    }
    if (noRebinarization && children.size() == 2) {
      return t;
    }
    if (unaryAtTop) {
      result=new Tree(t);
      result.setChildren(Collections.singletonList(markovInsideBinarizeLocalTreeNew(t,headLoc,left,right,false)));
      return result;
    }
  }
  List<Tree> newChildren=null;
  if (left == headLoc && right == headLoc) {
    newChildren=Collections.singletonList(children.get(headLoc));
  }
 else   if (left < headLoc) {
    newChildren=new ArrayList<>(2);
    newChildren.add(children.get(left));
    newChildren.add(markovInsideBinarizeLocalTreeNew(t,headLoc,left + 1,right,false));
  }
 else   if (right > headLoc) {
    newChildren=new ArrayList<>(2);
    newChildren.add(markovInsideBinarizeLocalTreeNew(t,headLoc,left,right - 1,false));
    newChildren.add(children.get(right));
  }
 else {
    log.warn("Bad bad parameters passed to markovInsideBinarizeLocalTree");
  }
  String label;
  if (starting) {
    label=t.label();
  }
 else {
    label=makeSyntheticLabel(t,left,right,headLoc,markovOrder);
  }
  if (doSelectiveSplit) {
    double stateCount=stateCounter.getCount(label);
    if (stateCount < selectiveSplitThreshold) {
      if (starting && !unaryAtTop) {
        label=t.label();
      }
 else {
        label=makeSyntheticLabel(t,left,right,headLoc,markovOrder - 1);
      }
    }
  }
 else {
    stateCounter.incrementCount(label,1.0);
  }
  result=new Tree(t);
  result.setChildren(newChildren);
  return result;
}
