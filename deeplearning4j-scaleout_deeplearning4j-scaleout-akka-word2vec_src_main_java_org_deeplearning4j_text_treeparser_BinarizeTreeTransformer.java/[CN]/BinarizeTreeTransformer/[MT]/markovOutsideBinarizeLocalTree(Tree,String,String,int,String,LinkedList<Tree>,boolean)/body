{
  List<Tree> newChildren=new ArrayList<>(2);
  if (headLoc == 0) {
    if (!doneLeft) {
      if (topCat.equals("S") || topCat.equals("TOP")) {
        return markovOutsideBinarizeLocalTree(t,word,tag,headLoc,topCat,new LinkedList<Tree>(),true);
      }
      String subLabelStr;
      if (simpleLabels) {
        subLabelStr="@" + topCat;
      }
 else {
        String headStr=t.children().get(headLoc).label();
        subLabelStr="@" + topCat + ": "+ headStr+ " ]";
      }
      Tree subTree=new Tree(t);
      subTree.setTags(Collections.singletonList(tag));
      subTree.setLabel(subLabelStr + "[" + word+ "/"+ tag);
      subTree.connect(t.children());
      newChildren.add(markovOutsideBinarizeLocalTree(subTree,word,tag,headLoc,topCat,new LinkedList<Tree>(),true));
      Tree ret=new Tree(t);
      ret.connect(newChildren);
      return ret;
    }
    int len=t.children().size();
    if (len == 1) {
      Tree ret=new Tree(t);
      ret.connect(Collections.singletonList(t.children().get(0)));
      return ret;
    }
    ll.addFirst(t.children().get(len - 1));
    if (ll.size() > markovOrder) {
      ll.removeLast();
    }
    String subLabelStr;
    if (simpleLabels) {
      subLabelStr="@" + topCat;
    }
 else {
      String headStr=t.children().get(headLoc).label();
      String rightStr=(len > markovOrder - 1 ? "... " : "") + StringUtils.join(ll);
      subLabelStr="@" + topCat + ": "+ headStr+ " "+ rightStr;
    }
    Tree subTree=new Tree(t.getTokens());
    subTree.connect(t.children().subList(0,len - 1));
    subTree.setValue(word);
    subTree.setLabel(tag);
    subTree.setHeadWord(subLabelStr);
    newChildren.add(markovOutsideBinarizeLocalTree(subTree,word,tag,headLoc,topCat,ll,true));
    newChildren.add(t.children().get(len - 1));
    Tree ret=new Tree(t);
    ret.connect(newChildren);
    return ret;
  }
  if (headLoc > 0) {
    ll.add(t.children().get(0));
    if (ll.size() > markovOrder) {
      ll.remove(0);
    }
    String subLabelStr;
    if (simpleLabels) {
      subLabelStr="@" + topCat;
    }
 else {
      String headStr=t.children().get(headLoc).label();
      String leftStr=StringUtils.join(ll) + (headLoc > markovOrder - 1 ? " ..." : "");
      subLabelStr="@" + topCat + ": "+ leftStr+ " "+ headStr+ " ]";
    }
    Tree subTree=new Tree(t.getTokens());
    subTree.setLabel(subLabelStr);
    subTree.setTags(Collections.singletonList(tag));
    subTree.setValue(word);
    subTree.connect(t.children().subList(1,t.children().size()));
    newChildren.add(t.children().get(0));
    newChildren.add(markovOutsideBinarizeLocalTree(subTree,word,tag,headLoc - 1,topCat,ll,false));
    Tree ret=new Tree(t);
    ret.setLabel(t.label());
    ret.connect(newChildren);
    return ret;
  }
  return t;
}
