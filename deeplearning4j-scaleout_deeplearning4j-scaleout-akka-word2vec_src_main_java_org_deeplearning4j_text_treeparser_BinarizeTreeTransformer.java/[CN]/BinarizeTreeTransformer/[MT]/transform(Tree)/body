{
  if (t == null)   return null;
  String tLabelVal=t.label();
  if (t.isLeaf()) {
    Tree ret=new Tree(t);
    ret.setLabel(tLabelVal);
    return ret;
  }
  if (t.isPreTerminal()) {
    Tree child=transform(t.firstChild());
    String val=child.value();
    List<Tree> newChildren=new ArrayList<>(1);
    Tree add=new Tree(child.getTokens());
    add.setLabel(tLabelVal + "[" + val+ "/"+ tLabelVal+ "]");
    add.setTags(Arrays.asList(tLabelVal));
    add.setType(child.getType());
    add.setValue(val);
    newChildren.add(add);
    child.connect(newChildren);
    return child;
  }
  Tree head=headWordFinder.findHead(t);
  if (head == null && !tLabelVal.equals("S") && !t.label().equals("TOP"))   log.warn("No head found");
  int headNum=-1;
  List<Tree> children=t.children();
  List<Tree> newChildren=new ArrayList<>();
  for (int i=0; i < children.size(); i++) {
    Tree child=children.get(i);
    Tree childResult=transform(child);
    if (child == head)     headNum=i;
    newChildren.add(childResult);
  }
  Tree result;
  if (t.label().equals("TOP")) {
    result=new Tree(t);
    result.connect(newChildren);
  }
 else {
    String word=head.value();
    String tag=head.tags().get(0);
    result=new Tree(t.getTokens());
    result.connect(newChildren);
    result.setTags(Arrays.asList(tag));
    result.setLabel(tLabelVal + "[" + word+ "/"+ tag+ "]");
    result.setValue(word);
    result=binarizeLocalTree(t,headNum,word,tag);
  }
  return result;
}
