{
  float ret=0.0f;
  double reg=0.5 * l2;
  INDArray z=output;
switch (lossFunction) {
case RECONSTRUCTION_CROSSENTROPY:
    INDArray xEntLogZ2=Transforms.log(z.dup());
  INDArray xEntOneMinusLabelsOut2=labels.rsub(1);
INDArray xEntOneMinusLogOneMinusZ2=Transforms.log(z.dup()).rsubi(1);
ret=-labels.mul(xEntLogZ2).add(xEntOneMinusLabelsOut2).mul(xEntOneMinusLogOneMinusZ2).sum(1).sum(Integer.MAX_VALUE).get(0) / labels.rows();
break;
case MCXENT:
INDArray mcXEntLogZ=log(z);
ret=-labels.mul(mcXEntLogZ).sum(1).sum(Integer.MAX_VALUE).get(0) / labels.rows();
break;
case XENT:
INDArray xEntLogZ=log(z);
INDArray xEntOneMinusLabelsOut=labels.rsub(1);
INDArray xEntOneMinusLogOneMinusZ=log(z).rsubi(1);
ret=-labels.mul(xEntLogZ).add(xEntOneMinusLabelsOut).mul(xEntOneMinusLogOneMinusZ).sum(1).sum(Integer.MAX_VALUE).get(0) / labels.rows();
break;
case RMSE_XENT:
ret=sqrt(pow(labels.sub(z),2)).sum(1).sum(Integer.MAX_VALUE).get(0) / labels.rows();
break;
case MSE:
INDArray mseDelta=labels.sub(z);
ret=0.5f * pow(mseDelta,2).sum(1).sum(Integer.MAX_VALUE).get(0) / labels.rows();
break;
case EXPLL:
INDArray expLLLogZ=log(z);
ret=-z.sub(labels.mul(expLLLogZ)).sum(1).sum(Integer.MAX_VALUE).get(0) / labels.rows();
break;
case SQUARED_LOSS:
ret=(float)pow(labels.sub(z),2).sum(1).sum(Integer.MAX_VALUE).element() / labels.rows();
}
if (useRegularization && l2 > 0) ret+=reg;
return ret;
}
