{
  for (  String p : SetUtils.union(new HashSet<>(positive),new HashSet<>(negative))) {
    if (!vocab().containsWord(p)) {
      return new ArrayList<>();
    }
  }
  WeightLookupTable weightLookupTable=lookupTable();
  INDArray words=Nd4j.create(positive.size() + negative.size(),weightLookupTable.layerSize());
  int row=0;
  Set<String> union=SetUtils.union(new HashSet<>(positive),new HashSet<>(negative));
  for (  String s : positive) {
    words.putRow(row++,weightLookupTable.vector(s));
  }
  for (  String s : negative) {
    words.putRow(row++,weightLookupTable.vector(s).mul(-1));
  }
  INDArray mean=words.isMatrix() ? words.mean(0) : words;
  if (weightLookupTable instanceof InMemoryLookupTable) {
    InMemoryLookupTable l=(InMemoryLookupTable)weightLookupTable;
    INDArray syn0=l.getSyn0();
    syn0.diviRowVector(syn0.norm2(0));
    INDArray similarity=Transforms.unitVec(mean).mmul(syn0.transpose());
    List<Double> highToLowSimList=getTopN(similarity,top + union.size());
    List<String> ret=new ArrayList<>();
    for (int i=0; i < highToLowSimList.size(); i++) {
      String word=vocab().wordAtIndex(highToLowSimList.get(i).intValue());
      if (word != null && !word.equals("UNK") && !word.equals("STOP") && !union.contains(word)) {
        ret.add(word);
        if (ret.size() >= top) {
          break;
        }
      }
    }
    return ret;
  }
  Counter<String> distances=new Counter<>();
  for (  String s : vocab().words()) {
    INDArray otherVec=getWordVectorMatrix(s);
    double sim=Transforms.cosineSim(mean,otherVec);
    distances.incrementCount(s,sim);
  }
  distances.keepTopNKeys(top);
  return distances.keySet();
}
