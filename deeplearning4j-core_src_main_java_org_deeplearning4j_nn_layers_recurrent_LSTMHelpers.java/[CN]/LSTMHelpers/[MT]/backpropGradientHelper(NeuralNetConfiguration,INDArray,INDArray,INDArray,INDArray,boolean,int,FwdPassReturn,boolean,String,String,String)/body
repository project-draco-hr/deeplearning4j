{
  int hiddenLayerSize=recurrentWeights.size(0);
  int prevLayerSize=inputWeights.size(0);
  int miniBatchSize=epsilon.size(0);
  boolean is2dInput=epsilon.rank() < 3;
  int timeSeriesLength=(is2dInput ? 1 : epsilon.size(2));
  INDArray wi=fwdPass.paramsMmulCompatible[0];
  INDArray wI=fwdPass.paramsMmulCompatible[1];
  INDArray wf=fwdPass.paramsMmulCompatible[2];
  INDArray wF=fwdPass.paramsMmulCompatible[3];
  INDArray wo=fwdPass.paramsMmulCompatible[5];
  INDArray wO=fwdPass.paramsMmulCompatible[6];
  INDArray wg=fwdPass.paramsMmulCompatible[8];
  INDArray wG=fwdPass.paramsMmulCompatible[9];
  INDArray wFFTranspose=fwdPass.paramsMmulCompatible[4];
  INDArray wOOTranspose=fwdPass.paramsMmulCompatible[7];
  INDArray wGGTranspose=fwdPass.paramsMmulCompatible[10];
  INDArray[] bGradients=new INDArray[4];
  INDArray[] iwGradients=new INDArray[4];
  INDArray[] rwGradients=new INDArray[7];
  for (int i=0; i < 4; i++) {
    bGradients[i]=Nd4j.create(new int[]{1,hiddenLayerSize});
    iwGradients[i]=Nd4j.create(new int[]{prevLayerSize,hiddenLayerSize},'f');
    rwGradients[i]=Nd4j.create(new int[]{hiddenLayerSize,hiddenLayerSize},'f');
  }
  for (int i=0; i < 3; i++)   rwGradients[i + 4]=Nd4j.zeros(1,hiddenLayerSize);
  INDArray epsilonNext=Nd4j.zeros(miniBatchSize,prevLayerSize,timeSeriesLength);
  INDArray nablaCellStateNext=null;
  INDArray deltaiNext=null;
  INDArray deltafNext=null;
  INDArray deltaoNext=null;
  INDArray deltagNext=null;
  Level1 l1BLAS=Nd4j.getBlasWrapper().level1();
  int endIdx=0;
  if (truncatedBPTT) {
    endIdx=Math.max(0,timeSeriesLength - tbpttBackwardLength);
  }
  for (int iTimeIndex=timeSeriesLength - 1; iTimeIndex >= endIdx; iTimeIndex--) {
    int t=iTimeIndex;
    if (!forwards) {
      t=timeSeriesLength - iTimeIndex - 1;
    }
    INDArray prevMemCellState=(iTimeIndex == 0 ? null : fwdPass.memCellState[t - 1]);
    INDArray prevHiddenUnitActivation=(iTimeIndex == 0 ? null : fwdPass.fwdPassOutputAsArrays[t - 1]);
    INDArray currMemCellState=fwdPass.memCellState[t];
    INDArray epsilonSlice=(is2dInput ? epsilon : epsilon.tensorAlongDimension(t,1,0));
    INDArray nablaOut=Shape.toOffsetZeroCopy(epsilonSlice,'f');
    if (iTimeIndex != timeSeriesLength - 1) {
      Nd4j.gemm(deltaiNext,wI,nablaOut,false,true,1.0,1.0);
      Nd4j.gemm(deltafNext,wF,nablaOut,false,true,1.0,1.0);
      Nd4j.gemm(deltaoNext,wO,nablaOut,false,true,1.0,1.0);
      Nd4j.gemm(deltagNext,wG,nablaOut,false,true,1.0,1.0);
    }
    INDArray sigmahOfS=fwdPass.memCellActivations[t];
    INDArray ao=fwdPass.oa[t];
    INDArray sigmaoPrimeOfZo=Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform("timesoneminus",ao.dup('f')));
    INDArray deltao=nablaOut.dup('f').muli(sigmahOfS).muli(sigmaoPrimeOfZo);
    INDArray sigmahPrimeOfS=Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform(conf.getLayer().getActivationFunction(),currMemCellState.dup('f')).derivative());
    INDArray nablaCellState=ao.muli(nablaOut).muli(sigmahPrimeOfS);
    INDArray deltaMulRowWOO=deltao.dup('f').muliRowVector(wOOTranspose);
    l1BLAS.axpy(nablaCellState.length(),1.0,deltaMulRowWOO,nablaCellState);
    if (iTimeIndex != timeSeriesLength - 1) {
      INDArray nextForgetGateAs=fwdPass.fa[t + 1];
      int length=nablaCellState.length();
      l1BLAS.axpy(length,1.0,nextForgetGateAs.muli(nablaCellStateNext),nablaCellState);
      l1BLAS.axpy(length,1.0,deltafNext.dup('f').muliRowVector(wFFTranspose),nablaCellState);
      l1BLAS.axpy(length,1.0,deltagNext.dup('f').muliRowVector(wGGTranspose),nablaCellState);
    }
    nablaCellStateNext=nablaCellState;
    INDArray af=fwdPass.fa[t];
    INDArray deltaf=null;
    if (iTimeIndex > 0) {
      deltaf=nablaCellState.dup('f').muli(prevMemCellState).muli(Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform("timesoneminus",af.dup('f'))));
    }
    INDArray ag=fwdPass.ga[t];
    INDArray ai=fwdPass.ia[t];
    INDArray deltag=ai.muli(nablaCellState).muli(Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform("timesoneminus",ag.dup('f'))));
    INDArray zi=fwdPass.iz[t];
    INDArray deltai=ag.muli(nablaCellState).muli(Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform(conf.getLayer().getActivationFunction(),zi).derivative()));
    INDArray prevLayerActivationSlice=Shape.toMmulCompatible(is2dInput ? input : input.tensorAlongDimension(t,1,0));
    Nd4j.gemm(prevLayerActivationSlice,deltai,iwGradients[0],true,false,1.0,1.0);
    if (iTimeIndex > 0) {
      Nd4j.gemm(prevLayerActivationSlice,deltaf,iwGradients[1],true,false,1.0,1.0);
    }
    Nd4j.gemm(prevLayerActivationSlice,deltao,iwGradients[2],true,false,1.0,1.0);
    Nd4j.gemm(prevLayerActivationSlice,deltag,iwGradients[3],true,false,1.0,1.0);
    if (iTimeIndex > 0) {
      Nd4j.gemm(prevHiddenUnitActivation,deltai,rwGradients[0],true,false,1.0,1.0);
      Nd4j.gemm(prevHiddenUnitActivation,deltaf,rwGradients[1],true,false,1.0,1.0);
      Nd4j.gemm(prevHiddenUnitActivation,deltao,rwGradients[2],true,false,1.0,1.0);
      Nd4j.gemm(prevHiddenUnitActivation,deltag,rwGradients[3],true,false,1.0,1.0);
      INDArray dLdwFF=deltaf.dup('f').muli(prevMemCellState).sum(0);
      l1BLAS.axpy(rwGradients[4].length(),1.0,dLdwFF,rwGradients[4]);
      INDArray dLdwGG=deltag.dup('f').muli(prevMemCellState).sum(0);
      l1BLAS.axpy(rwGradients[6].length(),1.0,dLdwGG,rwGradients[6]);
    }
    INDArray dLdwOO=deltao.dup('f').muli(currMemCellState).sum(0);
    l1BLAS.axpy(rwGradients[5].length(),1.0,dLdwOO,rwGradients[5]);
    l1BLAS.axpy(bGradients[0].length(),1.0,deltai.sum(0),bGradients[0]);
    if (iTimeIndex > 0) {
      l1BLAS.axpy(bGradients[1].length(),1.0,deltaf.sum(0),bGradients[1]);
    }
    l1BLAS.axpy(bGradients[2].length(),1.0,deltao.sum(0),bGradients[2]);
    l1BLAS.axpy(bGradients[3].length(),1.0,deltag.sum(0),bGradients[3]);
    INDArray epsilonNextSlice=Nd4j.gemm(deltai,wi,false,true);
    Nd4j.gemm(deltao,wo,epsilonNextSlice,false,true,1.0,1.0);
    Nd4j.gemm(deltag,wg,epsilonNextSlice,false,true,1.0,1.0);
    if (iTimeIndex > 0) {
      Nd4j.gemm(deltaf,wf,epsilonNextSlice,false,true,1.0,1.0);
    }
    epsilonNext.tensorAlongDimension(t,1,0).assign(epsilonNextSlice);
    deltaiNext=deltai;
    deltafNext=deltaf;
    deltaoNext=deltao;
    deltagNext=deltag;
  }
  INDArray iwGradientsOut=Nd4j.zeros(prevLayerSize,4 * hiddenLayerSize);
  INDArray rwGradientsOut=Nd4j.zeros(hiddenLayerSize,4 * hiddenLayerSize + 3);
  INDArray bGradientsOut=Nd4j.hstack(bGradients);
  iwGradientsOut.put(new INDArrayIndex[]{NDArrayIndex.all(),interval(0,hiddenLayerSize)},iwGradients[0]);
  iwGradientsOut.put(new INDArrayIndex[]{NDArrayIndex.all(),interval(hiddenLayerSize,2 * hiddenLayerSize)},iwGradients[1]);
  iwGradientsOut.put(new INDArrayIndex[]{NDArrayIndex.all(),interval(2 * hiddenLayerSize,3 * hiddenLayerSize)},iwGradients[2]);
  iwGradientsOut.put(new INDArrayIndex[]{NDArrayIndex.all(),interval(3 * hiddenLayerSize,4 * hiddenLayerSize)},iwGradients[3]);
  rwGradientsOut.put(new INDArrayIndex[]{NDArrayIndex.all(),interval(0,hiddenLayerSize)},rwGradients[0]);
  rwGradientsOut.put(new INDArrayIndex[]{NDArrayIndex.all(),interval(hiddenLayerSize,2 * hiddenLayerSize)},rwGradients[1]);
  rwGradientsOut.put(new INDArrayIndex[]{NDArrayIndex.all(),interval(2 * hiddenLayerSize,3 * hiddenLayerSize)},rwGradients[2]);
  rwGradientsOut.put(new INDArrayIndex[]{NDArrayIndex.all(),interval(3 * hiddenLayerSize,4 * hiddenLayerSize)},rwGradients[3]);
  rwGradientsOut.put(new INDArrayIndex[]{NDArrayIndex.all(),NDArrayIndex.point(4 * hiddenLayerSize)},rwGradients[4].transpose());
  rwGradientsOut.put(new INDArrayIndex[]{NDArrayIndex.all(),NDArrayIndex.point(4 * hiddenLayerSize + 1)},rwGradients[5].transpose());
  rwGradientsOut.put(new INDArrayIndex[]{NDArrayIndex.all(),NDArrayIndex.point(4 * hiddenLayerSize + 2)},rwGradients[6].transpose());
  Gradient retGradient=new DefaultGradient();
  retGradient.gradientForVariable().put(inputWeightKey,iwGradientsOut);
  retGradient.gradientForVariable().put(recurrentWeightKey,rwGradientsOut);
  retGradient.gradientForVariable().put(biasWeightKey,bGradientsOut);
  return new Pair<>(retGradient,epsilonNext);
}
