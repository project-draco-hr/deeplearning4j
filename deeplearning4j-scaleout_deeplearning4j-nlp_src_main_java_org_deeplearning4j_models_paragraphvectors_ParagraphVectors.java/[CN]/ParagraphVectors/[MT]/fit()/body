{
  log.info("Building vocab");
  if (existingModel == null) {
    log.info("Building matrices & resetting weights...");
    buildVocab();
    lookupTable.resetWeights(true);
  }
 else {
    log.info("Importing matrices from existing Word2Vec model");
  }
  log.info("Total number of documents: " + labelsSource.getLabels().size());
  log.info("Training ParaVec multithreaded");
  totalWords=vocab.totalWordOccurrences();
  totalWords*=numIterations;
  log.info("Processing sentences...");
  int epoch=1;
  while (epoch <= epochs) {
    final AtomicLong nextRandom=new AtomicLong(5);
    final AtomicLong wordsCount=new AtomicLong(0);
    LabelledAsyncIteratorDigitizer roller=new LabelledAsyncIteratorDigitizer(labelAwareIterator);
    roller.start();
    final AtomicLong documentCount=new AtomicLong(0);
    final VectorCalculationsThread[] threads=new VectorCalculationsThread[workers];
    for (int x=0; x < workers; x++) {
      threads[x]=new VectorCalculationsThread(epoch,roller,nextRandom,documentCount,wordsCount);
      threads[x].start();
    }
    try {
      roller.join();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    for (int x=0; x < workers; x++) {
      try {
        threads[x].join();
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    log.info("Epoch: " + epoch + "; Documents vectorized so far: "+ documentCount.get());
    epoch++;
  }
}
