{
  boolean loaded=buildVocab();
  if (!loaded && saveVocab)   vocab().saveVocab();
  if (stopWords == null)   readStopWords();
  log.info("Training word2vec multithreaded");
  if (sentenceIter != null)   sentenceIter.reset();
  if (docIter != null)   docIter.reset();
  totalWords=vectorizer.numWordsEncountered();
  totalWords*=numIterations;
  log.info("Processing sentences...");
  final AtomicLong numWordsSoFar=new AtomicLong(0);
  final AtomicLong nextRandom=new AtomicLong(5);
  final AtomicInteger doc=new AtomicInteger(0);
  ExecutorService exec=new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(),Runtime.getRuntime().availableProcessors(),0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>(),new RejectedExecutionHandler(){
    @Override public void rejectedExecution(    Runnable r,    ThreadPoolExecutor executor){
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
      executor.submit(r);
    }
  }
);
  final Queue<Pair<List<VocabWord>,Collection<VocabWord>>> batch2=new ConcurrentLinkedDeque<>();
  int[] docs=vectorizer.index().allDocs();
  if (docs.length < 1)   throw new IllegalStateException("No documents found");
  vectorizer.index().eachDocWithLabels(new Function<Pair<List<VocabWord>,Collection<String>>,Void>(){
    @Override public Void apply(    @Nullable Pair<List<VocabWord>,Collection<String>> input){
      List<VocabWord> batch=new ArrayList<>();
      addWords(input.getFirst(),nextRandom,batch);
      if (batch.isEmpty())       return null;
      Collection<VocabWord> docLabels=new ArrayList<>();
      for (      String s : input.getSecond())       docLabels.add(vocab().wordFor(s));
      batch2.add(new Pair<>(batch,docLabels));
      doc.incrementAndGet();
      if (doc.get() > 0 && doc.get() % 10000 == 0)       log.info("Doc " + doc.get() + " done so far");
      return null;
    }
  }
,exec);
  if (!batch2.isEmpty()) {
    jobQueue.add(new LinkedList<>(batch2));
  }
  exec.shutdown();
  try {
    exec.awaitTermination(1,TimeUnit.DAYS);
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  for (int i=0; i < numIterations; i++)   doIteration(batch2,numWordsSoFar,nextRandom);
}
