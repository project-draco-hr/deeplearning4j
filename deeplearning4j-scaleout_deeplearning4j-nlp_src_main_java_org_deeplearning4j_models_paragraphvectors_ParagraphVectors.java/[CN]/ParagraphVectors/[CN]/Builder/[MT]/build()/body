{
  ParagraphVectors ret=new ParagraphVectors();
  if (this.generator == null)   this.generator=new LabelsSource();
  if (docIter != null) {
    if (docIter instanceof LabelAwareDocumentIterator)     this.labelAwareIterator=new DocumentIteratorConverter((LabelAwareDocumentIterator)docIter,generator);
 else     this.labelAwareIterator=new DocumentIteratorConverter(docIter,generator);
  }
 else   if (iter != null) {
    if (iter instanceof LabelAwareSentenceIterator)     this.labelAwareIterator=new SentenceIteratorConverter((LabelAwareSentenceIterator)iter,generator);
 else     this.labelAwareIterator=new SentenceIteratorConverter(iter,generator);
  }
 else   if (labelAwareIterator != null) {
    this.generator=labelAwareIterator.getLabelsSource();
  }
 else {
  }
  ret.labelAwareIterator=this.labelAwareIterator;
  ret.alpha.set(lr);
  ret.window=window;
  ret.useAdaGrad=useAdaGrad;
  ret.minLearningRate=minLearningRate;
  ret.vectorizer=textVectorizer;
  ret.stopWords=stopWords;
  ret.minWordFrequency=minWordFrequency;
  ret.setVocab(vocabCache);
  ret.minWordFrequency=minWordFrequency;
  ret.numIterations=iterations;
  ret.seed=seed;
  ret.numIterations=iterations;
  ret.saveVocab=saveVocab;
  ret.batchSize=batchSize;
  ret.sample=sampling;
  ret.workers=workers;
  ret.invertedIndex=index;
  ret.lookupTable=lookupTable;
  ret.epochs=this.numEpochs;
  ret.resetModel=true;
  ret.existingModel=this.existingW2V;
  ret.trainWordVectors=this.trainWordVectors;
  ret.labelsSource=this.generator;
  try {
    if (tokenizerFactory == null)     tokenizerFactory=new UimaTokenizerFactory();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  if (vocabCache == null) {
    vocabCache=new InMemoryLookupCache();
    ret.setVocab(vocabCache);
  }
  if (lookupTable == null) {
    lookupTable=new InMemoryLookupTable.Builder().negative(negative).useAdaGrad(useAdaGrad).lr(lr).cache(vocabCache).vectorLength(layerSize).build();
  }
  ret.lookupTable=lookupTable;
  ret.tokenizerFactory=tokenizerFactory;
  if (this.vocabCache != null)   ret.vocabularyHolder=new VocabularyHolder.Builder().externalCache(vocabCache).hugeModelExpected(hugeModelExpected).minWordFrequency(minWordFrequency).scavengerActivationThreshold(this.configuration.getScavengerActivationThreshold()).scavengerRetentionDelay(this.configuration.getScavengerRetentionDelay()).build();
 else   ret.vocabularyHolder=new VocabularyHolder.Builder().hugeModelExpected(hugeModelExpected).minWordFrequency(minWordFrequency).scavengerActivationThreshold(this.configuration.getScavengerActivationThreshold()).scavengerRetentionDelay(this.configuration.getScavengerRetentionDelay()).build();
  ret.labelsSource=this.generator;
  this.configuration.setLearningRate(lr);
  this.configuration.setLayersSize(layerSize);
  this.configuration.setHugeModelExpected(hugeModelExpected);
  this.configuration.setWindow(window);
  this.configuration.setMinWordFrequency(minWordFrequency);
  this.configuration.setIterations(iterations);
  this.configuration.setSeed(seed);
  this.configuration.setBatchSize(batchSize);
  this.configuration.setLearningRateDecayWords(learningRateDecayWords);
  this.configuration.setMinLearningRate(minLearningRate);
  this.configuration.setSampling(this.sampling);
  this.configuration.setUseAdaGrad(useAdaGrad);
  this.configuration.setNegative(negative);
  this.configuration.setEpochs(this.numEpochs);
  ret.configuration=this.configuration;
  return ret;
}
