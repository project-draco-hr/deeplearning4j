{
  INDArray W=getParam(ConvolutionParamInitializer.CONVOLUTION_WEIGHTS);
  if (W.shape()[1] != input.shape()[1])   throw new IllegalStateException("Input size at dimension 1 must be same as the filter size");
  final INDArray b=getParam(ConvolutionParamInitializer.CONVOLUTION_BIAS);
  INDArray convolution=Convolution.conv2d(input,W,Convolution.Type.VALID);
  if (convolution.shape().length < 4) {
    int[] newShape=new int[4];
    for (int i=0; i < newShape.length; i++)     newShape[i]=1;
    int lengthDiff=4 - convolution.shape().length;
    for (int i=lengthDiff; i < 4; i++)     newShape[i]=convolution.shape()[i - lengthDiff];
    convolution=convolution.reshape(newShape);
  }
  final INDArray pooled=getPool(convolution);
  final INDArray bias=b.dimShuffle(new Object[]{'x',0,'x','x'},new int[4],new boolean[]{true});
  final INDArray broadCasted=bias.broadcast(pooled.shape());
  pooled.addi(broadCasted);
  return Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform(conf.getActivationFunction(),pooled));
}
