{
  INDArray[] activations=activateHelper(true);
  INDArray outputActivations=activations[0];
  INDArray memCellState=activations[1];
  INDArray ifogZs=activations[2];
  INDArray ifogAs=activations[3];
  INDArray inputWeights=getParam(GravesLSTMParamInitializer.INPUT_WEIGHT_KEY);
  INDArray recurrentWeights=getParam(GravesLSTMParamInitializer.RECURRENT_WEIGHT_KEY);
  int hiddenLayerSize=recurrentWeights.size(0);
  int prevLayerSize=inputWeights.size(0);
  int miniBatchSize=epsilon.size(0);
  boolean is2dInput=epsilon.rank() < 3;
  int timeSeriesLength=(is2dInput ? 1 : epsilon.size(2));
  INDArray wi=inputWeights.get(NDArrayIndex.all(),interval(0,hiddenLayerSize));
  INDArray wI=recurrentWeights.get(NDArrayIndex.all(),interval(0,hiddenLayerSize));
  INDArray wf=inputWeights.get(NDArrayIndex.all(),interval(hiddenLayerSize,2 * hiddenLayerSize));
  INDArray wF=recurrentWeights.get(NDArrayIndex.all(),interval(hiddenLayerSize,2 * hiddenLayerSize));
  INDArray wFF=recurrentWeights.get(NDArrayIndex.all(),interval(4 * hiddenLayerSize,4 * hiddenLayerSize + 1));
  INDArray wo=inputWeights.get(NDArrayIndex.all(),interval(2 * hiddenLayerSize,3 * hiddenLayerSize));
  INDArray wO=recurrentWeights.get(NDArrayIndex.all(),interval(2 * hiddenLayerSize,3 * hiddenLayerSize));
  INDArray wOO=recurrentWeights.get(NDArrayIndex.all(),interval(4 * hiddenLayerSize + 1,4 * hiddenLayerSize + 2));
  INDArray wg=inputWeights.get(NDArrayIndex.all(),interval(3 * hiddenLayerSize,4 * hiddenLayerSize));
  INDArray wG=recurrentWeights.get(NDArrayIndex.all(),interval(3 * hiddenLayerSize,4 * hiddenLayerSize));
  INDArray wGG=recurrentWeights.get(NDArrayIndex.all(),interval(4 * hiddenLayerSize + 2,4 * hiddenLayerSize + 3));
  INDArray bGradients=Nd4j.zeros(1,4 * hiddenLayerSize);
  INDArray iwGradients=Nd4j.zeros(prevLayerSize,4 * hiddenLayerSize);
  INDArray rwGradients=Nd4j.zeros(hiddenLayerSize,4 * hiddenLayerSize + 3);
  INDArray epsilonNext=Nd4j.zeros(miniBatchSize,prevLayerSize,timeSeriesLength);
  INDArray nablaCellStateNext=Nd4j.zeros(miniBatchSize,hiddenLayerSize);
  INDArray deltaiNext=Nd4j.zeros(miniBatchSize,hiddenLayerSize);
  INDArray deltafNext=Nd4j.zeros(miniBatchSize,hiddenLayerSize);
  INDArray deltaoNext=Nd4j.zeros(miniBatchSize,hiddenLayerSize);
  INDArray deltagNext=Nd4j.zeros(miniBatchSize,hiddenLayerSize);
  for (int t=timeSeriesLength - 1; t >= 0; t--) {
    INDArray prevMemCellState=(t == 0 ? Nd4j.zeros(miniBatchSize,hiddenLayerSize) : memCellState.tensorAlongDimension(t - 1,1,0));
    INDArray prevHiddenUnitActivation=(t == 0 ? Nd4j.zeros(miniBatchSize,hiddenLayerSize) : outputActivations.tensorAlongDimension(t - 1,1,0));
    INDArray currMemCellState=(is2dInput ? memCellState : memCellState.tensorAlongDimension(t,1,0));
    INDArray epsilonSlice=(is2dInput ? epsilon : epsilon.tensorAlongDimension(t,1,0));
    INDArray nablaOut=epsilonSlice.dup().addi(deltaiNext.mmul(wI.transpose())).addi(deltafNext.mmul(wF.transpose())).addi(deltaoNext.mmul(wO.transpose())).addi(deltagNext.mmul(wG.transpose()));
    INDArray sigmahOfS=Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform(conf.getLayer().getActivationFunction(),currMemCellState.dup()));
    INDArray zo;
    if (is2dInput)     zo=ifogZs.get(NDArrayIndex.all(),interval(2 * hiddenLayerSize,3 * hiddenLayerSize));
 else     zo=ifogZs.tensorAlongDimension(t,1,0).get(NDArrayIndex.all(),interval(2 * hiddenLayerSize,3 * hiddenLayerSize));
    INDArray sigmaoPrimeOfZo=Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform("sigmoid",zo.dup()).derivative());
    INDArray deltao=nablaOut.mul(sigmahOfS).muli(sigmaoPrimeOfZo);
    INDArray sigmahPrimeOfS=Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform(conf.getLayer().getActivationFunction(),currMemCellState.dup()).derivative());
    INDArray ao;
    if (is2dInput)     ao=ifogAs.get(NDArrayIndex.all(),interval(2 * hiddenLayerSize,3 * hiddenLayerSize));
 else     ao=ifogAs.tensorAlongDimension(t,1,0).get(NDArrayIndex.all(),interval(2 * hiddenLayerSize,3 * hiddenLayerSize));
    INDArray nextForgetGateAs=(t == timeSeriesLength - 1 ? Nd4j.zeros(miniBatchSize,hiddenLayerSize) : ifogAs.tensorAlongDimension(t + 1,1,0).get(NDArrayIndex.all(),interval(hiddenLayerSize,2 * hiddenLayerSize)));
    INDArray nablaCellState=nablaOut.mul(ao).muli(sigmahPrimeOfS).addi(nextForgetGateAs.mul(nablaCellStateNext)).addi(deltafNext.mulRowVector(wFF.transpose())).addi(deltao.mulRowVector(wOO.transpose())).addi(deltagNext.mulRowVector(wGG.transpose()));
    nablaCellStateNext=nablaCellState;
    INDArray zf=(is2dInput ? ifogZs.get(NDArrayIndex.all(),interval(hiddenLayerSize,2 * hiddenLayerSize)) : ifogZs.tensorAlongDimension(t,1,0).get(NDArrayIndex.all(),interval(hiddenLayerSize,2 * hiddenLayerSize)));
    INDArray deltaf=nablaCellState.mul(prevMemCellState).muli(Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform("sigmoid",zf.dup()).derivative()));
    INDArray zg=(is2dInput ? ifogZs.get(NDArrayIndex.all(),interval(3 * hiddenLayerSize,4 * hiddenLayerSize)) : ifogZs.tensorAlongDimension(t,1,0).get(NDArrayIndex.all(),interval(3 * hiddenLayerSize,4 * hiddenLayerSize)));
    INDArray ai=(is2dInput ? ifogAs.get(NDArrayIndex.all(),interval(0,hiddenLayerSize)) : ifogAs.tensorAlongDimension(t,1,0).get(NDArrayIndex.all(),interval(0,hiddenLayerSize)));
    INDArray deltag=nablaCellState.mul(ai).muli(Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform("sigmoid",zg.dup()).derivative()));
    INDArray zi=(is2dInput ? ifogZs.get(NDArrayIndex.all(),interval(0,hiddenLayerSize)) : ifogZs.tensorAlongDimension(t,1,0).get(NDArrayIndex.all(),interval(0,hiddenLayerSize)));
    INDArray ag=(is2dInput ? ifogAs.get(NDArrayIndex.all(),interval(3 * hiddenLayerSize,4 * hiddenLayerSize)) : ifogAs.tensorAlongDimension(t,1,0).get(NDArrayIndex.all(),interval(3 * hiddenLayerSize,4 * hiddenLayerSize)));
    INDArray deltai=nablaCellState.mul(ag).muli(Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform(conf.getLayer().getActivationFunction(),zi.dup()).derivative()));
    INDArray prevLayerActivationSlice=(is2dInput ? input : input.tensorAlongDimension(t,1,0));
    iwGradients.get(new INDArrayIndex[]{NDArrayIndex.all(),interval(0,hiddenLayerSize)}).addi(deltai.transpose().mmul(prevLayerActivationSlice).transpose());
    iwGradients.get(new INDArrayIndex[]{NDArrayIndex.all(),interval(hiddenLayerSize,2 * hiddenLayerSize)}).addi(deltaf.transpose().mmul(prevLayerActivationSlice).transpose());
    iwGradients.get(new INDArrayIndex[]{NDArrayIndex.all(),interval(2 * hiddenLayerSize,3 * hiddenLayerSize)}).addi(deltao.transpose().mmul(prevLayerActivationSlice).transpose());
    iwGradients.get(new INDArrayIndex[]{NDArrayIndex.all(),interval(3 * hiddenLayerSize,4 * hiddenLayerSize)}).addi(deltag.transpose().mmul(prevLayerActivationSlice).transpose());
    if (t > 0) {
      rwGradients.get(new INDArrayIndex[]{NDArrayIndex.all(),interval(0,hiddenLayerSize)}).addi(deltai.transpose().mmul(prevHiddenUnitActivation).transpose());
      rwGradients.get(new INDArrayIndex[]{NDArrayIndex.all(),interval(hiddenLayerSize,2 * hiddenLayerSize)}).addi(deltaf.transpose().mmul(prevHiddenUnitActivation).transpose());
      rwGradients.get(new INDArrayIndex[]{NDArrayIndex.all(),interval(2 * hiddenLayerSize,3 * hiddenLayerSize)}).addi(deltao.transpose().mmul(prevHiddenUnitActivation).transpose());
      rwGradients.get(new INDArrayIndex[]{NDArrayIndex.all(),interval(3 * hiddenLayerSize,4 * hiddenLayerSize)}).addi(deltag.transpose().mmul(prevHiddenUnitActivation).transpose());
      INDArray dLdwFF=deltaf.mul(prevMemCellState).sum(0).transpose();
      rwGradients.get(new INDArrayIndex[]{NDArrayIndex.all(),NDArrayIndex.point(4 * hiddenLayerSize)}).addi(dLdwFF);
      INDArray dLdwGG=deltag.mul(prevMemCellState).sum(0).transpose();
      rwGradients.get(new INDArrayIndex[]{NDArrayIndex.all(),NDArrayIndex.point(4 * hiddenLayerSize + 2)}).addi(dLdwGG);
    }
    INDArray dLdwOO=deltao.mul(currMemCellState).sum(0).transpose();
    rwGradients.get(new INDArrayIndex[]{NDArrayIndex.all(),NDArrayIndex.point(4 * hiddenLayerSize + 1)}).addi(dLdwOO);
    bGradients.get(new INDArrayIndex[]{NDArrayIndex.point(0),interval(0,hiddenLayerSize)}).addi(deltai.sum(0));
    bGradients.get(new INDArrayIndex[]{NDArrayIndex.point(0),interval(hiddenLayerSize,2 * hiddenLayerSize)}).addi(deltaf.sum(0));
    bGradients.get(new INDArrayIndex[]{NDArrayIndex.point(0),interval(2 * hiddenLayerSize,3 * hiddenLayerSize)}).addi(deltao.sum(0));
    bGradients.get(new INDArrayIndex[]{NDArrayIndex.point(0),interval(3 * hiddenLayerSize,4 * hiddenLayerSize)}).addi(deltag.sum(0));
    INDArray epsilonNextSlice=wi.mmul(deltai.transpose()).transpose().addi(wf.mmul(deltaf.transpose()).transpose()).addi(wo.mmul(deltao.transpose()).transpose()).addi(wg.mmul(deltag.transpose()).transpose());
    epsilonNext.tensorAlongDimension(t,1,0).assign(epsilonNextSlice);
    deltaiNext=deltai;
    deltafNext=deltaf;
    deltaoNext=deltao;
    deltagNext=deltag;
  }
  Gradient retGradient=new DefaultGradient();
  retGradient.gradientForVariable().put(GravesLSTMParamInitializer.INPUT_WEIGHT_KEY,iwGradients);
  retGradient.gradientForVariable().put(GravesLSTMParamInitializer.RECURRENT_WEIGHT_KEY,rwGradients);
  retGradient.gradientForVariable().put(GravesLSTMParamInitializer.BIAS_KEY,bGradients);
  return new Pair<>(retGradient,epsilonNext);
}
