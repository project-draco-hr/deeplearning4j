{
  INDArray recurrentWeights=getParam(GravesLSTMParamInitializer.RECURRENT_WEIGHT_KEY);
  INDArray inputWeights=getParam(GravesLSTMParamInitializer.INPUT_WEIGHT_KEY);
  INDArray biases=getParam(GravesLSTMParamInitializer.BIAS_KEY);
  boolean is2dInput=input.rank() < 3;
  int timeSeriesLength=(is2dInput ? 1 : input.size(2));
  int hiddenLayerSize=recurrentWeights.size(0);
  int miniBatchSize=input.size(0);
  if (conf.isUseDropConnect() && training) {
    if (conf.getLayer().getDropOut() > 0) {
      inputWeights=Dropout.applyDropConnect(this,GravesLSTMParamInitializer.INPUT_WEIGHT_KEY);
    }
  }
  INDArray wi=inputWeights.get(NDArrayIndex.all(),interval(0,hiddenLayerSize));
  INDArray wI=recurrentWeights.get(NDArrayIndex.all(),interval(0,hiddenLayerSize));
  INDArray bi=biases.get(NDArrayIndex.point(0),interval(0,hiddenLayerSize));
  INDArray wf=inputWeights.get(NDArrayIndex.all(),interval(hiddenLayerSize,2 * hiddenLayerSize));
  INDArray wF=recurrentWeights.get(NDArrayIndex.all(),interval(hiddenLayerSize,2 * hiddenLayerSize));
  INDArray wFFTranspose=recurrentWeights.get(NDArrayIndex.all(),interval(4 * hiddenLayerSize,4 * hiddenLayerSize + 1)).transpose();
  INDArray bf=biases.get(NDArrayIndex.point(0),interval(hiddenLayerSize,2 * hiddenLayerSize));
  INDArray wo=inputWeights.get(NDArrayIndex.all(),interval(2 * hiddenLayerSize,3 * hiddenLayerSize));
  INDArray wO=recurrentWeights.get(NDArrayIndex.all(),interval(2 * hiddenLayerSize,3 * hiddenLayerSize));
  INDArray wOOTranspose=recurrentWeights.get(NDArrayIndex.all(),interval(4 * hiddenLayerSize + 1,4 * hiddenLayerSize + 2)).transpose();
  INDArray bo=biases.get(NDArrayIndex.point(0),interval(2 * hiddenLayerSize,3 * hiddenLayerSize));
  INDArray wg=inputWeights.get(NDArrayIndex.all(),interval(3 * hiddenLayerSize,4 * hiddenLayerSize));
  INDArray wG=recurrentWeights.get(NDArrayIndex.all(),interval(3 * hiddenLayerSize,4 * hiddenLayerSize));
  INDArray wGGTranspose=recurrentWeights.get(NDArrayIndex.all(),interval(4 * hiddenLayerSize + 2,4 * hiddenLayerSize + 3)).transpose();
  INDArray bg=biases.get(NDArrayIndex.point(0),interval(3 * hiddenLayerSize,4 * hiddenLayerSize));
  if (timeSeriesLength > 1 || forBackprop) {
    wi=Shape.toMmulCompatible(wi);
    wI=Shape.toMmulCompatible(wI);
    wf=Shape.toMmulCompatible(wf);
    wF=Shape.toMmulCompatible(wF);
    wFFTranspose=Shape.toMmulCompatible(wFFTranspose);
    wo=Shape.toMmulCompatible(wo);
    wO=Shape.toMmulCompatible(wO);
    wOOTranspose=Shape.toMmulCompatible(wOOTranspose);
    wg=Shape.toMmulCompatible(wg);
    wG=Shape.toMmulCompatible(wG);
    wGGTranspose=Shape.toMmulCompatible(wGGTranspose);
    bi=Shape.toMmulCompatible(bi);
    bf=Shape.toMmulCompatible(bf);
    bo=Shape.toMmulCompatible(bo);
    bg=Shape.toMmulCompatible(bg);
  }
  INDArray outputActivations=null;
  FwdPassReturn toReturn=new FwdPassReturn();
  if (forBackprop) {
    toReturn.paramsMmulCompatible=new INDArray[]{wi,wI,wf,wF,wFFTranspose,wo,wO,wOOTranspose,wg,wG,wGGTranspose};
    toReturn.fwdPassOutputAsArrays=new INDArray[timeSeriesLength];
    toReturn.memCellState=new INDArray[timeSeriesLength];
    toReturn.memCellActivations=new INDArray[timeSeriesLength];
    toReturn.iz=new INDArray[timeSeriesLength];
    toReturn.ia=new INDArray[timeSeriesLength];
    toReturn.fa=new INDArray[timeSeriesLength];
    toReturn.oa=new INDArray[timeSeriesLength];
    toReturn.ga=new INDArray[timeSeriesLength];
  }
 else {
    outputActivations=Nd4j.zeros(new int[]{miniBatchSize,hiddenLayerSize,timeSeriesLength});
    toReturn.fwdPassOutput=outputActivations;
  }
  if (prevOutputActivations == null)   prevOutputActivations=Nd4j.zeros(new int[]{miniBatchSize,hiddenLayerSize});
  if (prevMemCellState == null)   prevMemCellState=Nd4j.zeros(new int[]{miniBatchSize,hiddenLayerSize});
  for (int t=0; t < timeSeriesLength; t++) {
    INDArray miniBatchData=(is2dInput ? input : input.tensorAlongDimension(t,1,0));
    miniBatchData=Shape.toMmulCompatible(miniBatchData);
    INDArray inputActivations=miniBatchData.mmul(wi);
    Nd4j.gemm(prevOutputActivations,wI,inputActivations,false,false,1.0,1.0);
    inputActivations.addiRowVector(bi);
    if (forBackprop)     toReturn.iz[t]=inputActivations.dup('f');
    Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform(conf.getLayer().getActivationFunction(),inputActivations));
    if (forBackprop)     toReturn.ia[t]=inputActivations;
    INDArray forgetGateActivations=miniBatchData.mmul(wf);
    Nd4j.gemm(prevOutputActivations,wF,forgetGateActivations,false,false,1.0,1.0);
    INDArray pmcellWFF=prevMemCellState.dup('f').muliRowVector(wFFTranspose);
    Nd4j.getBlasWrapper().level1().axpy(pmcellWFF.length(),1.0,pmcellWFF,forgetGateActivations);
    forgetGateActivations.addiRowVector(bf);
    Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform("sigmoid",forgetGateActivations));
    if (forBackprop)     toReturn.fa[t]=forgetGateActivations;
    INDArray inputModGateActivations=miniBatchData.mmul(wg);
    Nd4j.gemm(prevOutputActivations,wG,inputModGateActivations,false,false,1.0,1.0);
    INDArray pmcellWGG=prevMemCellState.dup('f').muliRowVector(wGGTranspose);
    Nd4j.getBlasWrapper().level1().axpy(pmcellWGG.length(),1.0,pmcellWGG,inputModGateActivations);
    inputModGateActivations.addiRowVector(bg);
    Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform("sigmoid",inputModGateActivations));
    if (forBackprop)     toReturn.ga[t]=inputModGateActivations;
    INDArray currentMemoryCellState=forgetGateActivations.mul(prevMemCellState).addi(inputModGateActivations.mul(inputActivations));
    INDArray outputGateActivations=miniBatchData.mmul(wo);
    Nd4j.gemm(prevOutputActivations,wO,outputGateActivations,false,false,1.0,1.0);
    INDArray pmcellWOO=prevMemCellState.dup('f').muliRowVector(wOOTranspose);
    Nd4j.getBlasWrapper().level1().axpy(pmcellWOO.length(),1.0,pmcellWOO,outputGateActivations);
    outputGateActivations.addiRowVector(bo);
    Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform("sigmoid",outputGateActivations));
    if (forBackprop)     toReturn.oa[t]=outputGateActivations;
    INDArray currMemoryCellActivation=Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform(conf.getLayer().getActivationFunction(),currentMemoryCellState.dup('f')));
    INDArray currHiddenUnitActivations=currMemoryCellActivation.mul(outputGateActivations);
    if (forBackprop) {
      toReturn.fwdPassOutputAsArrays[t]=currHiddenUnitActivations;
      toReturn.memCellState[t]=currentMemoryCellState;
      toReturn.memCellActivations[t]=currMemoryCellActivation;
    }
 else {
      outputActivations.tensorAlongDimension(t,1,0).assign(currHiddenUnitActivations);
    }
    prevOutputActivations=currHiddenUnitActivations;
    prevMemCellState=currentMemoryCellState;
    toReturn.lastAct=currHiddenUnitActivations;
    toReturn.lastMemCell=currentMemoryCellState;
  }
  return toReturn;
}
