{
  INDArray recurrentWeights=getParam(GravesLSTMParamInitializer.RECURRENT_WEIGHT_KEY);
  INDArray inputWeights=getParam(GravesLSTMParamInitializer.INPUT_WEIGHT_KEY);
  INDArray biases=getParam(GravesLSTMParamInitializer.BIAS_KEY);
  boolean is2dInput=input.rank() < 3;
  int timeSeriesLength=(is2dInput ? 1 : input.size(2));
  int hiddenLayerSize=recurrentWeights.size(0);
  int miniBatchSize=input.size(0);
  if (conf.isUseDropConnect() && training) {
    if (conf.getLayer().getDropOut() > 0) {
      inputWeights=Dropout.applyDropConnect(this,GravesLSTMParamInitializer.INPUT_WEIGHT_KEY);
    }
  }
  INDArray wi=inputWeights.get(NDArrayIndex.all(),interval(0,hiddenLayerSize));
  INDArray wI=recurrentWeights.get(NDArrayIndex.all(),interval(0,hiddenLayerSize));
  INDArray bi=biases.get(NDArrayIndex.point(0),interval(0,hiddenLayerSize));
  INDArray wf=inputWeights.get(NDArrayIndex.all(),interval(hiddenLayerSize,2 * hiddenLayerSize));
  INDArray wF=recurrentWeights.get(NDArrayIndex.all(),interval(hiddenLayerSize,2 * hiddenLayerSize));
  INDArray wFF=recurrentWeights.get(NDArrayIndex.all(),interval(4 * hiddenLayerSize,4 * hiddenLayerSize + 1));
  INDArray bf=biases.get(NDArrayIndex.point(0),interval(hiddenLayerSize,2 * hiddenLayerSize));
  INDArray wo=inputWeights.get(NDArrayIndex.all(),interval(2 * hiddenLayerSize,3 * hiddenLayerSize));
  INDArray wO=recurrentWeights.get(NDArrayIndex.all(),interval(2 * hiddenLayerSize,3 * hiddenLayerSize));
  INDArray wOO=recurrentWeights.get(NDArrayIndex.all(),interval(4 * hiddenLayerSize + 1,4 * hiddenLayerSize + 2));
  INDArray bo=biases.get(NDArrayIndex.point(0),interval(2 * hiddenLayerSize,3 * hiddenLayerSize));
  INDArray wg=inputWeights.get(NDArrayIndex.all(),interval(3 * hiddenLayerSize,4 * hiddenLayerSize));
  INDArray wG=recurrentWeights.get(NDArrayIndex.all(),interval(3 * hiddenLayerSize,4 * hiddenLayerSize));
  INDArray wGG=recurrentWeights.get(NDArrayIndex.all(),interval(4 * hiddenLayerSize + 2,4 * hiddenLayerSize + 3));
  INDArray bg=biases.get(NDArrayIndex.point(0),interval(3 * hiddenLayerSize,4 * hiddenLayerSize));
  if (timeSeriesLength > 1) {
    wi=Shape.toOffsetZero(wi);
    wI=Shape.toOffsetZero(wI);
    wf=Shape.toOffsetZero(wf);
    wF=Shape.toOffsetZero(wF);
    wFF=Shape.toOffsetZero(wFF);
    wo=Shape.toOffsetZero(wo);
    wO=Shape.toOffsetZero(wO);
    wOO=Shape.toOffsetZero(wOO);
    wg=Shape.toOffsetZero(wg);
    wG=Shape.toOffsetZero(wG);
    wGG=Shape.toOffsetZero(wGG);
    bi=Shape.toOffsetZero(bi);
    bf=Shape.toOffsetZero(bf);
    bo=Shape.toOffsetZero(bo);
    bg=Shape.toOffsetZero(bg);
  }
  INDArray outputActivations=Nd4j.zeros(new int[]{miniBatchSize,hiddenLayerSize,timeSeriesLength});
  INDArray ifogZ=Nd4j.zeros(new int[]{miniBatchSize,4 * hiddenLayerSize,timeSeriesLength});
  INDArray ifogA=Nd4j.zeros(new int[]{miniBatchSize,4 * hiddenLayerSize,timeSeriesLength});
  INDArray memCellState=Nd4j.zeros(new int[]{miniBatchSize,hiddenLayerSize,timeSeriesLength});
  if (prevOutputActivations == null)   prevOutputActivations=Nd4j.zeros(new int[]{miniBatchSize,hiddenLayerSize});
  if (prevMemCellState == null)   prevMemCellState=Nd4j.zeros(new int[]{miniBatchSize,hiddenLayerSize});
  for (int t=0; t < timeSeriesLength; t++) {
    INDArray miniBatchData=(is2dInput ? input : input.tensorAlongDimension(t,1,0));
    miniBatchData=Shape.toOffsetZero(miniBatchData);
    INDArray inputActivations=miniBatchData.mmul(wi).addi(prevOutputActivations.mmul(wI)).addiRowVector(bi);
    INDArrayIndex[] iIndexes=new INDArrayIndex[]{NDArrayIndex.all(),interval(0,hiddenLayerSize)};
    ifogZ.tensorAlongDimension(t,1,0).put(iIndexes,inputActivations);
    Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform(conf.getLayer().getActivationFunction(),inputActivations));
    ifogA.tensorAlongDimension(t,1,0).put(iIndexes,inputActivations);
    INDArray forgetGateActivations=miniBatchData.mmul(wf).addi(prevOutputActivations.mmul(wF)).addi(prevMemCellState.mulRowVector(wFF.transpose())).addiRowVector(bf);
    INDArrayIndex[] fIndexes=new INDArrayIndex[]{NDArrayIndex.all(),interval(hiddenLayerSize,2 * hiddenLayerSize)};
    ifogZ.tensorAlongDimension(t,1,0).put(fIndexes,forgetGateActivations);
    Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform("sigmoid",forgetGateActivations));
    ifogA.tensorAlongDimension(t,1,0).put(fIndexes,forgetGateActivations);
    INDArray inputModGateActivations=miniBatchData.mmul(wg).addi(prevOutputActivations.mmul(wG)).addi(prevMemCellState.mulRowVector(wGG.transpose())).addiRowVector(bg);
    INDArrayIndex[] gIndexes=new INDArrayIndex[]{NDArrayIndex.all(),interval(3 * hiddenLayerSize,4 * hiddenLayerSize)};
    ifogZ.tensorAlongDimension(t,1,0).put(gIndexes,inputModGateActivations);
    Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform("sigmoid",inputModGateActivations));
    ifogA.tensorAlongDimension(t,1,0).put(gIndexes,inputModGateActivations);
    INDArray currentMemoryCellState=forgetGateActivations.mul(prevMemCellState).addi(inputModGateActivations.mul(inputActivations));
    INDArray outputGateActivations=miniBatchData.mmul(wo).addi(prevOutputActivations.mmul(wO)).addi(currentMemoryCellState.mulRowVector(wOO.transpose())).addiRowVector(bo);
    INDArrayIndex[] oIndexes=new INDArrayIndex[]{NDArrayIndex.all(),interval(2 * hiddenLayerSize,3 * hiddenLayerSize)};
    ifogZ.tensorAlongDimension(t,1,0).put(oIndexes,outputGateActivations);
    Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform("sigmoid",outputGateActivations));
    ifogA.tensorAlongDimension(t,1,0).put(oIndexes,outputGateActivations);
    INDArray currMemoryCellActivation=Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform(conf.getLayer().getActivationFunction(),currentMemoryCellState.dup()));
    INDArray currHiddenUnitActivations=currMemoryCellActivation.muli(outputGateActivations);
    outputActivations.tensorAlongDimension(t,1,0).assign(currHiddenUnitActivations);
    memCellState.tensorAlongDimension(t,1,0).assign(currentMemoryCellState);
    prevOutputActivations=currHiddenUnitActivations;
    prevMemCellState=currentMemoryCellState;
  }
  return new INDArray[]{outputActivations,memCellState,ifogZ,ifogA};
}
