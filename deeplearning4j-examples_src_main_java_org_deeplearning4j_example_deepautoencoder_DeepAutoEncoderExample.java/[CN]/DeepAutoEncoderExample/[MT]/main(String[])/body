{
  DataSetIterator iter=new MnistDataSetIterator(80,80);
  Map<Integer,Boolean> activationForLayer=new HashMap<>();
  activationForLayer.put(3,true);
  DBN dbn=new DBN.Builder().withHiddenUnitsByLayer(Collections.singletonMap(3,RBM.HiddenUnit.GAUSSIAN)).withLossFunction(NeuralNetwork.LossFunction.RECONSTRUCTION_CROSSENTROPY).hiddenLayerSizes(new int[]{1000,500,250,28}).withMomentum(0.9).withOptimizationAlgorithm(NeuralNetwork.OptimizationAlgorithm.CONJUGATE_GRADIENT).sampleOrActivateByLayer(activationForLayer).activateForLayer(Collections.singletonMap(3,Activations.sigmoid())).learningRateForLayer(Collections.singletonMap(3,1e-1)).numberOfInputs(784).numberOfOutPuts(2).build();
  while (iter.hasNext()) {
    DataSet data=iter.next();
    data.filterAndStrip(new int[]{0,1});
    dbn.pretrain(data.getFirst(),new Object[]{1,1e-1,100});
  }
  iter.reset();
  DeepAutoEncoder encoder=new DeepAutoEncoder(dbn);
  encoder.setVisibleUnit(RBM.VisibleUnit.GAUSSIAN);
  encoder.setHiddenUnit(RBM.HiddenUnit.BINARY);
  while (iter.hasNext()) {
    DataSet next=iter.next();
    next.filterAndStrip(new int[]{0,1});
    log.info("Fine tune " + next.labelDistribution());
    encoder.finetune(next.getFirst(),1e-1,1000);
  }
  iter.reset();
  while (iter.hasNext()) {
    DataSet data=iter.next();
    data.filterAndStrip(new int[]{0,1});
    DoubleMatrix reconstruct=encoder.reconstruct(data.getFirst());
    for (int j=0; j < data.numExamples(); j++) {
      DoubleMatrix draw1=data.get(j).getFirst().mul(255);
      DoubleMatrix reconstructed2=reconstruct.getRow(j);
      DoubleMatrix draw2=reconstructed2.mul(255);
      DrawReconstruction d=new DrawReconstruction(draw1);
      d.title="REAL";
      d.draw();
      DrawReconstruction d2=new DrawReconstruction(draw2);
      d2.title="TEST";
      d2.draw();
      Thread.sleep(10000);
      d.frame.dispose();
      d2.frame.dispose();
    }
  }
}
