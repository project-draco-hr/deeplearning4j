{
  DataSetIterator iter=new SamplingDataSetIterator(new MnistDataSetIterator(100,100).next(),100,10000);
  RandomGenerator rng=new MersenneTwister(123);
  DBN dbn=new DBN.Builder().learningRateForLayer(Collections.singletonMap(3,1e-1)).hiddenLayerSizes(new int[]{600,500,10}).withRng(rng).numberOfInputs(784).withDist(Distributions.normal(rng,0.1)).numberOfOutPuts(2).withMomentum(0.9).withDropOut(0.5).useRegularization(true).withL2(2e-4).build();
  log.info("Training with layers of " + RBMUtil.architecure(dbn));
  log.info("Begin training ");
  int numTimesIter=0;
  while (iter.hasNext()) {
    DataSet data=iter.next();
    dbn.pretrain(data.getFirst(),new Object[]{1,1e-1,10});
    log.info("Training " + numTimesIter++);
  }
  iter.reset();
  DeepAutoEncoder encoder=new DeepAutoEncoder(dbn);
  encoder.setRoundCodeLayerInput(true);
  encoder.setCodeLayerActivationFunction(Activations.sigmoid());
  encoder.setOutputLayerLossFunction(OutputLayer.LossFunction.RMSE_XENT);
  encoder.setUseHiddenActivationsForwardProp(false);
  while (iter.hasNext()) {
    DataSet next=iter.next();
    log.info("Fine tune " + next.labelDistribution());
    encoder.finetune(next.getFirst(),1e-1,1000);
  }
  iter.reset();
  while (iter.hasNext()) {
    DataSet data=iter.next();
    FilterRenderer f=new FilterRenderer();
    f.renderFilters(encoder.getOutputLayer().getW(),"outputlayer.png",28,28,data.numExamples());
    DeepAutoEncoderDataSetReconstructionRender r=new DeepAutoEncoderDataSetReconstructionRender(data.iterator(data.numExamples()),encoder);
    r.draw();
  }
}
