{
  INDArray[] activations=activateHelper(true);
  INDArray outputActivations=activations[0];
  INDArray rucZs=activations[2];
  INDArray rucAs=activations[3];
  INDArray inputWeights=getParam(GRUParamInitializer.INPUT_WEIGHTS);
  INDArray recurrentWeights=getParam(GRUParamInitializer.RECURRENT_WEIGHTS);
  int layerSize=recurrentWeights.size(0);
  int prevLayerSize=inputWeights.size(0);
  int miniBatchSize=epsilon.size(0);
  boolean is2dInput=epsilon.rank() < 3;
  int timeSeriesLength=(is2dInput ? 1 : epsilon.size(2));
  INDArray wr=inputWeights.get(NDArrayIndex.all(),interval(0,layerSize));
  INDArray wu=inputWeights.get(NDArrayIndex.all(),interval(layerSize,2 * layerSize));
  INDArray wc=inputWeights.get(NDArrayIndex.all(),interval(2 * layerSize,3 * layerSize));
  INDArray wR=recurrentWeights.get(NDArrayIndex.all(),interval(0,layerSize));
  INDArray wU=recurrentWeights.get(NDArrayIndex.all(),interval(layerSize,2 * layerSize));
  INDArray wC=recurrentWeights.get(NDArrayIndex.all(),interval(2 * layerSize,3 * layerSize));
  INDArray biasGradients=Nd4j.zeros(new int[]{miniBatchSize,3 * layerSize});
  INDArray inputWeightGradients=Nd4j.zeros(new int[]{prevLayerSize,3 * layerSize});
  INDArray recurrentWeightGradients=Nd4j.zeros(new int[]{layerSize,3 * layerSize});
  INDArray epsilonNext=Nd4j.zeros(miniBatchSize,prevLayerSize,timeSeriesLength);
  INDArray deltaOutNext=Nd4j.zeros(miniBatchSize,layerSize);
  INDArray deltaRNext=deltaOutNext;
  INDArray deltaUNext=deltaOutNext;
  INDArray deltaCNext=deltaOutNext;
  for (int t=timeSeriesLength - 1; t >= 0; t--) {
    INDArray prevOut=(t == 0 ? Nd4j.zeros(miniBatchSize,layerSize) : outputActivations.slice(t - 1,2));
    INDArray aSlice=(is2dInput ? rucAs : rucAs.slice(t,2));
    INDArray zSlice=(is2dInput ? rucZs : rucZs.slice(t,2));
    INDArray aSliceNext;
    if (t == timeSeriesLength - 1)     aSliceNext=Nd4j.zeros(miniBatchSize,3 * layerSize);
 else     aSliceNext=rucAs.slice(t,2);
    INDArray aOut=(is2dInput ? outputActivations : outputActivations.slice(t,2));
    INDArray auNext=aSliceNext.get(NDArrayIndex.all(),interval(layerSize,2 * layerSize));
    INDArray dOutNextdOut=null;
    INDArray epsilonSlice=(is2dInput ? epsilon : epsilon.slice(t,2));
    INDArray deltaOut=epsilonSlice.add(deltaOutNext.mmul(dOutNextdOut.transpose())).addi(deltaRNext.mmul(wR.transpose())).addi(deltaUNext.mmul(wU.transpose())).addi(deltaCNext.mmul(wC.transpose()));
    INDArray zu=zSlice.get(NDArrayIndex.all(),interval(layerSize,2 * layerSize));
    INDArray sigmaPrimeU=Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform("sigmoid",zu).derivative());
    INDArray ac=aSlice.get(NDArrayIndex.all(),interval(2 * layerSize,3 * layerSize));
    INDArray deltaU=deltaOut.mul(sigmaPrimeU).muli(prevOut.sub(ac));
    INDArray zc=zSlice.get(NDArrayIndex.all(),interval(2 * layerSize,3 * layerSize));
    INDArray sigmaPrimeC=Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform(conf.getActivationFunction(),zc).derivative());
    INDArray au=aSlice.get(NDArrayIndex.all(),interval(layerSize,2 * layerSize));
    INDArray deltaC=deltaOut.mul(sigmaPrimeC).muli(au.rsub(1.0));
    INDArray zr=zSlice.get(NDArrayIndex.all(),interval(0,layerSize));
    INDArray sigmaPrimeR=Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform("sigmoid",zr).derivative());
    INDArray deltaR=deltaC.mul(Nd4j.diag(wC)).muli(prevOut).muli(sigmaPrimeR);
    INDArray prevLayerActivationSlice=(is2dInput ? input : input.slice(t,2));
    inputWeightGradients.get(NDArrayIndex.all(),interval(0,layerSize)).addi(deltaR.transpose().mmul(prevLayerActivationSlice).transpose());
    inputWeightGradients.get(NDArrayIndex.all(),interval(layerSize,2 * layerSize)).addi(deltaU.transpose().mmul(prevLayerActivationSlice).transpose());
    inputWeightGradients.get(NDArrayIndex.all(),interval(2 * layerSize,3 * layerSize)).addi(deltaC.transpose().mmul(prevLayerActivationSlice).transpose());
    INDArray epsilonNextSlice=wr.mmul(deltaR.transpose()).transpose().addi(wu.mmul(deltaU.transpose()).transpose()).addi(wc.mmul(deltaC.transpose()).transpose());
    epsilonNext.slice(t,2).assign(epsilonNextSlice);
    deltaOutNext=deltaOut;
    deltaRNext=deltaR;
    deltaUNext=deltaU;
    deltaCNext=deltaC;
  }
  Gradient g=new DefaultGradient();
  g.setGradientFor(GRUParamInitializer.INPUT_WEIGHTS,inputWeightGradients);
  g.setGradientFor(GRUParamInitializer.RECURRENT_WEIGHTS,recurrentWeightGradients);
  g.setGradientFor(GRUParamInitializer.BIAS,biasGradients.sum(0,2));
  return new Pair<>(g,epsilonNext);
}
