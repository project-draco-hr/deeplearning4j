{
  INDArray[] activations=activateHelper(true);
  INDArray outputActivations=activations[0];
  INDArray rucZs=activations[1];
  INDArray rucAs=activations[2];
  INDArray inputWeights=getParam(GRUParamInitializer.INPUT_WEIGHTS);
  INDArray recurrentWeights=getParam(GRUParamInitializer.RECURRENT_WEIGHTS);
  int layerSize=recurrentWeights.size(0);
  int prevLayerSize=inputWeights.size(0);
  int miniBatchSize=epsilon.size(0);
  boolean is2dInput=epsilon.rank() < 3;
  int timeSeriesLength=(is2dInput ? 1 : epsilon.size(2));
  INDArray wr=inputWeights.get(NDArrayIndex.all(),interval(0,layerSize));
  INDArray wu=inputWeights.get(NDArrayIndex.all(),interval(layerSize,2 * layerSize));
  INDArray wc=inputWeights.get(NDArrayIndex.all(),interval(2 * layerSize,3 * layerSize));
  INDArray wR=recurrentWeights.get(NDArrayIndex.all(),interval(0,layerSize));
  INDArray wU=recurrentWeights.get(NDArrayIndex.all(),interval(layerSize,2 * layerSize));
  INDArray wC=recurrentWeights.get(NDArrayIndex.all(),interval(2 * layerSize,3 * layerSize));
  INDArray biasGradients=Nd4j.zeros(new int[]{miniBatchSize,3 * layerSize});
  INDArray inputWeightGradients=Nd4j.zeros(new int[]{prevLayerSize,3 * layerSize});
  INDArray recurrentWeightGradients=Nd4j.zeros(new int[]{layerSize,3 * layerSize});
  INDArray epsilonNext=Nd4j.zeros(miniBatchSize,prevLayerSize,timeSeriesLength);
  INDArray deltaOutNext=Nd4j.zeros(miniBatchSize,layerSize);
  INDArray deltaRNext=deltaOutNext;
  INDArray deltaUNext=deltaOutNext;
  INDArray deltaCNext=deltaOutNext;
  for (int t=timeSeriesLength - 1; t >= 0; t--) {
    INDArray prevOut=(t == 0 ? Nd4j.zeros(miniBatchSize,layerSize) : outputActivations.tensorAlongDimension(t - 1,1,0));
    INDArray aSlice=(is2dInput ? rucAs : rucAs.tensorAlongDimension(t,1,0));
    INDArray zSlice=(is2dInput ? rucZs : rucZs.tensorAlongDimension(t,1,0));
    INDArray aSliceNext;
    INDArray zSliceNext;
    if (t == timeSeriesLength - 1) {
      aSliceNext=Nd4j.zeros(miniBatchSize,3 * layerSize);
      zSliceNext=Nd4j.zeros(miniBatchSize,3 * layerSize);
    }
 else {
      aSliceNext=rucAs.tensorAlongDimension(t,1,0);
      zSliceNext=rucZs.tensorAlongDimension(t,1,0);
    }
    INDArray zr=zSlice.get(NDArrayIndex.all(),interval(0,layerSize));
    INDArray sigmaPrimeR=Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform("sigmoid",zr).derivative());
    INDArray dOutNextdOut;
    if (t == timeSeriesLength - 1) {
      dOutNextdOut=Nd4j.zeros(miniBatchSize,layerSize);
    }
 else {
      INDArray aOut=(is2dInput ? outputActivations : outputActivations.tensorAlongDimension(t,1,0));
      INDArray arNext=aSliceNext.get(NDArrayIndex.all(),interval(0,layerSize));
      INDArray auNext=aSliceNext.get(NDArrayIndex.all(),interval(layerSize,2 * layerSize));
      INDArray acNext=aSliceNext.get(NDArrayIndex.all(),interval(2 * layerSize,3 * layerSize));
      INDArray zuNext=zSliceNext.get(NDArrayIndex.all(),interval(layerSize,2 * layerSize));
      INDArray zcNext=zSliceNext.get(NDArrayIndex.all(),interval(2 * layerSize,3 * layerSize));
      INDArray sigmaPrimeUNext=Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform("sigmoid",zuNext).derivative());
      INDArray sigmaPrimeCNext=Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform(conf.getActivationFunction(),zcNext).derivative());
      INDArray second=aOut.sub(acNext).muli(sigmaPrimeUNext);
      INDArray third=auNext.rsub(1.0).muli(sigmaPrimeCNext);
      INDArray temp=Nd4j.diag(Nd4j.diag(wC)).mmul(arNext.transpose()).transpose().addi(Nd4j.diag(Nd4j.diag(wR)).mmul(wC.mmul(aOut.transpose())).transpose().muli(sigmaPrimeR));
      third.muli(temp);
      dOutNextdOut=auNext.add(second).addi(third);
    }
    INDArray epsilonSlice=(is2dInput ? epsilon : epsilon.tensorAlongDimension(t,1,0));
    INDArray deltaOut=epsilonSlice.add(deltaOutNext.mul(dOutNextdOut.transpose())).addi(deltaRNext.mmul(wR.transpose())).addi(deltaUNext.mmul(wU.transpose())).addi(deltaCNext.mmul(wC.transpose()));
    INDArray zu=zSlice.get(NDArrayIndex.all(),interval(layerSize,2 * layerSize));
    INDArray sigmaPrimeU=Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform("sigmoid",zu).derivative());
    INDArray ac=aSlice.get(NDArrayIndex.all(),interval(2 * layerSize,3 * layerSize));
    INDArray deltaU=deltaOut.mul(sigmaPrimeU).muli(prevOut.sub(ac));
    INDArray zc=zSlice.get(NDArrayIndex.all(),interval(2 * layerSize,3 * layerSize));
    INDArray sigmaPrimeC=Nd4j.getExecutioner().execAndReturn(Nd4j.getOpFactory().createTransform(conf.getActivationFunction(),zc).derivative());
    INDArray au=aSlice.get(NDArrayIndex.all(),interval(layerSize,2 * layerSize));
    INDArray deltaC=deltaOut.mul(sigmaPrimeC).muli(au.rsub(1.0));
    INDArray deltaR=deltaC.mul(Nd4j.diag(Nd4j.diag(wC)).mmul(prevOut.transpose()).transpose()).muli(sigmaPrimeR);
    INDArray prevLayerActivationSlice=(is2dInput ? input : input.tensorAlongDimension(t,1,0));
    inputWeightGradients.get(NDArrayIndex.all(),interval(0,layerSize)).addi(deltaR.transpose().mmul(prevLayerActivationSlice).transpose());
    inputWeightGradients.get(NDArrayIndex.all(),interval(layerSize,2 * layerSize)).addi(deltaU.transpose().mmul(prevLayerActivationSlice).transpose());
    inputWeightGradients.get(NDArrayIndex.all(),interval(2 * layerSize,3 * layerSize)).addi(deltaC.transpose().mmul(prevLayerActivationSlice).transpose());
    if (t > 0) {
      recurrentWeightGradients.get(NDArrayIndex.all(),interval(0,layerSize)).addi(deltaR.transpose().mmul(prevOut).transpose());
      recurrentWeightGradients.get(NDArrayIndex.all(),interval(layerSize,2 * layerSize)).addi(deltaU.transpose().mmul(prevOut).transpose());
      recurrentWeightGradients.get(NDArrayIndex.all(),interval(2 * layerSize,3 * layerSize)).addi(deltaC.transpose().mmul(prevOut).transpose());
    }
    biasGradients.get(NDArrayIndex.all(),interval(0,layerSize)).addi(deltaR);
    biasGradients.get(NDArrayIndex.all(),interval(layerSize,2 * layerSize)).addi(deltaU);
    biasGradients.get(NDArrayIndex.all(),interval(2 * layerSize,3 * layerSize)).addi(deltaC);
    INDArray epsilonNextSlice=wr.mmul(deltaR.transpose()).transpose().addi(wu.mmul(deltaU.transpose()).transpose()).addi(wc.mmul(deltaC.transpose()).transpose());
    epsilonNext.tensorAlongDimension(t,1,0).assign(epsilonNextSlice);
    deltaOutNext=deltaOut;
    deltaRNext=deltaR;
    deltaUNext=deltaU;
    deltaCNext=deltaC;
  }
  Gradient g=new DefaultGradient();
  g.setGradientFor(GRUParamInitializer.INPUT_WEIGHTS,inputWeightGradients);
  g.setGradientFor(GRUParamInitializer.RECURRENT_WEIGHTS,recurrentWeightGradients);
  g.setGradientFor(GRUParamInitializer.BIAS,biasGradients.sum(0));
  return new Pair<>(g,epsilonNext);
}
