{
  if (epsilon <= 0.0 || epsilon > 0.1)   throw new IllegalArgumentException("Invalid epsilon: expect epsilon in range (0,0.1], usually 1e-4 or so");
  if (maxRelError <= 0.0 || maxRelError > 0.25)   throw new IllegalArgumentException("Invalid maxRelativeError: " + maxRelError);
  if (!(mln.getOutputLayer() instanceof OutputLayer))   throw new IllegalArgumentException("Cannot check backprop gradients without OutputLayer");
  mln.setInput(input);
  mln.setLabels(labels);
  mln.feedForward();
  mln.computeGradientAndScore();
  Pair<Gradient,Double> gradAndScore=mln.gradientAndScore();
  if (useUpdater) {
    Updater updater=UpdaterCreator.getUpdater(mln);
    updater.update(mln,gradAndScore.getFirst(),0);
  }
  INDArray gradientToCheck=gradAndScore.getFirst().gradient(mln.conf().getVariables());
  INDArray originalParams=mln.params();
  OutputLayer ol=(OutputLayer)mln.getOutputLayer();
  int nParams=mln.numParams();
  int totalNFailures=0;
  double maxError=0.0;
  for (int i=0; i < nParams; i++) {
    INDArray params=originalParams.dup();
    params.putScalar(i,params.getDouble(i) + epsilon);
    mln.setParameters(params);
    mln.feedForward();
    double scorePlus=ol.computeScore();
    params.putScalar(i,params.getDouble(i) - 2 * epsilon);
    mln.setParameters(params);
    mln.feedForward();
    double scoreMinus=ol.computeScore();
    double numericalGradient=(scorePlus - scoreMinus) / (2 * epsilon);
    if (Double.isNaN(numericalGradient))     throw new IllegalStateException("Numerical gradient was NaN for parameter " + i + " of "+ nParams);
    double backpropGradient=gradientToCheck.getDouble(i);
    double relError=Math.abs(numericalGradient - backpropGradient) / Math.abs(numericalGradient);
    if (relError > maxRelError) {
      if (print)       System.out.println("Param " + i + " FAILED: grad="+ backpropGradient+ ", numericalGrad="+ numericalGradient+ ", relError="+ relError+ ", scorePlus="+ scorePlus+ ", scoreMinus="+ scoreMinus);
      if (exitOnFirstError)       return false;
      if (relError > maxError)       maxError=relError;
      totalNFailures++;
    }
 else     if (print) {
      System.out.println("Param " + i + " passed: grad="+ backpropGradient+ ", numericalGrad="+ numericalGradient+ ", relError="+ relError);
    }
  }
  if (print) {
    int nPass=nParams - totalNFailures;
    System.out.println("GradientCheckUtil.checkGradients(): " + nParams + " params checked, "+ nPass+ " passed, "+ totalNFailures+ " failed. Largest relative error = "+ maxError);
  }
  return totalNFailures == 0;
}
