{
  if (message instanceof DistributedPubSubMediator.SubscribeAck || message instanceof DistributedPubSubMediator.UnsubscribeAck) {
    DistributedPubSubMediator.SubscribeAck ack=(DistributedPubSubMediator.SubscribeAck)message;
    mediator.tell(new DistributedPubSubMediator.Publish(ClusterListener.TOPICS,message),getSelf());
    log.info("Subscribed " + ack.toString());
  }
 else   if (message instanceof DoneMessage) {
    log.info("Received done message");
    doDoneOrNextPhase();
  }
 else   if (message instanceof String) {
    getSender().tell(Ack.getInstance(),getSelf());
  }
 else   if (message instanceof MoreWorkMessage) {
    log.info("Prompted for more work, starting pipeline");
    mediator.tell(new DistributedPubSubMediator.Publish(BatchActor.BATCH,MoreWorkMessage.getInstance()),getSelf());
  }
 else   if (message instanceof Collection) {
    Collection<String> list=(Collection<String>)message;
    for (    String worker : list) {
      Job data=stateTracker.loadForWorker(worker);
      int numRetries=0;
      while (data == null && numRetries < 3) {
        data=stateTracker.loadForWorker(worker);
        numRetries++;
        if (data == null) {
          Thread.sleep(10000);
          log.info("Data still not found....sleeping for 10 seconds and trying again");
        }
      }
      if (data == null && numRetries >= 3) {
        log.info("No data found for worker..." + worker + " returning");
        return;
      }
      stateTracker.addJobToCurrent(data);
      data=null;
      log.info("Job delegated for " + worker);
    }
  }
 else   unhandled(message);
}
