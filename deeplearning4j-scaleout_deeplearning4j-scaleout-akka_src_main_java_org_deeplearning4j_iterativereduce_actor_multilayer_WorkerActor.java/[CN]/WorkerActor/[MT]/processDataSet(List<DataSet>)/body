{
  if (tracker.needsReplicate(id)) {
    try {
      log.info("Updating worker " + id);
      setE(tracker.getCurrent());
      setNetwork(tracker.getCurrent().get());
      tracker.doneReplicating(id);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  Future<UpdateableImpl> f=Futures.future(new Callable<UpdateableImpl>(){
    @Override public UpdateableImpl call() throws Exception {
      DoubleMatrix newInput=new DoubleMatrix(list.size(),list.get(0).getFirst().columns);
      DoubleMatrix newOutput=new DoubleMatrix(list.size(),list.get(0).getSecond().columns);
      for (int i=0; i < list.size(); i++) {
        newInput.putRow(i,list.get(i).getFirst());
        newOutput.putRow(i,list.get(i).getSecond());
      }
      UpdateableImpl work=compute();
      if (work != null) {
        log.info("Done working; adding update to mini batch...");
        tracker.addUpdate(work);
      }
 else {
        mediator.tell(new DistributedPubSubMediator.Publish(MasterActor.MASTER,NoJobFound.getInstance()),getSelf());
        log.info("No job found; unlocking worker " + id);
      }
      return work;
    }
  }
,getContext().dispatcher());
  ActorRefUtils.throwExceptionIfExists(f,context().dispatcher());
}
