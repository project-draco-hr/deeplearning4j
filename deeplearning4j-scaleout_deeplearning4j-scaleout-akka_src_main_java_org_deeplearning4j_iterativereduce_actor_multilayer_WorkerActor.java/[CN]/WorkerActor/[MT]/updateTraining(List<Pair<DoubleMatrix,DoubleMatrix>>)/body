{
  DoubleMatrix newInput=new DoubleMatrix(list.size(),list.get(0).getFirst().columns);
  DoubleMatrix newOutput=new DoubleMatrix(list.size(),list.get(0).getSecond().columns);
  for (int i=0; i < list.size(); i++) {
    newInput.putRow(i,list.get(i).getFirst());
    newOutput.putRow(i,list.get(i).getSecond());
  }
  setCombinedInput(newInput);
  setOutcomes(newOutput);
  Future<UpdateableImpl> f=Futures.future(new Callable<UpdateableImpl>(){
    @Override public UpdateableImpl call() throws Exception {
      UpdateableImpl work=compute();
      log.info("Updating parent actor...");
      mediator.tell(new DistributedPubSubMediator.Publish(MasterActor.MASTER,work),getSelf());
      return work;
    }
  }
,getContext().dispatcher());
  f.onComplete(new OnComplete<UpdateableImpl>(){
    @Override public void onComplete(    Throwable arg0,    UpdateableImpl work) throws Throwable {
      if (arg0 != null) {
        log.error("Unable to process work ",arg0);
        throw arg0;
      }
    }
  }
,context().dispatcher());
}
