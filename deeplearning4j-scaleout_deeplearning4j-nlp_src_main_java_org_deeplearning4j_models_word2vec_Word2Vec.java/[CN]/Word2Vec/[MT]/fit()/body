{
  boolean loaded=buildVocab();
  if (!loaded && saveVocab)   cache.saveVocab();
  if (stopWords == null)   readStopWords();
  log.info("Training word2vec multithreaded");
  if (sentenceIter != null)   sentenceIter.reset();
  if (docIter != null)   docIter.reset();
  final AtomicLong latch=new AtomicLong(0);
  ExecutorService service=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2);
  log.info("Processing sentences...");
  for (int i=0; i < numIterations; i++) {
    log.info("Iteration " + (i + 1));
    int numDocs=vectorizer.index().numDocuments();
    log.info("Training on " + numDocs);
    for (int j=0; j < numDocs; j++) {
      final int k=j;
      service.execute(new Runnable(){
        /** 
 * When an object implementing interface <code>Runnable</code> is used
 * to create a thread, starting the thread causes the object's
 * <code>run</code> method to be called in that separately executing
 * thread.
 * <p/>
 * The general contract of the method <code>run</code> is that it may
 * take any action whatsoever.
 * @see Thread#run()
 */
        @Override public void run(){
          trainSentence(vectorizer.index().document(k),k);
        }
      }
);
      numSentencesProcessed.incrementAndGet();
      if (numSentencesProcessed.get() % 100 == 0)       log.info("Num sentences processed " + numSentencesProcessed.get());
    }
    numSentencesProcessed.set(0);
  }
  try {
    service.shutdown();
    service.awaitTermination(1,TimeUnit.DAYS);
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  while (latch.get() > 0) {
    log.info("Waiting on sentences...Num processed so far " + numSentencesProcessed.get() + " with latch count at "+ latch.get());
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
}
