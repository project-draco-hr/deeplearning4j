{
  boolean loaded=buildVocab();
  if (!loaded && saveVocab)   cache.saveVocab();
  if (stopWords == null)   readStopWords();
  log.info("Training word2vec multithreaded");
  if (sentenceIter != null)   sentenceIter.reset();
  if (docIter != null)   docIter.reset();
  final ExecutorService service=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2);
  final Collection<Integer> docs=vectorizer.index().allDocs();
  int tries=0;
  while (docs.isEmpty()) {
    if (tries >= 3)     throw new IllegalStateException("Unable to train, no documents found");
 else {
      log.warn("No documents found...waiting 10 seconds on try " + tries);
      try {
        Thread.sleep(10000);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
      tries++;
    }
  }
  final AtomicInteger numSentencesProcessed=new AtomicInteger(0);
  totalWords=vectorizer.numWordsEncountered();
  totalWords*=numIterations;
  log.info("Processing sentences...");
  final List<Future<?>> futures2=new ArrayList<>();
  for (int i=0; i < numIterations; i++) {
    log.info("Training on " + docs.size());
    final AtomicLong nextRandom=new AtomicLong(5);
    Iterator<List<VocabWord>> minibatchesIter=vectorizer.index().miniBatches();
    while (minibatchesIter.hasNext()) {
      final List<VocabWord> batch=minibatchesIter.next();
      futures2.add(service.submit(new Callable<Void>(){
        @Override public Void call(){
          trainSentence(batch,numSentencesProcessed,nextRandom);
          return null;
        }
      }
));
    }
  }
  try {
    for (    Future<?> f : futures2)     f.get();
    service.shutdown();
    while (!service.isTerminated())     Thread.sleep(1000);
  }
 catch (  Exception e) {
    Thread.currentThread().interrupt();
  }
}
