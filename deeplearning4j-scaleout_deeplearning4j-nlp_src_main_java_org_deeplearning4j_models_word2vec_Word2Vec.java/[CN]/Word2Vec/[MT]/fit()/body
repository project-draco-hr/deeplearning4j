{
  if (trainingSystem == null) {
    trainingSystem=ActorSystem.create();
  }
  buildVocab();
  if (stopWords == null)   readStopWords();
  log.info("Training word2vec multithreaded");
  sentenceIter.reset();
  final AtomicLong latch=new AtomicLong(0);
  ActorRef skipgram=trainingSystem.actorOf(new RoundRobinPool(Runtime.getRuntime().availableProcessors()).props(Props.create(SkipGramActor.class,this).withDispatcher("akka.actor.worker-dispatcher")));
  ActorRef ref=trainingSystem.actorOf(new RoundRobinPool(Runtime.getRuntime().availableProcessors()).props(Props.create(SentenceActor.class,this,skipgram).withDispatcher("akka.actor.worker-dispatcher")));
  log.info("Processing sentences...");
  List<SentenceMessage> batch=new ArrayList<>();
  while (getSentenceIter().hasNext()) {
    String sentence=sentenceIter.nextSentence();
    if (sentence == null)     continue;
    ref.tell(new SentenceMessage(sentence,latch),ref);
    batch.add(new SentenceMessage(sentence,latch));
    if (batch.size() % 100 == 0) {
      ref.tell(new ArrayList<>(batch),ref);
      batch.clear();
    }
    numSentencesProcessed.incrementAndGet();
    if (numSentencesProcessed.get() % 100 == 0)     log.info("Num sentences processed " + numSentencesProcessed.get());
  }
  if (!batch.isEmpty()) {
    ref.tell(new ArrayList<>(batch),ref);
    batch.clear();
  }
  try {
    Thread.sleep(10000);
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  while (latch.get() > 0) {
    log.info("Waiting on sentences...Num processed so far " + numSentencesProcessed.get() + " with latch count at "+ latch.get());
    try {
      Thread.sleep(10000);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
}
