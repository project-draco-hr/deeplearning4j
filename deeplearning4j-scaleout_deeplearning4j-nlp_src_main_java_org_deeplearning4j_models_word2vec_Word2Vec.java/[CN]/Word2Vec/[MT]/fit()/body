{
  boolean loaded=buildVocab();
  if (!loaded && saveVocab)   cache.saveVocab();
  if (stopWords == null)   readStopWords();
  log.info("Training word2vec multithreaded");
  if (sentenceIter != null)   sentenceIter.reset();
  if (docIter != null)   docIter.reset();
  final int[] docs=vectorizer.index().allDocs();
  final AtomicInteger numSentencesProcessed=new AtomicInteger(0);
  totalWords=vectorizer.numWordsEncountered();
  totalWords*=numIterations;
  log.info("Processing sentences...");
  List<Thread> work=new ArrayList<>();
  for (int i=0; i < Runtime.getRuntime().availableProcessors(); i++) {
    final String name="worker" + i;
    Thread t=new Thread(new Runnable(){
      @Override public void run(){
        final AtomicLong nextRandom=new AtomicLong(5);
        long start=System.currentTimeMillis();
        long wordsSeen=0;
        while (true) {
          List<List<VocabWord>> job=jobQueue.poll();
          if (job == null)           continue;
          wordsSeen+=job.size();
          if (job != null && job.isEmpty()) {
            log.info("Shutting down worker " + name);
            break;
          }
          for (          List<VocabWord> sentence : job) {
            long before=System.currentTimeMillis();
            trainSentence(sentence,numSentencesProcessed,nextRandom);
            long after=System.currentTimeMillis();
            long diff=Math.abs(after - before);
            log.info("Took " + diff + " for sentence of size "+ sentence.size());
          }
        }
      }
    }
);
    t.setName("worker" + i);
    t.setDaemon(true);
    t.start();
    work.add(t);
  }
  final List<List<VocabWord>> batch=new ArrayList<>(batchSize);
  final AtomicLong nextRandom=new AtomicLong(5);
  final AtomicInteger doc=new AtomicInteger(0);
  final int numDocs=vectorizer.index().numDocuments();
  ExecutorService exec=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  vectorizer.index().eachDoc(new Function<List<VocabWord>,Void>(){
    @Nullable @Override public Void apply(    @Nullable List<VocabWord> input){
      addWords(input,nextRandom,batch);
      if (batch.size() >= batchSize) {
        doc.incrementAndGet();
        try {
          while (!jobQueue.offer(new ArrayList<>(batch),1,TimeUnit.MILLISECONDS)) {
            Thread.sleep(1);
          }
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
        if (doc.get() % 10000 == 0)         log.info("Doc " + doc.get() + " done so far out of "+ numDocs);
        batch.clear();
      }
      return null;
    }
  }
,exec);
  if (!jobQueue.isEmpty()) {
    jobQueue.add(new ArrayList<>(batch));
    batch.clear();
  }
  for (int i=0; i < work.size(); i++)   jobQueue.add(new ArrayList<List<VocabWord>>());
  for (  Thread t : work)   try {
    t.join();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  for (int i=0; i < numIterations; i++) {
    log.info("Training on " + docs.length);
  }
}
