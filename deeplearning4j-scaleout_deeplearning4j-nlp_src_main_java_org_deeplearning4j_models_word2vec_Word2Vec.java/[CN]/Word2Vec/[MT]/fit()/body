{
  if (trainingSystem == null)   trainingSystem=ActorSystem.create();
  buildVocab();
  cache.saveVocab();
  if (stopWords == null)   readStopWords();
  log.info("Training word2vec multithreaded");
  if (sentenceIter != null)   sentenceIter.reset();
  if (docIter != null)   docIter.reset();
  trainingSystem.shutdown();
  final AtomicLong latch=new AtomicLong(0);
  log.info("Processing sentences...");
  if (getSentenceIter() != null && getSentenceIter().hasNext())   for (int i=0; i < numIterations; i++) {
    while (getSentenceIter() != null && getSentenceIter().hasNext()) {
      final String sentence=sentenceIter.nextSentence();
      if (sentence == null)       continue;
      trainSentence(sentence);
      numSentencesProcessed.incrementAndGet();
      if (numSentencesProcessed.get() % 100 == 0)       log.info("Num sentences processed " + numSentencesProcessed.get());
    }
    if (sentenceIter != null)     sentenceIter.reset();
  }
  if (docIter != null && docIter.hasNext())   for (int iter=0; iter < numIterations; iter++) {
    while (docIter != null && docIter.hasNext()) {
      InputStream is=docIter.nextDocument();
      trainSentence(is);
      numSentencesProcessed.incrementAndGet();
      if (numSentencesProcessed.get() % 100 == 0)       log.info("Num sentences processed " + numSentencesProcessed.get());
      try {
        is.close();
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
    if (docIter != null)     docIter.reset();
  }
  while (latch.get() > 0) {
    log.info("Waiting on sentences...Num processed so far " + numSentencesProcessed.get() + " with latch count at "+ latch.get());
    try {
      Thread.sleep(10000);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
  trainingSystem.shutdown();
}
