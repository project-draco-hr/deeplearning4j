{
  if (trainingSystem == null) {
    trainingSystem=ActorSystem.create();
  }
  buildVocab();
  if (stopWords == null)   readStopWords();
  log.info("Training word2vec multithreaded");
  final AtomicLong changed=new AtomicLong(System.currentTimeMillis());
  trainingSystem.actorOf(new RoundRobinPool(Runtime.getRuntime().availableProcessors() * 3).props(Props.create(new SentenceActor.SentenceActorCreator(this)).withDispatcher("akka.actor.worker-dispatcher")));
  int numCores=Runtime.getRuntime().availableProcessors();
  final CountDownLatch latch=new CountDownLatch(numCores);
  for (int i=0; i < numCores; i++) {
    Future<Void> f=Futures.future(new Callable<Void>(){
      @Override public Void call() throws Exception {
        while (getSentenceIter().hasNext()) {
          final String sentence=sentenceIter.nextSentence();
          if (sentence != null && !sentence.isEmpty()) {
            Future<Void> f=Futures.future(new Callable<Void>(){
              @Override public Void call() throws Exception {
                processSentence(sentence);
                return null;
              }
            }
,trainingSystem.dispatcher());
            f.onComplete(new OnComplete<Void>(){
              @Override public void onComplete(              Throwable arg0,              Void arg1) throws Throwable {
                if (arg0 != null)                 throw arg0;
                numSentencesProcessed.incrementAndGet();
                changed.set(System.currentTimeMillis());
              }
            }
,trainingSystem.dispatcher());
          }
        }
        return null;
      }
    }
,trainingSystem.dispatcher());
    f.onComplete(new OnComplete<Void>(){
      @Override public void onComplete(      Throwable failure,      Void success) throws Throwable {
        latch.countDown();
      }
    }
,trainingSystem.dispatcher());
  }
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  boolean done=false;
  long fiveMinutes=TimeUnit.MINUTES.toMillis(1);
  while (!done) {
    long curr=System.currentTimeMillis();
    long lastChanged=changed.get();
    long diff=Math.abs(curr - lastChanged);
    if (diff >= fiveMinutes) {
      done=true;
    }
 else     try {
      Thread.sleep(15000);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
  if (trainingSystem != null)   trainingSystem.shutdown();
}
