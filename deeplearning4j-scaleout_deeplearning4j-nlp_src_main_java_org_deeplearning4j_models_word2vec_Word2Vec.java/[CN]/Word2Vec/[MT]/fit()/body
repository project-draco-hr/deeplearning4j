{
  boolean loaded=buildVocab();
  if (!loaded)   cache.saveVocab();
  if (stopWords == null)   readStopWords();
  log.info("Training word2vec multithreaded");
  if (sentenceIter != null)   sentenceIter.reset();
  if (docIter != null)   docIter.reset();
  final AtomicLong latch=new AtomicLong(0);
  ExecutorService service=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2);
  log.info("Processing sentences...");
  for (int i=0; i < numIterations; i++) {
    while (getSentenceIter() != null && getSentenceIter().hasNext()) {
      final String sentence=sentenceIter.nextSentence();
      if (sentence == null)       continue;
      service.execute(new Runnable(){
        /** 
 * When an object implementing interface <code>Runnable</code> is used
 * to create a thread, starting the thread causes the object's
 * <code>run</code> method to be called in that separately executing
 * thread.
 * <p/>
 * The general contract of the method <code>run</code> is that it may
 * take any action whatsoever.
 * @see Thread#run()
 */
        @Override public void run(){
          trainSentence(sentence);
        }
      }
);
      numSentencesProcessed.incrementAndGet();
      if (numSentencesProcessed.get() % 100 == 0)       log.info("Num sentences processed " + numSentencesProcessed.get());
    }
    if (sentenceIter != null)     sentenceIter.reset();
  }
  for (int iter=0; iter < numIterations; iter++) {
    List<Future<?>> futures=new ArrayList<>();
    while (docIter != null && docIter.hasNext()) {
      final InputStream is=docIter.nextDocument();
      Future<?> f=service.submit(new Runnable(){
        /** 
 * When an object implementing interface <code>Runnable</code> is used
 * to create a thread, starting the thread causes the object's
 * <code>run</code> method to be called in that separately executing
 * thread.
 * <p/>
 * The general contract of the method <code>run</code> is that it may
 * take any action whatsoever.
 * @see Thread#run()
 */
        @Override public void run(){
          trainSentence(is);
          try {
            is.close();
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
      }
);
      futures.add(f);
      numSentencesProcessed.incrementAndGet();
      if (numSentencesProcessed.get() % 1000 == 0)       log.info("Num sentences processed " + numSentencesProcessed.get());
      while (futures.size() > 100) {
        Set<Future<?>> remove=new HashSet<>();
        for (        Future<?> f2 : futures) {
          if (f2.isDone())           remove.add(f2);
        }
        futures.removeAll(remove);
      }
    }
    if (docIter != null)     docIter.reset();
  }
  try {
    service.shutdown();
    service.awaitTermination(1,TimeUnit.DAYS);
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  while (latch.get() > 0) {
    log.info("Waiting on sentences...Num processed so far " + numSentencesProcessed.get() + " with latch count at "+ latch.get());
    try {
      Thread.sleep(10000);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
}
