{
  if (sentenceIter == null && docIter == null)   throw new IllegalStateException("At least one iterator is needed for model fit()");
  final LinkedBlockingQueue<List<VocabWord>> sentences=new LinkedBlockingQueue<>();
  if (resetModel) {
    log.info("Building matrices & resetting weights...");
    buildVocab();
    lookupTable.resetWeights(true);
    resetModel=true;
  }
  final long totalWordsCount=vocab.totalWordOccurrences() * numIterations * epochs;
  log.info("Total number of words in vocab: [" + vocab.numWords() + "], word occurencies: ["+ vocab.totalWordOccurrences()+ "], buffed words count: ["+ totalWordsCount+ "], number of Epochs: ["+ epochs+ "],  number of Iterations:["+ numIterations+ "]");
  int epoch=1;
  final long maxLines=totalLines.get();
  while (epoch <= epochs) {
    log.info("Starting async iterator...");
    totalLines.set(0);
    final AtomicLong wordsCounter=new AtomicLong(0);
    AsyncIteratorDigitizer roller=new AsyncIteratorDigitizer(sentenceIter,sentences,totalLines);
    roller.start();
    log.info("Starting vectorization process...");
    final VectorCalculationsThread[] threads=new VectorCalculationsThread[workers];
    for (int x=0; x < workers; x++) {
      threads[x]=new VectorCalculationsThread(x,maxLines,epoch,wordsCounter,totalWordsCount,totalLines,sentences,roller);
      threads[x].start();
    }
    try {
      roller.join();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    for (int x=0; x < workers; x++) {
      try {
        threads[x].join();
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    log.info("Epoch: " + epoch + "; Lines vectorized so far: "+ totalLines.get());
    epoch++;
  }
  log.info("Vectorization accomplished.");
}
