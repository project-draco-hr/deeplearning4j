{
  boolean loaded=buildVocab();
  if (!loaded && saveVocab)   cache.saveVocab();
  if (stopWords == null)   readStopWords();
  log.info("Training word2vec multithreaded");
  if (sentenceIter != null)   sentenceIter.reset();
  if (docIter != null)   docIter.reset();
  final ExecutorService service=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2);
  final Collection<Integer> docs=vectorizer.index().allDocs();
  final AtomicInteger numSentencesProcessed=new AtomicInteger(0);
  for (  int j : docs)   totalWords+=vectorizer.index().document(j).size();
  totalWords*=numIterations;
  log.info("Processing sentences...");
  final List<Future<?>> futures2=new ArrayList<>();
  for (int i=0; i < numIterations; i++) {
    log.info("Training on " + docs.size());
    final List<VocabWord> docMiniBatch=new CopyOnWriteArrayList<>();
    final List<List<VocabWord>> minibatches=new ArrayList<>();
    for (    int j : docs) {
      final int k=j;
      docMiniBatch.addAll(vectorizer.index().document(k));
      if (docMiniBatch.size() >= batchSize) {
        minibatches.add(new ArrayList<>(docMiniBatch));
        docMiniBatch.clear();
      }
    }
    for (    final List<VocabWord> batch : minibatches) {
      futures2.add(service.submit(new Callable<Void>(){
        @Override public Void call(){
          trainSentence(batch,numSentencesProcessed);
          docMiniBatch.clear();
          return null;
        }
      }
));
    }
  }
  try {
    for (    Future<?> f : futures2)     f.get();
    service.shutdown();
    while (!service.isTerminated())     Thread.sleep(1000);
  }
 catch (  Exception e) {
    Thread.currentThread().interrupt();
  }
}
