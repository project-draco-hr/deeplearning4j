{
  boolean loaded=buildVocab();
  if (!loaded && saveVocab)   cache.saveVocab();
  if (stopWords == null)   readStopWords();
  log.info("Training word2vec multithreaded");
  if (sentenceIter != null)   sentenceIter.reset();
  if (docIter != null)   docIter.reset();
  final int[] docs=vectorizer.index().allDocs();
  final AtomicLong numSentencesProcessed=new AtomicLong(0);
  totalWords=vectorizer.numWordsEncountered();
  totalWords*=numIterations;
  log.info("Processing sentences...");
  List<Thread> work=new ArrayList<>();
  final AtomicInteger processed=new AtomicInteger(0);
  final int allDocs=docs.length * numIterations;
  for (int i=0; i < Runtime.getRuntime().availableProcessors(); i++) {
    final Set<List<VocabWord>> set=new ConcurrentHashSet<>();
    Thread t=new Thread(new Runnable(){
      @Override public void run(){
        final AtomicLong nextRandom=new AtomicLong(5);
        while (true) {
          if (processed.get() >= allDocs)           return;
          List<VocabWord> job=null;
          job=jobQueue.poll();
          if (job == null || job.isEmpty() || set.contains(job))           continue;
          trainSentence(job,numSentencesProcessed,nextRandom);
          processed.incrementAndGet();
        }
      }
    }
);
    t.setName("worker" + i);
    t.start();
    work.add(t);
  }
  final AtomicLong nextRandom=new AtomicLong(5);
  final AtomicInteger doc=new AtomicInteger(0);
  final int numDocs=vectorizer.index().numDocuments() * numIterations;
  ExecutorService exec=new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(),Runtime.getRuntime().availableProcessors(),0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>(),new RejectedExecutionHandler(){
    @Override public void rejectedExecution(    Runnable r,    ThreadPoolExecutor executor){
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
      executor.submit(r);
    }
  }
);
  vectorizer.index().eachDoc(new Function<List<VocabWord>,Void>(){
    @Override public Void apply(    List<VocabWord> input){
      List<VocabWord> batch=new ArrayList<>();
      addWords(input,nextRandom,batch);
      if (batch.isEmpty())       return null;
      for (int i=0; i < numIterations; i++) {
        jobQueue.add(batch);
      }
      doc.incrementAndGet();
      if (doc.get() > 0 && doc.get() % 10000 == 0)       log.info("Doc " + doc.get() + " done so far out of "+ numDocs);
      return null;
    }
  }
,exec);
  exec.shutdown();
  try {
    exec.awaitTermination(1,TimeUnit.DAYS);
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  for (  Thread t : work)   try {
    t.join();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
}
