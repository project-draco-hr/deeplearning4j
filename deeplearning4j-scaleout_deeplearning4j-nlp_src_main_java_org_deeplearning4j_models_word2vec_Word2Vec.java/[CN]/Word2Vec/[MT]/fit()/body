{
  boolean loaded=buildVocab();
  if (!loaded && saveVocab)   cache.saveVocab();
  if (stopWords == null)   readStopWords();
  log.info("Training word2vec multithreaded");
  if (sentenceIter != null)   sentenceIter.reset();
  if (docIter != null)   docIter.reset();
  final ExecutorService service=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2);
  final Collection<Integer> docs=vectorizer.index().allDocs();
  int tries=0;
  while (docs.isEmpty()) {
    if (tries >= 3)     throw new IllegalStateException("Unable to train, no documents found");
 else {
      log.warn("No documents found...waiting 10 seconds on try " + tries);
      try {
        Thread.sleep(10000);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
      tries++;
    }
  }
  final AtomicInteger numSentencesProcessed=new AtomicInteger(0);
  totalWords*=numIterations;
  log.info("Processing sentences...");
  final List<Future<?>> futures2=new ArrayList<>();
  for (int i=0; i < numIterations; i++) {
    log.info("Training on " + docs.size());
    final List<VocabWord> docMiniBatch=new CopyOnWriteArrayList<>();
    final List<List<VocabWord>> minibatches=new ArrayList<>();
    final AtomicLong nextRandom=new AtomicLong(5);
    for (    int j : docs) {
      final int k=j;
      List<VocabWord> doc=vectorizer.index().document(k);
      for (      VocabWord word : doc) {
        if (word == null || word.getWord() == null)         continue;
        if (sample > 0) {
          double ran=(Math.sqrt(word.getWordFrequency() / (sample * numSentencesProcessed.get())) + 1) * (sample * numSentencesProcessed.get()) / word.getWordFrequency();
          if (ran < (nextRandom.get() & 0xFFFF) / (double)65536) {
            continue;
          }
          docMiniBatch.add(word);
        }
 else         docMiniBatch.add(word);
      }
      if (docMiniBatch.size() >= batchSize) {
        minibatches.add(new ArrayList<>(docMiniBatch));
        docMiniBatch.clear();
      }
    }
    for (    final List<VocabWord> batch : minibatches) {
      futures2.add(service.submit(new Callable<Void>(){
        @Override public Void call(){
          trainSentence(batch,numSentencesProcessed,nextRandom);
          docMiniBatch.clear();
          return null;
        }
      }
));
    }
  }
  try {
    for (    Future<?> f : futures2)     f.get();
    service.shutdown();
    while (!service.isTerminated())     Thread.sleep(1000);
  }
 catch (  Exception e) {
    Thread.currentThread().interrupt();
  }
}
