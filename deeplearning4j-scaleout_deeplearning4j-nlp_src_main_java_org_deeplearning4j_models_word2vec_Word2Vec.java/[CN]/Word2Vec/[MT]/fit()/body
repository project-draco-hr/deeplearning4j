{
  boolean loaded=buildVocab();
  if (!loaded && saveVocab)   vocab().saveVocab();
  if (stopWords == null)   readStopWords();
  log.info("Training word2vec multithreaded");
  if (sentenceIter != null)   sentenceIter.reset();
  if (docIter != null)   docIter.reset();
  int[] docs=vectorizer.index().allDocs();
  if (docs.length < 1) {
    vectorizer.fit();
  }
  docs=vectorizer.index().allDocs();
  if (docs.length < 1) {
    throw new IllegalStateException("No documents found");
  }
  totalWords=vectorizer.numWordsEncountered();
  if (totalWords < 1)   throw new IllegalStateException("Unable to train, total words less than 1");
  totalWords*=numIterations;
  log.info("Processing sentences...");
  AtomicLong numWordsSoFar=new AtomicLong(0);
  final AtomicLong nextRandom=new AtomicLong(5);
  ExecutorService exec=new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(),Runtime.getRuntime().availableProcessors(),0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>(),new RejectedExecutionHandler(){
    @Override public void rejectedExecution(    Runnable r,    ThreadPoolExecutor executor){
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
      executor.submit(r);
    }
  }
);
  final Queue<List<VocabWord>> batch2=new ConcurrentLinkedDeque<>();
  vectorizer.index().eachDoc(new Function<List<VocabWord>,Void>(){
    @Override public Void apply(    List<VocabWord> input){
      List<VocabWord> batch=new ArrayList<>();
      addWords(input,nextRandom,batch);
      if (!batch.isEmpty()) {
        batch2.add(batch);
      }
      return null;
    }
  }
,exec);
  exec.shutdown();
  try {
    exec.awaitTermination(1,TimeUnit.DAYS);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  ActorSystem actorSystem=ActorSystem.create();
  for (int i=0; i < numIterations; i++)   doIteration(batch2,numWordsSoFar,nextRandom,actorSystem);
  actorSystem.shutdown();
}
