{
  boolean loaded=buildVocab();
  if (!loaded && saveVocab)   cache.saveVocab();
  if (stopWords == null)   readStopWords();
  log.info("Training word2vec multithreaded");
  if (sentenceIter != null)   sentenceIter.reset();
  if (docIter != null)   docIter.reset();
  final ExecutorService service=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2);
  final Collection<Integer> docs=vectorizer.index().allDocs();
  final List<Callable<Void>> futures=new ArrayList<>();
  log.info("Processing sentences...");
  for (int i=0; i < numIterations; i++) {
    futures.add(new Callable<Void>(){
      @Override public Void call(){
        final AtomicInteger numSentencesProcessed=new AtomicInteger(0);
        final AtomicDouble d=new AtomicDouble(alpha.doubleValue());
        log.info("Training on " + docs.size());
        for (        int j : docs) {
          final int k=j;
          service.submit(new Callable<Void>(){
            @Override public Void call(){
              trainSentence(vectorizer.index().document(k),k,numSentencesProcessed,d);
              return null;
            }
          }
);
        }
        return null;
      }
    }
);
  }
  try {
    List<Future<Void>> f2=service.invokeAll(futures);
    service.shutdown();
    while (!service.isTerminated())     Thread.sleep(1000);
  }
 catch (  Exception e) {
    Thread.currentThread().interrupt();
  }
}
