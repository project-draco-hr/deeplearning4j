{
  INDArray words=Nd4j.create(positive.size() + negative.size(),layerSize);
  int row=0;
  for (  String s : positive) {
    words.putRow(row++,cache.vector(s));
  }
  for (  String s : negative) {
    words.putRow(row++,cache.vector(s).mul(-1));
  }
  INDArray mean=words.mean(0);
  if (cache instanceof InMemoryLookupCache) {
    InMemoryLookupCache l=(InMemoryLookupCache)cache;
    INDArray syn0=l.getSyn0();
    INDArray weights=syn0.norm2(0).rdivi(1).muli(mean);
    INDArray distances=syn0.mulRowVector(weights).sum(1);
    INDArray[] sorted=Nd4j.sortWithIndices(distances,0,false);
    INDArray sort=sorted[0];
    List<String> ret=new ArrayList<>();
    if (top > sort.length())     top=sort.length();
    for (int i=0; i < top + 1; i++) {
      ret.add(cache.wordAtIndex(sort.getInt(i)));
    }
    return ret;
  }
  Counter<String> distances=new Counter<>();
  for (  String s : cache.words()) {
    INDArray otherVec=getWordVectorMatrix(s);
    double sim=Transforms.cosineSim(mean,otherVec);
    distances.incrementCount(s,sim);
  }
  distances.keepTopNKeys(top);
  return distances.keySet();
}
