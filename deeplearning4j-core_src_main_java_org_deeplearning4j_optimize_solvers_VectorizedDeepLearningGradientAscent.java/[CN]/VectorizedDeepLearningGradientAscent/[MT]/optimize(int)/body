{
  int iterations;
  double fret;
  double fp=optimizable.getValue();
  INDArray xi=optimizable.getValueGradient(0);
  for (iterations=0; iterations < numIterations; iterations++) {
    logger.info("At iteration " + iterations + ", cost = "+ fp+ ", scaled = "+ maxStep+ " step = "+ step+ ", gradient infty-norm = "+ xi.normmax(Integer.MAX_VALUE));
    boolean calledEpochDone=false;
    optimizable.setCurrentIteration(iterations);
    double sum=xi.norm2(Integer.MAX_VALUE).getDouble(0);
    if (sum > stpmax) {
      logger.info("*** Step 2-norm " + sum + " greater than max "+ stpmax+ "  Scaling...");
      xi.muli(stpmax / sum);
    }
    try {
      step=lineMaximizer.optimize(xi,iterations,step);
    }
 catch (    InvalidStepException e) {
      logger.warn("Error during computation",e);
      continue;
    }
    fret=optimizable.getValue();
    if (2.0 * Math.abs(fret - fp) <= tolerance * (Math.abs(fret) + Math.abs(fp) + eps)) {
      logger.info("Gradient Ascent: Value difference " + Math.abs(fret - fp) + " below "+ "tolerance; saying converged.");
      converged=true;
      if (listener != null) {
        listener.iterationDone(iterations);
        calledEpochDone=true;
      }
      return true;
    }
    fp=fret;
    xi=optimizable.getValueGradient(iterations);
    if (listener != null && !calledEpochDone) {
      listener.iterationDone(iterations);
    }
    if (eval != null && eval.shouldStop(iterations)) {
      return true;
    }
  }
  return false;
}
