{
  if (trainingSystem == null)   trainingSystem=ActorSystem.create();
  if (stopWords == null)   readStopWords();
  log.info("Training word2vec multithreaded");
  MapFactory<String,Double> factory=new MapFactory<String,Double>(){
    private static final long serialVersionUID=5447027920163740307L;
    @Override public Map<String,Double> buildMap(){
      return new java.util.concurrent.ConcurrentHashMap<String,Double>();
    }
  }
;
  final Counter<String> totalWords=new Counter<String>(factory);
  sentenceIter.reset();
  final AtomicLong changed=new AtomicLong(System.currentTimeMillis());
  ActorRef sentenceActor=trainingSystem.actorOf(new RoundRobinPool(Runtime.getRuntime().availableProcessors()).props(Props.create(new SentenceActor.SentenceActorCreator(this))));
  if (syn0.rows != this.vocab.size())   throw new IllegalStateException("We appear to be missing vectors here. Unable to train. Please ensure vectors were loaded properly.");
  while (sentenceIter.hasNext()) {
    final String sentence=sentenceIter.nextSentence();
    sentenceActor.tell(new SentenceMessage(totalWords,sentence,changed),sentenceActor);
  }
  boolean done=false;
  long fiveMinutes=TimeUnit.MINUTES.toMillis(5);
  while (!done) {
    long curr=System.currentTimeMillis();
    long lastChanged=changed.get();
    long diff=Math.abs(curr - lastChanged);
    if (diff >= fiveMinutes) {
      done=true;
    }
 else     try {
      Thread.sleep(15000);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
  log.info("Shutting down system; done training");
  if (trainingSystem != null)   trainingSystem.shutdown();
}
