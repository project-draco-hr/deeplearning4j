{
  if (resetCounters && buildHuffmanTree)   throw new IllegalStateException("You can't reset counters and build Huffman tree at the same time!");
  if (cache == null)   cache=new AbstractCache.Builder<T>().build();
  VocabularyHolder topHolder=new VocabularyHolder.Builder().externalCache(cache).minWordFrequency(0).build();
  for (  VocabSource source : sources) {
    SequenceIterator<T> iterator=source.getIterator();
    iterator.reset();
    AbstractCache<T> tempHolder=new AbstractCache.Builder<T>().build();
    while (iterator.hasMoreSequences()) {
      Sequence<T> document=iterator.nextSequence();
      if (fetchLabels) {
        VocabularyWord word=new VocabularyWord(document.getSequenceLabel().getLabel());
        word.setSpecial(true);
        word.setCount(1);
        tempHolder.addToken();
      }
      List<String> tokens=document.asLabels();
      for (      String token : tokens) {
        if (stopWords != null && stopWords.contains(token))         continue;
        if (token == null || token.isEmpty())         continue;
        if (!tempHolder.containsWord(token)) {
          tempHolder.addToken(document.getElementByLabel(token));
        }
 else {
          tempHolder.incrementWordCount(token);
        }
      }
    }
    log.info("Vocab size before truncation: " + tempHolder.numWords());
    tempHolder.truncateVocabulary();
    log.info("Vocab size after truncation: " + tempHolder.numWords());
    topHolder.consumeVocabulary(tempHolder);
  }
  if (resetCounters)   topHolder.resetWordCounters();
  if (buildHuffmanTree)   topHolder.updateHuffmanCodes();
  topHolder.transferBackToVocabCache(cache);
  return cache;
}
