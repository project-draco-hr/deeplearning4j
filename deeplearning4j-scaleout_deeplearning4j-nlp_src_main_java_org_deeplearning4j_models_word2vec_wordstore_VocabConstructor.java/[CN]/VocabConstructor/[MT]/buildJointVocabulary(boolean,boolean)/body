{
  if (resetCounters && buildHuffmanTree)   throw new IllegalStateException("You can't reset counters and build Huffman tree at the same time!");
  if (cache == null)   throw new IllegalStateException("Cache is null, building fresh one");
  if (cache == null)   cache=new AbstractCache.Builder<T>().build();
  log.info("Target vocab size before building: [" + cache.numWords() + "]");
  AbstractCache<T> topHolder=new AbstractCache.Builder<T>().minElementFrequency(0).build();
  int cnt=0;
  for (  VocabSource<T> source : sources) {
    SequenceIterator<T> iterator=source.getIterator();
    iterator.reset();
    log.info("Trying source iterator: [" + cnt + "]");
    log.info("Target vocab size before building: [" + cache.numWords() + "]");
    cnt++;
    AbstractCache<T> tempHolder=new AbstractCache.Builder<T>().build();
    int sequences=0;
    long counter=0;
    while (iterator.hasMoreSequences()) {
      Sequence<T> document=iterator.nextSequence();
      if (fetchLabels) {
        T labelWord=createInstance();
        labelWord.setSpecial(true);
        labelWord.setElementFrequency(1);
        tempHolder.addToken(labelWord);
      }
      List<String> tokens=document.asLabels();
      for (      String token : tokens) {
        if (stopWords != null && stopWords.contains(token))         continue;
        if (token == null || token.isEmpty())         continue;
        if (!tempHolder.containsWord(token)) {
          tempHolder.addToken(document.getElementByLabel(token));
          counter++;
        }
 else {
          counter++;
          tempHolder.incrementWordCount(token);
        }
      }
      sequences++;
    }
    log.debug("Vocab size before truncation: [" + tempHolder.numWords() + "],  NumWords: ["+ tempHolder.totalWordOccurrences()+ "], sequences parsed: ["+ sequences+ "], counter: ["+ counter+ "]");
    if (source.getMinWordFrequency() > 0) {
      LinkedBlockingQueue<String> labelsToRemove=new LinkedBlockingQueue<>();
      for (      T element : tempHolder.vocabWords()) {
        if (element.getElementFrequency() < source.getMinWordFrequency())         labelsToRemove.add(element.getLabel());
      }
      for (      String label : labelsToRemove) {
        log.debug("Removing label: '" + label + "'");
        tempHolder.removeElement(label);
      }
    }
    log.debug("Vocab size after truncation: [" + tempHolder.numWords() + "],  NumWords: ["+ tempHolder.totalWordOccurrences()+ "], sequences parsed: ["+ sequences+ "], counter: ["+ counter+ "]");
    topHolder.importVocabulary(tempHolder);
    log.debug("Top holder size: [" + topHolder.numWords() + "]");
    log.debug("Target vocab size before building: [" + cache.numWords() + "]");
  }
  log.info("Joint vocabulary size BEFORE: [" + cache.numWords() + "]");
  log.info("Top holder size: [" + topHolder.numWords() + "]");
  cache.importVocabulary(topHolder);
  log.info("Joint vocabulary size: [" + cache.numWords() + "]");
  for (  T element : cache.vocabWords()) {
  }
  if (resetCounters) {
    for (    T element : cache.vocabWords()) {
      element.setElementFrequency(0);
    }
    cache.updateWordsOccurencies();
  }
  if (buildHuffmanTree) {
    Huffman huffman=new Huffman(cache.vocabWords());
    huffman.build();
    huffman.applyIndexes(cache);
  }
  return cache;
}
