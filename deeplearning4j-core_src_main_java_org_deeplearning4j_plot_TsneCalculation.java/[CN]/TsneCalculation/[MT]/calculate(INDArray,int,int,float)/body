{
  if (usePca)   X=pca(X,initialDims);
  if (nDims > X.shape().length)   nDims=X.shape().length;
  if (normalize) {
    X=X.sub(X.min(Integer.MAX_VALUE));
    X=X.divi(X.max(Integer.MAX_VALUE));
    X=X.subiRowVector(X.mean(0));
  }
  INDArray sumX=Transforms.pow(X,2).sum(1);
  INDArray D=X.mmul(X.transpose()).muli(-2).addiColumnVector(sumX.transpose()).addiRowVector(sumX);
  INDArray y=Nd4j.randn(X.rows(),nDims).muli(1e-3f);
  INDArray yIncs=Nd4j.create(y.shape());
  INDArray gains=Nd4j.ones(y.shape());
  INDArray p=d2p(D,perplexity,tolerance);
  Nd4j.doAlongDiagonal(p,new Function<Number,Number>(){
    @Override public Number apply(    Number input){
      return 0;
    }
  }
);
  p=p.add(p.transpose()).muli(0.5f);
  p=Transforms.max(p.diviRowVector(p.sum(0).addi(1e-6f)),realMin);
  float constant=Nd4j.getBlasWrapper().dot(p,Transforms.log(p));
  p.muli(4);
  float epsilon=500;
  float costCheck=Float.NEGATIVE_INFINITY;
  for (int i=0; i < maxIter; i++) {
    INDArray sumY=Transforms.pow(y,2).sum(1);
    INDArray num=y.mmul(y.transpose()).muli(-2).addiColumnVector(sumY.transpose()).addiRowVector(sumY).addi(1).rdivi(1);
    Nd4j.doAlongDiagonal(num,new Function<Number,Number>(){
      @Override public Number apply(      Number input){
        return 0;
      }
    }
);
    INDArray q=Transforms.max(num.diviRowVector(num.sum(0).addi(1e-6f)),realMin);
    INDArray L=p.sub(q).muli(num);
    INDArray yGrads=Nd4j.diag(L.sum(0)).subi(L).mmul(y);
    if (i < stopLyingIteration)     yGrads.muli(4);
    gains=gains.add(.2f).muli(sign(yGrads).eps(sign(yIncs))).addi(gains.mul(momentum)).muli(sign(yGrads).eq(sign(yIncs)));
    BooleanIndexing.applyWhere(gains,new Condition(){
      @Override public Boolean apply(      Number input){
        return input.floatValue() < minGain;
      }
      @Override public Boolean apply(      IComplexNumber input){
        return input.absoluteValue().floatValue() < minGain;
      }
    }
,new Function<Number,Number>(){
      @Override public Number apply(      Number input){
        return minGain;
      }
    }
);
    yIncs=yIncs.mul(momentum).sub(epsilon).mul(gains.mul(yGrads));
    y.addi(yIncs);
    y.subiRowVector(y.mean(0));
    if (i == switchMomentumIteration)     momentum=finalMomentum;
    if (i % 10 == 0) {
      float cost=constant - Nd4j.getBlasWrapper().dot(p,Transforms.log(q));
      if (!Float.isInfinite(costCheck)) {
        float diff=Math.abs(costCheck - cost);
        if (diff < 1e-6)         break;
      }
 else       costCheck=cost;
      log.info("Cost " + cost + " at iteration "+ i);
    }
    if (i == stopLyingIteration)     p.divi(4);
  }
  return y;
}
