{
  if (solution.size() >= k)   return solution;
  Counter<T> counter=new Counter<>();
  if (left == null) {
    List<T> result=new ArrayList<>();
    for (    T p : points) {
      result.add(p);
      counter.incrementCount(p,p.distance(point));
    }
    counter.keepBottomNKeys(k);
    List<T> keys=counter.getSortedKeys();
    Collections.reverse(keys);
    result.addAll(keys);
    solution.addAll(result);
  }
  double distanceToLeftCenter=vantagePoint.distance(point);
  if (distanceToLeftCenter < leftRadius) {
    solution.addAll(left.findNearbyPoints(point,k));
  }
 else   if (distanceToLeftCenter >= leftRadius) {
    solution.addAll(right.findNearbyPoints(point,k));
  }
 else {
    List<T> result=right.findNearbyPoints(point,k);
    result.addAll(left.findNearbyPoints(point,k));
    solution.addAll(result);
  }
  Counter<T> c=new Counter<>();
  for (  T t : solution) {
    c.incrementCount(t,point.distance(t));
  }
  c.keepBottomNKeys(k);
  solution.clear();
  List<T> keys=c.getSortedKeys();
  Collections.reverse(keys);
  solution.addAll(keys);
  solution=solution.subList(0,k);
  return solution;
}
