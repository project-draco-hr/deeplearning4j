{
  if (getMemoryFootprint() < getMemoryThreshold() && !isFinished.get())   return;
  int numberOfLinesSaved=0;
  isInvoked.set(true);
  logger.info("invokeBlocking() started.");
  counter.tick();
  CountMap<T> localMap;
  try {
    lock.writeLock().lock();
    localMap=coOccurrenceCounts;
    coOccurrenceCounts=new CountMap<T>();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
 finally {
    lock.writeLock().unlock();
  }
  try {
    Configuration configuration=null;
    File file=null;
    if (!isFinished.get()) {
      file=tempFiles[counter.previous()];
    }
 else     file=targetFile;
    PrintWriter pw=new PrintWriter(file);
    InputSplit split=new FileSplit(tempFiles[counter.get()]);
    CSVRecordReader reader=new CSVRecordReader(0," ");
    reader.initialize(split);
    int linesRead=0;
    while (reader.hasNext()) {
      List<Writable> list=new ArrayList<>(reader.next());
      T element1=vocabCache.wordFor(vocabCache.wordAtIndex(list.get(0).toInt()));
      T element2=vocabCache.wordFor(vocabCache.wordAtIndex(list.get(1).toInt()));
      double sWeight=list.get(2).toDouble();
      double mWeight=localMap.getCount(element1,element2);
      if (mWeight <= 0) {
      }
 else {
        sWeight+=mWeight;
        localMap.removePair(element1,element2);
      }
      StringBuilder builder=new StringBuilder().append(element1.getIndex()).append(" ").append(element2.getIndex()).append(" ").append(sWeight);
      pw.println(builder.toString());
      numberOfLinesSaved++;
      linesRead++;
    }
    logger.info("Lines read: [" + linesRead + "]");
    Iterator<Pair<T,T>> iterator=localMap.getPairIterator();
    while (iterator.hasNext()) {
      Pair<T,T> pair=iterator.next();
      double mWeight=localMap.getCount(pair);
      StringBuilder builder=new StringBuilder().append(pair.getFirst().getIndex()).append(" ").append(pair.getFirst().getIndex()).append(" ").append(mWeight);
      pw.println(builder.toString());
      numberOfLinesSaved++;
    }
    pw.flush();
    pw.close();
    localMap=null;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  logger.info("invokeBlocking() finished. Number of lines saved: [" + numberOfLinesSaved + "]");
  isInvoked.set(false);
}
