{
  while (iterator.hasMoreSequences()) {
    Sequence<T> sequence=iterator.nextSequence();
    List<String> tokens=new ArrayList<>(vocabCache.words());
    for (int x=0; x < sequence.getElements().size(); x++) {
      int wordIdx=vocabCache.indexOf(tokens.get(x));
      if (wordIdx < 0)       continue;
      String w1=vocabCache.wordFor(tokens.get(i)).getLabel();
      if (w1.equals(Glove.UNK))       continue;
      int windowStop=Math.min(x + windowSize + 1,tokens.size());
      for (int j=x; j < windowStop; j++) {
        int otherWord=tokens.indexOf(tokens.get(j));
        if (otherWord < 0)         continue;
        String w2=vocabCache.wordFor(tokens.get(j)).getLabel();
        if (w2.equals(Glove.UNK) || otherWord == wordIdx)         continue;
        if (wordIdx < otherWord) {
          coOCurreneCounts.incrementCount(tokens.get(x),tokens.get(j),1.0 / (j - i + Nd4j.EPS_THRESHOLD));
          occurrenceAllocations.incrementCount(work.getId(),1.0);
          if (symmetric) {
            coOCurreneCounts.incrementCount(tokens.get(j),tokens.get(i),1.0 / (j - i + Nd4j.EPS_THRESHOLD));
            occurrenceAllocations.incrementCount(work.getId(),1.0);
          }
        }
 else {
          coOCurreneCounts.incrementCount(tokens.get(j),tokens.get(i),1.0 / (j - i + Nd4j.EPS_THRESHOLD));
          occurrenceAllocations.incrementCount(work.getId(),1.0);
          if (symmetric) {
            coOCurreneCounts.incrementCount(tokens.get(i),tokens.get(j),1.0 / (j - i + Nd4j.EPS_THRESHOLD));
            occurrenceAllocations.incrementCount(work.getId(),1.0);
          }
        }
      }
    }
    processed.incrementAndGet();
  }
}
