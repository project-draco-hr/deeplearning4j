{
  if (inputTypes == null || inputTypes.length != networkInputs.size()) {
    throw new IllegalArgumentException("Invalid number of InputTypes: cannot add preprocessors if number of InputType " + "objects differs from number of network inputs");
  }
  Map<String,List<String>> verticesOutputTo=new HashMap<>();
  for (  Map.Entry<String,GraphVertex> entry : vertices.entrySet()) {
    String vertexName=entry.getKey();
    List<String> vertexInputNames;
    vertexInputNames=vertexInputs.get(vertexName);
    if (vertexInputNames == null)     continue;
    for (    String s : vertexInputNames) {
      List<String> list=verticesOutputTo.get(s);
      if (list == null) {
        list=new ArrayList<>();
        verticesOutputTo.put(s,list);
      }
      list.add(vertexName);
    }
  }
  LinkedList<String> noIncomingEdges=new LinkedList<>(networkInputs);
  List<String> topologicalOrdering=new ArrayList<>();
  Map<String,Set<String>> inputEdges=new HashMap<>();
  for (  Map.Entry<String,List<String>> entry : vertexInputs.entrySet()) {
    inputEdges.put(entry.getKey(),new HashSet<>(entry.getValue()));
  }
  while (!noIncomingEdges.isEmpty()) {
    String next=noIncomingEdges.removeFirst();
    topologicalOrdering.add(next);
    List<String> nextEdges=verticesOutputTo.get(next);
    if (nextEdges != null && !nextEdges.isEmpty()) {
      for (      String s : nextEdges) {
        Set<String> set=inputEdges.get(s);
        set.remove(next);
        if (set.isEmpty()) {
          noIncomingEdges.add(s);
        }
      }
    }
  }
  for (  Map.Entry<String,Set<String>> entry : inputEdges.entrySet()) {
    Set<String> set=entry.getValue();
    if (set == null)     continue;
    if (!set.isEmpty())     throw new IllegalStateException("Invalid configuration: cycle detected in graph. Cannot calculate topological ordering with graph cycle (" + "cycle includes vertex \"" + entry.getKey() + "\")");
  }
  Map<String,InputType> vertexOutputs=new HashMap<>();
  for (  String s : topologicalOrdering) {
    int inputIdx=networkInputs.indexOf(s);
    if (inputIdx != -1) {
      vertexOutputs.put(s,inputTypes[inputIdx]);
      continue;
    }
    GraphVertex gv=vertices.get(s);
    List<InputType> inputTypeList=new ArrayList<>();
    if (gv instanceof LayerVertex) {
      String in=vertexInputs.get(s).get(0);
      InputType layerInput=vertexOutputs.get(in);
      LayerVertex lv=(LayerVertex)gv;
      if (lv.getPreProcessor() != null)       continue;
      Layer l=lv.getLayerConf().getLayer();
      if (l instanceof ConvolutionLayer || l instanceof SubsamplingLayer) {
switch (layerInput.getType()) {
case FF:
          log.warn("Automatic addition of FF -> CNN preprocessors: not yet implemented (layer: " + s + ")");
        break;
case RNN:
      log.warn("Automatic addition of RNN -> CNN preprocessors: not yet implemented (layer: " + s + ")");
    break;
case CNN:
  InputType.InputTypeConvolutional conv=(InputType.InputTypeConvolutional)layerInput;
if (l instanceof ConvolutionLayer) {
  ConvolutionLayer cl=(ConvolutionLayer)l;
  if (cl.getNIn() == 0) {
    cl.setNIn(conv.getDepth());
  }
}
break;
}
}
 else if (l instanceof BaseRecurrentLayer || l instanceof RnnOutputLayer) {
switch (layerInput.getType()) {
case FF:
lv.setPreProcessor(new FeedForwardToRnnPreProcessor());
setNInIfNecessary(lv,layerInput);
break;
case RNN:
setNInIfNecessary(lv,layerInput);
break;
case CNN:
InputType.InputTypeConvolutional conv=(InputType.InputTypeConvolutional)layerInput;
lv.setPreProcessor(new CnnToRnnPreProcessor(conv.getHeight(),conv.getWidth(),conv.getDepth()));
int nIn=conv.getHeight() * conv.getWidth() * conv.getDepth();
((FeedForwardLayer)lv.getLayerConf().getLayer()).setNIn(nIn);
break;
}
}
 else if (l instanceof FeedForwardLayer) {
switch (layerInput.getType()) {
case FF:
setNInIfNecessary(lv,layerInput);
break;
case RNN:
lv.setPreProcessor(new RnnToFeedForwardPreProcessor());
setNInIfNecessary(lv,layerInput);
break;
case CNN:
InputType.InputTypeConvolutional conv=(InputType.InputTypeConvolutional)layerInput;
lv.setPreProcessor(new CnnToFeedForwardPreProcessor(conv.getHeight(),conv.getWidth(),conv.getDepth()));
int nIn=conv.getHeight() * conv.getWidth() * conv.getDepth();
((FeedForwardLayer)lv.getLayerConf().getLayer()).setNIn(nIn);
break;
}
}
inputTypeList.add(layerInput);
}
 else {
List<String> inputs=vertexInputs.get(s);
if (inputs != null) {
for (String inputVertexName : inputs) {
inputTypeList.add(vertexOutputs.get(inputVertexName));
}
}
}
InputType outputFromVertex=gv.getOutputType(inputTypeList.toArray(new InputType[inputTypeList.size()]));
vertexOutputs.put(s,outputFromVertex);
}
}
