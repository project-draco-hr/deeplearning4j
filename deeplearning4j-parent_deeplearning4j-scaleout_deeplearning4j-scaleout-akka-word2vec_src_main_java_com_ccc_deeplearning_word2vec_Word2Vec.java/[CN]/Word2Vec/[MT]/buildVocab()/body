{
  readStopWords();
  if (trainingSystem == null)   trainingSystem=ActorSystem.create();
  @SuppressWarnings("unused") final AtomicInteger count=new AtomicInteger(0);
  final AtomicBoolean bool=new AtomicBoolean(false);
  MapFactory<String,Double> factory=new MapFactory<String,Double>(){
    private static final long serialVersionUID=5447027920163740307L;
    @Override public Map<String,Double> buildMap(){
      return new java.util.concurrent.ConcurrentHashMap<String,Double>();
    }
  }
;
  final Counter<String> rawVocab=new Counter<String>(factory);
  final int capacity=Runtime.getRuntime().availableProcessors() * 4;
  final java.util.concurrent.ArrayBlockingQueue<String> work=new java.util.concurrent.ArrayBlockingQueue<>(capacity);
  final AtomicInteger workersSpawned=new AtomicInteger(0);
  Future<Void> f1=Futures.future(new Callable<Void>(){
    @Override public Void call() throws Exception {
      while (sentenceIter.hasNext()) {
        if (work.remainingCapacity() == 0) {
          Word2Vec.this.process(bool,work,count,rawVocab);
          workersSpawned.incrementAndGet();
        }
 else {
          if (workersSpawned.get() < capacity)           Word2Vec.this.process(bool,work,count,rawVocab);
          work.add(sentenceIter.nextSentence());
        }
      }
      return null;
    }
  }
,trainingSystem.dispatcher());
  while (!bool.get()) {
    try {
      Thread.sleep(15000);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
  setup();
}
