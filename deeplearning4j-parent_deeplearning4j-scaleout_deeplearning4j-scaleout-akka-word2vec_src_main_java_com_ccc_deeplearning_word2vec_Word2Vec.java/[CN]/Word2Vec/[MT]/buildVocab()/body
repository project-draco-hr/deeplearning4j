{
  readStopWords();
  if (trainingSystem == null)   trainingSystem=ActorSystem.create();
  final AtomicBoolean bool=new AtomicBoolean(false);
  MapFactory<String,Double> factory=new MapFactory<String,Double>(){
    private static final long serialVersionUID=5447027920163740307L;
    @Override public Map<String,Double> buildMap(){
      return new java.util.concurrent.ConcurrentHashMap<String,Double>();
    }
  }
;
  final Counter<String> rawVocab=new Counter<String>(factory);
  Set<Future<Void>> futures=new HashSet<>();
  while (sentenceIter.hasNext()) {
    Future<Void> f=process(bool,sentenceIter.nextSentence(),rawVocab);
    futures.add(f);
    Future<Iterable<Void>> wait=Futures.sequence(futures,trainingSystem.dispatcher());
    try {
      Await.result(wait,Duration.Inf());
    }
 catch (    Exception e) {
      Thread.currentThread().interrupt();
    }
    futures.clear();
  }
  while (!bool.get()) {
    try {
      Thread.sleep(15000);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
  setup();
}
