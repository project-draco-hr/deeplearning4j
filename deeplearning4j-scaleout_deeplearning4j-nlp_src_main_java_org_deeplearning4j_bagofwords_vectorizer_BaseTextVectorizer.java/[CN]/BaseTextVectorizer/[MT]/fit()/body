{
  if (trainingSystem == null)   trainingSystem=ActorSystem.create();
  final AtomicLong semaphore=new AtomicLong(System.currentTimeMillis());
  final AtomicInteger queued=new AtomicInteger(0);
  final ActorRef vocabActor=trainingSystem.actorOf(new RoundRobinPool(Runtime.getRuntime().availableProcessors()).props(Props.create(VocabActor.class,tokenizerFactory,cache,stopWords,semaphore,minWordFrequency,numWordsEncountered,index)));
  final AtomicInteger latch=new AtomicInteger(0);
  while (docIter != null && docIter.hasNext()) {
    vocabActor.tell(new StreamWork(new DefaultInputStreamCreator(docIter),latch),vocabActor);
    queued.incrementAndGet();
    if (queued.get() % 10000 == 0) {
      log.info("Sent " + queued);
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        ;
      }
    }
  }
  while (getSentenceIterator() != null && getSentenceIterator().hasNext()) {
    String sentence=getSentenceIterator().nextSentence();
    if (sentence == null)     break;
    vocabActor.tell(new VocabWork(latch,sentence,stem),vocabActor);
    queued.incrementAndGet();
    if (queued.get() % 10000 == 0) {
      log.info("Sent " + queued);
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        ;
      }
    }
  }
  while (latch.get() < queued.get()) {
    try {
      Thread.sleep(10000);
      log.info("latch count " + latch.get() + " with queued "+ queued.get());
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
  log.info("Invoking finish on index");
  index.finish();
  trainingSystem.shutdown();
}
