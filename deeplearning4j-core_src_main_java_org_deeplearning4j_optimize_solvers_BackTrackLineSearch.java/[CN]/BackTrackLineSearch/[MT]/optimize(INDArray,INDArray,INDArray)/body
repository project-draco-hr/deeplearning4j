{
  double test, stepMin, step, step2, oldStep, tmpStep;
  double rhs1, rhs2, a, b, disc, score, oldScore, score2;
  double sum=searchDirection.norm2(Integer.MAX_VALUE).getDouble(0);
  double slope=Nd4j.getBlasWrapper().dot(searchDirection,gradients);
  logger.debug("slope = {}",slope);
  INDArray maxOldParams=abs(parameters);
  Nd4j.getExecutioner().exec(new ScalarSetValue(maxOldParams,1));
  INDArray testMatrix=abs(gradients).divi(maxOldParams);
  test=testMatrix.max(Integer.MAX_VALUE).getDouble(0);
  step=1.0;
  stepMin=relTolx / test;
  oldStep=0.0;
  step2=0.0;
  score2=oldScore=layer.score();
  if (logger.isTraceEnabled()) {
    logger.trace("ENTERING BACKTRACK\n");
    logger.trace("Entering BackTrackLinnSearch, value = " + oldScore + ",\ndirection.oneNorm:"+ searchDirection.dup().norm1(Integer.MAX_VALUE)+ "  direction.infNorm:"+ FastMath.max(Float.NEGATIVE_INFINITY,abs(searchDirection.dup()).max(Integer.MAX_VALUE).getDouble(0)));
  }
  if (sum > stepMax) {
    logger.warn("Attempted step too big. scaling: sum= {}, stepMax= {}",sum,stepMax);
    searchDirection.muli(stepMax / sum);
  }
  if (slope <= 0.0)   throw new InvalidStepException("Slope " + slope + " is <= 0.0. Expect slope > 0.0");
  INDArray candidateParameters=null;
  for (int iteration=0; iteration < maxIterations; iteration++) {
    if (logger.isTraceEnabled()) {
      logger.trace("BackTrack loop iteration {} : step={}, oldStep={}",iteration,step,oldStep);
      logger.trace("before step, x.1norm: {} \nstep: {} \noldStep: {}",parameters.norm1(Integer.MAX_VALUE),step,oldStep);
    }
    if (step == oldStep)     throw new IllegalArgumentException("Current step == oldStep");
    if (candidateParameters == null)     candidateParameters=parameters.dup();
 else     candidateParameters.assign(parameters);
    stepFunction.step(candidateParameters,searchDirection,step);
    oldStep=step;
    if (logger.isDebugEnabled()) {
      double norm1=candidateParameters.norm1(Integer.MAX_VALUE).getDouble(0);
      logger.debug("after step, x.1norm: " + norm1);
    }
    if ((step < stepMin) || Nd4j.getExecutioner().execAndReturn(new Eps(parameters,candidateParameters,candidateParameters.dup(),candidateParameters.length())).sum(Integer.MAX_VALUE).getDouble(0) == candidateParameters.length()) {
      score=setScoreFor(parameters);
      logger.trace("EXITING BACKTRACK: Jump too small (stepMin = {}). Exiting and using xold. Value = {}",stepMin,score);
      return 0.0;
    }
    score=setScoreFor(candidateParameters);
    logger.debug("Model score after step = {}",score);
    if (score <= oldScore - ALF * step * slope) {
      logger.debug("Sufficient decrease (Wolfe cond.), exiting backtrack on iter {}: score={}, oldScore={}",iteration,score,oldScore);
      if (score > oldScore)       throw new IllegalStateException("Function did not decrease: score = " + score + " > "+ oldScore+ " = oldScore");
      return step;
    }
 else     if (Double.isInfinite(score) || Double.isInfinite(score2) || Double.isNaN(score)|| Double.isNaN(score2)) {
      logger.warn("Value is infinite after jump. oldStep={}. score={}, score2={}. Scaling back step size...",oldStep,score,score2);
      tmpStep=.2 * step;
      if (step < stepMin || Double.isNaN(score2) || Double.isInfinite(score2)) {
        score=setScoreFor(parameters);
        logger.warn("EXITING BACKTRACK: Jump too small. Exiting and using previous parameters. Value={}",score);
        return 0.0;
      }
    }
 else {
      if (step == 1.0)       tmpStep=slope / (2.0 * (score - oldScore + slope));
 else {
        rhs1=score - oldScore + step * slope;
        rhs2=score2 - oldScore + step2 * slope;
        if (step == step2)         throw new IllegalStateException("FAILURE: dividing by step-step2 which equals 0. step=" + step);
        double stepSquared=step * step;
        double step2Squared=step2 * step2;
        a=(rhs1 / stepSquared - rhs2 / step2Squared) / (step - step2);
        b=(-step2 * rhs1 / stepSquared + step * rhs2 / step2Squared) / (step - step2);
        if (a == 0.0)         tmpStep=slope / (2.0 * b);
 else {
          disc=b * b + 3.0 * a * slope;
          if (disc < 0.0) {
            tmpStep=0.5 * step;
          }
 else           if (b <= 0.0)           tmpStep=(-b + FastMath.sqrt(disc)) / (3.0 * a);
 else           tmpStep=slope / (b + FastMath.sqrt(disc));
        }
        if (tmpStep > 0.5 * step)         tmpStep=0.5 * step;
      }
    }
    step2=step;
    score2=score;
    logger.debug("tmpStep: {}",tmpStep);
    step=Math.max(tmpStep,.1f * step);
  }
  logger.debug("Exited line search after maxIterations termination condition");
  return 0.0;
}
