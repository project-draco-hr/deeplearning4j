{
  LinAlgExceptions.assertRows(input,labels);
  INDArray z=output(input);
  float ret=0;
  double reg=0.5 * l2;
switch (lossFunction) {
case MCXENT:
    INDArray mcXEntLogZ=log(z);
  ret=-(float)labels.mul(mcXEntLogZ).sum(1).sum(Integer.MAX_VALUE).element() / labels.rows();
break;
case XENT:
INDArray xEntLogZ=log(z);
INDArray xEntOneMinusLabelsOut=labels.rsub(1);
INDArray xEntOneMinusLogOneMinusZ=log(z).rsub(1);
ret=-(float)labels.mul(xEntLogZ).add(xEntOneMinusLabelsOut).mul(xEntOneMinusLogOneMinusZ).sum(1).sum(Integer.MAX_VALUE).element() / labels.rows();
break;
case RMSE_XENT:
ret=(float)pow(labels.sub(z),2).sum(1).sum(Integer.MAX_VALUE).element() / labels.rows();
break;
case MSE:
INDArray mseDelta=labels.sub(z);
ret=0.5f * (float)(pow(mseDelta,2).sum(1).sum(Integer.MAX_VALUE)).element() / labels.rows();
break;
case EXPLL:
INDArray expLLLogZ=log(z);
ret=-(float)z.sub(labels.mul(expLLLogZ)).sum(1).sum(Integer.MAX_VALUE).element() / labels.rows();
break;
case SQUARED_LOSS:
ret=(float)pow(labels.sub(z),2).sum(1).sum(Integer.MAX_VALUE).element() / labels.rows();
}
if (useRegularization && l2 > 0) ret+=reg;
return ret;
}
