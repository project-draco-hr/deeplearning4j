{
  int split=this.workers.size();
  final List<List<DataSet>> splitList=Lists.partition(datasets,split);
  partition=splitList.size();
  log.info("Found partition of size " + partition);
  for (int i=0; i < splitList.size(); i++) {
    final int j=i;
    Future<Void> f=Futures.future(new Callable<Void>(){
      @Override public Void call() throws Exception {
        log.info("Sending off work for batch " + j);
        boolean foundWork=false;
        while (!foundWork) {
          for (          WorkerState state : workers.values()) {
            if (state.isAvailable()) {
              state.getRef().tell(new ArrayList<>(splitList.get(j)),getSelf());
              mediator.tell(new DistributedPubSubMediator.Publish(state.getWorkerId(),new ArrayList<>(splitList.get(j))),getSelf());
              log.info("Delegated work to worker " + state.getWorkerId());
              state.setAvailable(false);
              foundWork=true;
              break;
            }
          }
        }
        return null;
      }
    }
,context().dispatcher());
    f.onComplete(new OnComplete<Void>(){
      @Override public void onComplete(      Throwable arg0,      Void arg1) throws Throwable {
        if (arg0 != null)         throw arg0;
      }
    }
,context().dispatcher());
  }
}
