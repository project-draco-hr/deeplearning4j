{
  int split=conf.getSplit();
  final List<List<DataSet>> splitList=Lists.partition(pairs,split);
  partition=splitList.size();
  log.info("Found partition of size " + partition);
  for (int i=0; i < splitList.size(); i++) {
    final int j=i;
    Future<Void> f=Futures.future(new Callable<Void>(){
      @Override public Void call() throws Exception {
        log.info("Sending off work for batch " + j);
        for (        WorkerState state : workers.values()) {
          if (state.isAvailable()) {
            state.getRef().tell(new ArrayList<>(splitList.get(j)),getSelf());
            log.info("Delegated work to worker " + state.getWorkerId());
            state.setAvailable(false);
            break;
          }
        }
        return null;
      }
    }
,context().dispatcher());
    f.onComplete(new OnComplete<Void>(){
      @Override public void onComplete(      Throwable arg0,      Void arg1) throws Throwable {
        if (arg0 != null)         throw arg0;
      }
    }
,context().dispatcher());
  }
}
