{
  double lr=1e-2;
  double mu=0.6;
  Map<Integer,Double> momentumAfter=new HashMap<>();
  momentumAfter.put(1,0.2);
  int iterations=2;
  Map<String,INDArray> v=new HashMap<>();
  INDArray vPrev;
  NeuralNetConfiguration conf=new NeuralNetConfiguration.Builder().learningRate(lr).momentum(mu).momentumAfter(momentumAfter).iterations(iterations).layer(new DenseLayer.Builder().nIn(nIn).nOut(nOut).updater(org.deeplearning4j.nn.conf.Updater.NESTEROVS).build()).build();
  Layer layer=LayerFactories.getFactory(conf).create(conf,null,0);
  Updater updater=UpdaterCreator.getUpdater(layer);
  Gradient gradientDup=new DefaultGradient();
  gradientDup.setGradientFor(DefaultParamInitializer.WEIGHT_KEY,weightGradient);
  gradientDup.setGradientFor(DefaultParamInitializer.BIAS_KEY,biasGradient);
  for (int i=0; i < 2; i++) {
    updater.update(layer,gradient,i);
    for (    Map.Entry<String,INDArray> entry : gradientDup.gradientForVariable().entrySet()) {
      if (momentumAfter != null)       mu=(momentumAfter.containsKey(i)) ? momentumAfter.get(i) : mu;
      key=entry.getKey();
      val=entry.getValue();
      INDArray vTmp=v.get(key);
      if (vTmp == null)       vTmp=Nd4j.zeros(val.shape());
      vPrev=vTmp;
      vTmp=vPrev.mul(mu).subi(val.mul(lr));
      gradExpected=vPrev.muli(mu).addi(vTmp.mul(-mu - 1));
      gradientDup.setGradientFor(key,gradExpected);
      assertEquals(gradExpected,gradient.getGradientFor(entry.getKey()));
      v.put(key,vTmp);
    }
    assertEquals(momentumAfter,layer.conf().getLayer().getMomentumAfter());
  }
}
