{
  MatrixUtil.ensureValidOutcomeMatrix(labels);
  network.feedForward(network.getInput());
  DoubleMatrix layerInput=network.getSigmoidLayers()[network.getSigmoidLayers().length - 1].sample_h_given_v();
  network.getLogLayer().setInput(layerInput);
  network.getLogLayer().setLabels(labels);
  if (layerInput.rows != labels.rows) {
    throw new IllegalStateException("Labels not equal to input");
  }
  if (!network.isForceNumEpochs()) {
    LogisticRegressionOptimizer opt=new LogisticRegressionOptimizer(network.getLogLayer(),lr);
    NonZeroStoppingConjugateGradient g=new NonZeroStoppingConjugateGradient(opt);
    g.optimize(epochs);
  }
 else {
    log.info("Training for " + epochs + " epochs");
    for (int i=0; i < epochs; i++) {
      network.getLogLayer().train(layerInput,labels,lr);
    }
  }
  if (network.isShouldBackProp())   network.backProp(lr,epochs);
}
