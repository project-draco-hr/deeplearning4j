{
  double corruptionLevel=(double)params[0];
  double lr=(double)params[1];
  DoubleMatrix corruptedX=getCorruptedInput(input,corruptionLevel);
  DoubleMatrix y=getHiddenValues(corruptedX);
  DoubleMatrix z=getReconstructedInput(y);
  DoubleMatrix L_h2=input.sub(z);
  DoubleMatrix L_h1=sparsity == 0 ? L_h2.mmul(W).mul(y).mul(oneMinus(y)) : L_h2.mmul(W).mul(y).mul(y.add(-sparsity));
  DoubleMatrix L_vbias=L_h2;
  DoubleMatrix L_hbias=L_h1;
  DoubleMatrix wGradient=corruptedX.transpose().mmul(L_h1).add(L_h2.transpose().mmul(y));
  if (useAdaGrad)   wGradient.muli(wAdaGrad.getLearningRates(wGradient));
 else   wGradient.muli(lr);
  if (useRegularization)   wGradient.subi(W.muli(l2));
  if (momentum != 0)   wGradient.muli(1 - momentum);
  if (normalizeByInputRows)   wGradient.divi(input.rows);
  DoubleMatrix L_hbias_mean=L_hbias.columnMeans();
  DoubleMatrix L_vbias_mean=L_vbias.columnMeans();
  NeuralNetworkGradient gradient=new NeuralNetworkGradient(wGradient,L_vbias_mean,L_hbias_mean);
  this.triggerGradientEvents(gradient);
  return gradient;
}
