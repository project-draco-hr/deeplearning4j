{
  double ret=0.0;
  double reg=0.5 * l2;
  INDArray z=output.output(input);
switch (lossFunction) {
case MCXENT:
    INDArray mcXEntLogZ=Transforms.log(z);
  ret=-(double)labels.mul(mcXEntLogZ).sum(1).sum(Integer.MAX_VALUE).element() / labels.rows();
break;
case XENT:
INDArray xEntLogZ=Transforms.log(z);
INDArray xEntOneMinusLabelsOut=labels.rsub(1);
INDArray xEntOneMinusLogOneMinusZ=Transforms.log(z).rsubi(1);
ret=-(double)labels.mul(xEntLogZ).add(xEntOneMinusLabelsOut).mul(xEntOneMinusLogOneMinusZ).sum(1).sum(Integer.MAX_VALUE).element() / labels.rows();
break;
case RMSE_XENT:
ret=(double)Transforms.pow(labels.sub(z),2).sum(1).sum(Integer.MAX_VALUE).element() / labels.rows();
break;
case MSE:
INDArray mseDelta=labels.sub(z);
ret=0.5 * (double)Transforms.pow(mseDelta,2).sum(1).sum(Integer.MAX_VALUE).element() / labels.rows();
break;
case EXPLL:
INDArray expLLLogZ=Transforms.log(z);
ret=-(double)z.sub(labels.mul(expLLLogZ)).sum(1).sum(Integer.MAX_VALUE).element() / labels.rows();
break;
case SQUARED_LOSS:
ret=(double)Transforms.pow(labels.sub(z),2).sum(1).sum(Integer.MAX_VALUE).element() / labels.rows();
}
if (useRegularization && l2 > 0) ret+=reg;
return ret;
}
