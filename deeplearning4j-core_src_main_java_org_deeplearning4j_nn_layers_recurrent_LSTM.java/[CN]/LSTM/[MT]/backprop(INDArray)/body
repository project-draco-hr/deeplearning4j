{
  INDArray decoderWeights=getParam(LSTMParamInitializer.INPUT_WEIGHT_KEY);
  INDArray recurrentWeights=getParam(LSTMParamInitializer.RECURRENT_WEIGHT_KEY);
  INDArray dY=Nd4j.vstack(Nd4j.zeros(y.columns()),y);
  INDArray dWd=hOut.transpose().mmul(dY);
  INDArray dBd=Nd4j.sum(dWd,0);
  INDArray dHout=dY.mmul(decoderWeights.transpose());
  if (conf.getLayer().getDropOut() > 0) {
    dHout.muli(u2);
  }
  INDArray dIFog=Nd4j.zeros(iFog.shape());
  INDArray dIFogF=Nd4j.zeros(iFogF.shape());
  INDArray dRecurrentWeights=Nd4j.zeros(recurrentWeights.shape());
  INDArray dHin=Nd4j.zeros(hIn.shape());
  INDArray dC=Nd4j.zeros(c.shape());
  INDArray dx=Nd4j.zeros(x.shape());
  int n=hOut.rows();
  int d=hOut.columns();
  for (int t=n - 1; t > 0; t--) {
    if (conf.getLayer().getActivationFunction().equals("tanh")) {
      INDArray tanhCt=tanh(c.slice(t));
      dIFogF.slice(t).put(new INDArrayIndex[]{interval(2 * d,3 * d)},tanhCt.mul(dHout.slice(t)));
      dC.slice(t).addi(pow(tanhCt,2).rsubi(1).muli(iFogF.slice(t).get(interval(2 * d,3 * d)).mul(dHout.slice(t))));
    }
 else {
      dIFogF.slice(t).put(new INDArrayIndex[]{interval(2 * d,3 * d)},c.slice(t).mul(dHout.slice(t)));
      dC.slice(t).addi(iFogF.slice(t).get(interval(2 * d,3 * d)).mul(dHout.slice(t)));
    }
    if (t > 0) {
      dIFogF.slice(t).put(new INDArrayIndex[]{interval(d,2 * d)},c.slice(t - 1).mul(dC.slice(t)));
      dC.slice(t - 1).addi(iFogF.slice(t).get(interval(d,2 * d)).mul(dC.slice(t)));
    }
    dIFogF.slice(t).put(new INDArrayIndex[]{interval(0,d)},iFogF.slice(t).get(interval(3 * d,iFogF.columns())).mul(dC.slice(t)));
    dIFogF.slice(t).put(new INDArrayIndex[]{interval(3 * d,dIFogF.columns())},iFogF.slice(t).get(interval(0,d)).mul(dC.slice(t)));
    dIFog.slice(t).put(new INDArrayIndex[]{interval(3 * d,dIFog.columns())},pow(iFogF.slice(t).get(interval(3 * d,iFogF.columns())),2).rsubi(1).mul(dIFogF.slice(t).get(interval(3 * d,dIFogF.columns()))));
    y=iFogF.slice(t).get(interval(0,3 * d));
    dIFogF.slice(t).put(new INDArrayIndex[]{interval(0,3 * d)},y.mul(y.rsub(1)).mul(dIFogF.slice(t).get(interval(0,3 * d))));
    dRecurrentWeights.addi(hIn.slice(t).transpose().mmul(dIFog.slice(t)));
    dHin.slice(t).assign(dIFog.slice(t).mmul(recurrentWeights.transpose()));
    INDArray get=dHin.slice(t).get(interval(1,1 + d));
    dx.slice(t).assign(get);
    if (t > 0)     dHout.slice(t - 1).addi(dHin.slice(t).get(interval(1 + d,dHin.columns())));
    if (conf.getLayer().getDropOut() > 0)     dx.muli(u);
  }
  clear();
  Gradient gradient=new DefaultGradient();
  gradient.gradientForVariable().put(LSTMParamInitializer.BIAS_KEY,dBd);
  gradient.gradientForVariable().put(LSTMParamInitializer.INPUT_WEIGHT_KEY,dWd);
  gradient.gradientForVariable().put(LSTMParamInitializer.RECURRENT_WEIGHT_KEY,dRecurrentWeights);
  return gradient;
}
