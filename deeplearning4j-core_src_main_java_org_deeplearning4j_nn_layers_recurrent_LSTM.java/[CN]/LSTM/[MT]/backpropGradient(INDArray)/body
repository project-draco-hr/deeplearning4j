{
  INDArray tanhCt, activations;
  INDArray delta=Nd4j.zeros(epsilon.shape());
  INDArray inputWeights=getParam(LSTMParamInitializer.INPUT_WEIGHT_KEY);
  INDArray recurrentWeights=getParam(LSTMParamInitializer.RECURRENT_WEIGHT_KEY);
  INDArray dHin=Nd4j.zeros(hIn.shape());
  INDArray dX=Nd4j.zeros(input.shape());
  epsilon=Nd4j.vstack(Nd4j.zeros(epsilon.columns()),epsilon);
  if (conf.isUseDropConnect() & conf.getLayer().getDropOut() > 0)   epsilon.muli(u2);
  INDArray dIFogZ=Nd4j.zeros(iFogZ.shape());
  INDArray dIFogA=Nd4j.zeros(iFogA.shape());
  INDArray recurrentWeightGradients=Nd4j.zeros(recurrentWeights.shape());
  INDArray dC=Nd4j.zeros(memCellActivations.shape());
  int sequenceLen=hOut.rows();
  int hiddenLayerSize=hOut.columns();
  for (int t=sequenceLen - 1; t > 0; t--) {
    if (conf.getLayer().getActivationFunction().equals("tanh")) {
      tanhCt=tanh(memCellActivations.slice(t));
      dIFogA.slice(t).put(new INDArrayIndex[]{interval(2 * hiddenLayerSize,3 * hiddenLayerSize)},tanhCt.mul(epsilon.slice(t)));
      dC.slice(t).addi(pow(tanhCt,2).rsubi(1).muli(iFogA.slice(t).get(interval(2 * hiddenLayerSize,3 * hiddenLayerSize)).mul(epsilon.slice(t))));
    }
 else {
      dIFogA.slice(t).put(new INDArrayIndex[]{interval(2 * hiddenLayerSize,3 * hiddenLayerSize)},memCellActivations.slice(t).mul(epsilon.slice(t)));
      dC.slice(t).addi(iFogA.slice(t).get(interval(2 * hiddenLayerSize,3 * hiddenLayerSize)).mul(epsilon.slice(t)));
    }
    if (t > 0) {
      dIFogA.slice(t).put(new INDArrayIndex[]{interval(hiddenLayerSize,2 * hiddenLayerSize)},memCellActivations.slice(t - 1).mul(dC.slice(t)));
      dC.slice(t - 1).addi(iFogA.slice(t).get(interval(hiddenLayerSize,2 * hiddenLayerSize)).mul(dC.slice(t)));
    }
    dIFogA.slice(t).put(new INDArrayIndex[]{interval(0,hiddenLayerSize)},iFogA.slice(t).get(interval(3 * hiddenLayerSize,iFogA.columns())).mul(dC.slice(t)));
    dIFogA.slice(t).put(new INDArrayIndex[]{interval(3 * hiddenLayerSize,dIFogA.columns())},iFogA.slice(t).get(interval(0,hiddenLayerSize)).mul(dC.slice(t)));
    dIFogZ.slice(t).put(new INDArrayIndex[]{interval(3 * hiddenLayerSize,dIFogZ.columns())},pow(iFogA.slice(t).get(interval(3 * hiddenLayerSize,iFogA.columns())),2).rsubi(1).mul(dIFogA.slice(t).get(interval(3 * hiddenLayerSize,dIFogA.columns()))));
    activations=iFogA.slice(t).get(interval(0,3 * hiddenLayerSize));
    dIFogZ.slice(t).put(new INDArrayIndex[]{interval(0,3 * hiddenLayerSize)},activations.mul(activations.rsub(1)).mul(dIFogA.slice(t).get(interval(0,3 * hiddenLayerSize))));
    recurrentWeightGradients.addi(hIn.slice(t).transpose().mmul(dIFogZ.slice(t)));
    dHin.slice(t).assign(dIFogZ.slice(t).mmul(recurrentWeights.transpose()));
    INDArray get=dHin.slice(t).get(interval(1,1 + hiddenLayerSize));
    dX.slice(t).assign(get);
    if (t > 0) {
      INDArray v=epsilon.slice(t);
      INDArray yo=dHin.slice(t).get(interval(1 + hiddenLayerSize,dHin.columns()));
      epsilon.slice(t - 1).addi(dHin.slice(t).get(interval(1 + hiddenLayerSize,dHin.columns())));
    }
    if (conf.isUseDropConnect() & conf.getLayer().getDropOut() > 0)     dX.muli(u);
  }
  INDArray inputWeightGradients=inputWeights.transpose().mul(dX);
  INDArray biasGradients=Nd4j.sum(dX,0);
  Gradient retGradient=new DefaultGradient();
  retGradient.gradientForVariable().put(LSTMParamInitializer.INPUT_WEIGHT_KEY,inputWeightGradients);
  retGradient.gradientForVariable().put(LSTMParamInitializer.RECURRENT_WEIGHT_KEY,recurrentWeightGradients);
  retGradient.gradientForVariable().put(LSTMParamInitializer.BIAS_KEY,biasGradients);
  return new Pair<>(retGradient,inputWeightGradients);
}
