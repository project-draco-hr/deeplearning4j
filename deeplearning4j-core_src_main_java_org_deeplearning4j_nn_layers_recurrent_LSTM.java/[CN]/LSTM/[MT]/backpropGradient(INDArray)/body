{
  INDArray activations=activate(true);
  INDArray inputWeights=getParam(LSTMParamInitializer.INPUT_WEIGHT_KEY);
  INDArray recurrentWeights=getParam(LSTMParamInitializer.RECURRENT_WEIGHT_KEY);
  INDArray dY=Nd4j.vstack(Nd4j.zeros(activations.columns()),activations);
  INDArray inputWeightGradients=outputActivations.transpose().mmul(dY);
  INDArray biasGradients=Nd4j.sum(inputWeightGradients,0);
  INDArray dHout=dY.mmul(inputWeights.transpose());
  if (conf.isUseDropConnect() & conf.getDropOut() > 0)   dHout.muli(u2);
  INDArray dIFogZ=Nd4j.zeros(iFogZ.shape());
  INDArray dIFogA=Nd4j.zeros(iFogA.shape());
  INDArray recurrentWeightGradients=Nd4j.zeros(recurrentWeights.shape());
  INDArray dHin=Nd4j.zeros(hIn.shape());
  INDArray dC=Nd4j.zeros(memCellActivations.shape());
  INDArray dX=Nd4j.zeros(input.shape());
  int sequenceLen=outputActivations.rows();
  int hiddenLayerSize=outputActivations.columns();
  for (int t=sequenceLen - 1; t > 0; t--) {
    if (conf.getActivationFunction().equals("tanh")) {
      INDArray tanhCt=tanh(memCellActivations.slice(t));
      dIFogA.slice(t).put(new INDArrayIndex[]{interval(2 * hiddenLayerSize,3 * hiddenLayerSize)},tanhCt.mul(dHout.slice(t)));
      dC.slice(t).addi(pow(tanhCt,2).rsubi(1).muli(iFogA.slice(t).get(interval(2 * hiddenLayerSize,3 * hiddenLayerSize)).mul(dHout.slice(t))));
    }
 else {
      dIFogA.slice(t).put(new INDArrayIndex[]{interval(2 * hiddenLayerSize,3 * hiddenLayerSize)},memCellActivations.slice(t).mul(dHout.slice(t)));
      dC.slice(t).addi(iFogA.slice(t).get(interval(2 * hiddenLayerSize,3 * hiddenLayerSize)).mul(dHout.slice(t)));
    }
    if (t > 0) {
      dIFogA.slice(t).put(new INDArrayIndex[]{interval(hiddenLayerSize,2 * hiddenLayerSize)},memCellActivations.slice(t - 1).mul(dC.slice(t)));
      dC.slice(t - 1).addi(iFogA.slice(t).get(interval(hiddenLayerSize,2 * hiddenLayerSize)).mul(dC.slice(t)));
    }
    dIFogA.slice(t).put(new INDArrayIndex[]{interval(0,hiddenLayerSize)},iFogA.slice(t).get(interval(3 * hiddenLayerSize,iFogA.columns())).mul(dC.slice(t)));
    dIFogA.slice(t).put(new INDArrayIndex[]{interval(3 * hiddenLayerSize,dIFogA.columns())},iFogA.slice(t).get(interval(0,hiddenLayerSize)).mul(dC.slice(t)));
    dIFogZ.slice(t).put(new INDArrayIndex[]{interval(3 * hiddenLayerSize,dIFogZ.columns())},pow(iFogA.slice(t).get(interval(3 * hiddenLayerSize,iFogA.columns())),2).rsubi(1).mul(dIFogA.slice(t).get(interval(3 * hiddenLayerSize,dIFogA.columns()))));
    activations=iFogA.slice(t).get(interval(0,3 * hiddenLayerSize));
    dIFogA.slice(t).put(new INDArrayIndex[]{interval(0,3 * hiddenLayerSize)},activations.mul(activations.rsub(1)).mul(dIFogA.slice(t).get(interval(0,3 * hiddenLayerSize))));
    recurrentWeightGradients.addi(hIn.slice(t).transpose().mmul(dIFogZ.slice(t)));
    dHin.slice(t).assign(dIFogZ.slice(t).mmul(recurrentWeights.transpose()));
    INDArray get=dHin.slice(t).get(interval(1,1 + hiddenLayerSize));
    dX.slice(t).assign(get);
    if (t > 0)     dHout.slice(t - 1).addi(dHin.slice(t).get(interval(1 + hiddenLayerSize,dHin.columns())));
    if (conf.isUseDropConnect() & conf.getDropOut() > 0)     dX.muli(u);
  }
  clear();
  Gradient retGradient=new DefaultGradient();
  retGradient.gradientForVariable().put(LSTMParamInitializer.INPUT_WEIGHT_KEY,inputWeightGradients);
  retGradient.gradientForVariable().put(LSTMParamInitializer.RECURRENT_WEIGHT_KEY,recurrentWeightGradients);
  retGradient.gradientForVariable().put(LSTMParamInitializer.BIAS_KEY,biasGradients);
  INDArray nextEpsilon=null;
  return new Pair<>(retGradient,nextEpsilon);
}
