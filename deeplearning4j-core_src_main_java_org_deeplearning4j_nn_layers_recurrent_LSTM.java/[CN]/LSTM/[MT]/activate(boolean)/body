{
  this.x=input;
  INDArray decoderWeights=getParam(LSTMParamInitializer.INPUT_WEIGHT_KEY);
  INDArray recurrentWeights=getParam(LSTMParamInitializer.RECURRENT_WEIGHT_KEY);
  INDArray decoderBias=getParam(LSTMParamInitializer.BIAS_KEY);
  if (conf.getDropOut() > 0) {
    double scale=1 / (1 - conf.getDropOut());
    u=Nd4j.rand(x.shape()).lti(1 - conf.getDropOut()).muli(scale);
    x.muli(u);
  }
  int n=x.rows();
  int d=decoderWeights.rows();
  hIn=Nd4j.zeros(n,recurrentWeights.rows());
  hOut=Nd4j.zeros(n,d);
  iFog=Nd4j.zeros(n,d * 4);
  iFogF=Nd4j.zeros(iFog.shape());
  c=Nd4j.zeros(n,d);
  INDArray prev;
  for (int t=0; t < n; t++) {
    prev=t == 0 ? Nd4j.zeros(d) : hOut.getRow(t - 1);
    hIn.put(t,0,1.0);
    hIn.slice(t).put(new INDArrayIndex[]{interval(1,1 + d)},x.slice(t));
    hIn.slice(t).put(new INDArrayIndex[]{interval(1 + d,hIn.columns())},prev);
    iFog.putRow(t,hIn.slice(t).mmul(recurrentWeights));
    iFogF.slice(t).put(new INDArrayIndex[]{interval(0,3 * d)},sigmoid(iFog.slice(t).get(interval(0,3 * d))));
    iFogF.slice(t).put(new INDArrayIndex[]{interval(3 * d,iFogF.columns() - 1)},tanh(iFog.slice(t).get(interval(3 * d,iFog.columns() - 1))));
    INDArray cPut=iFogF.slice(t).get(interval(0,d)).mul(iFogF.slice(t).get(interval(3 * d,iFogF.columns())));
    c.putRow(t,cPut);
    if (t > 0)     c.slice(t).addi(iFogF.slice(t).get(interval(d,2 * d)).mul(c.getRow(t - 1)));
    if (conf.getActivationFunction().equals("tanh"))     hOut.slice(t).assign(iFogF.slice(t).get(interval(2 * d,3 * d)).mul(tanh(c.getRow(t))));
 else     hOut.slice(t).assign(iFogF.slice(t).get(interval(2 * d,3 * d)).mul(c.getRow(t)));
  }
  if (conf.getDropOut() > 0) {
    u2=Dropout.applyDropout(hOut,conf.getDropOut(),u2);
  }
  INDArray y=hOut.get(interval(1,hOut.rows())).mmul(decoderWeights).addiRowVector(decoderBias);
  return y;
}
