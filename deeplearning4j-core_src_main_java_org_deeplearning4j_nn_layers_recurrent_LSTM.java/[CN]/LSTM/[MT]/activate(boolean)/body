{
  INDArray prevOutputActivations, prevMemCellActivations;
  INDArray decoderWeights=getParam(LSTMParamInitializer.INPUT_WEIGHT_KEY);
  INDArray recurrentWeights=getParam(LSTMParamInitializer.RECURRENT_WEIGHT_KEY);
  INDArray decoderBias=getParam(LSTMParamInitializer.BIAS_KEY);
  if (conf.getLayer().getDropOut() > 0) {
    double scale=1 / (1 - conf.getLayer().getDropOut());
    u=Nd4j.rand(input.shape()).lti(1 - conf.getLayer().getDropOut()).muli(scale);
    input.muli(u);
  }
  int sequenceLen=input.rows();
  int hiddenLayerSize=decoderWeights.rows();
  int recurrentSize=recurrentWeights.size(0);
  hIn=Nd4j.zeros(sequenceLen,recurrentWeights.rows());
  outputActivations=Nd4j.zeros(sequenceLen,hiddenLayerSize);
  iFogZ=Nd4j.zeros(sequenceLen,hiddenLayerSize * 4);
  iFogA=Nd4j.zeros(iFogZ.shape());
  memCellActivations=Nd4j.zeros(sequenceLen,hiddenLayerSize);
  for (int t=0; t < sequenceLen; t++) {
    prevOutputActivations=t == 0 ? Nd4j.zeros(hiddenLayerSize) : outputActivations.getRow(t - 1);
    prevMemCellActivations=t == 0 ? Nd4j.zeros(hiddenLayerSize) : memCellActivations.getRow(t - 1);
    hIn.put(t,0,1.0);
    hIn.slice(t).put(new INDArrayIndex[]{interval(1,1 + hiddenLayerSize)},input.slice(t));
    hIn.slice(t).put(new INDArrayIndex[]{interval(1 + hiddenLayerSize,hIn.columns())},prevOutputActivations);
    iFogZ.putRow(t,hIn.slice(t).mmul(recurrentWeights));
    iFogA.slice(t).put(new INDArrayIndex[]{interval(0,3 * hiddenLayerSize)},sigmoid(iFogZ.slice(t).get(new INDArrayIndex[]{interval(0,3 * hiddenLayerSize)})));
    iFogA.slice(t).put(new INDArrayIndex[]{interval(3 * hiddenLayerSize,iFogA.columns() - 1)},tanh(iFogZ.slice(t).get(interval(3 * hiddenLayerSize,iFogZ.columns() - 1))));
    memCellActivations.putRow(t,iFogA.slice(t).get(interval(0,hiddenLayerSize)).mul(iFogA.slice(t).get(interval(3 * hiddenLayerSize,iFogA.columns()))));
    if (t > 0)     memCellActivations.slice(t).addi(iFogA.slice(t).get(interval(hiddenLayerSize,2 * hiddenLayerSize)).mul(prevMemCellActivations));
    if (conf.getLayer().getActivationFunction().equals("tanh")) {
      outputActivations.slice(t).assign(iFogA.slice(t).get(interval(2 * hiddenLayerSize,3 * hiddenLayerSize)).mul(tanh(memCellActivations.getRow(t))));
    }
 else {
      outputActivations.slice(t).assign(iFogA.slice(t).get(interval(2 * hiddenLayerSize,3 * hiddenLayerSize)).mul(memCellActivations.getRow(t)));
    }
  }
  if (conf.isUseDropConnect() && training) {
    if (conf.getLayer().getDropOut() > 0) {
      u2=Dropout.applyDropout(outputActivations,conf.getLayer().getDropOut(),u2);
      outputActivations.muli(u2);
    }
  }
  return outputActivations.get(interval(1,outputActivations.rows())).mmul(decoderWeights).addiRowVector(decoderBias);
}
