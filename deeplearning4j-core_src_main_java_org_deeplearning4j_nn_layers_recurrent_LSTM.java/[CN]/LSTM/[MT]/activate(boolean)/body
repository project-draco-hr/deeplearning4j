{
  INDArray prevOutputActivations, prevMemCellActivations;
  INDArray decoderWeights=getParam(LSTMParamInitializer.INPUT_WEIGHT_KEY);
  INDArray recurrentWeights=getParam(LSTMParamInitializer.RECURRENT_WEIGHT_KEY);
  INDArray decoderBias=getParam(LSTMParamInitializer.BIAS_KEY);
  if (conf.getLayer().getDropOut() > 0) {
    double scale=1 / (1 - conf.getLayer().getDropOut());
    u=Nd4j.rand(input.shape()).lti(1 - conf.getLayer().getDropOut()).muli(scale);
    input.muli(u);
  }
  int sequenceLen=input.size(0);
  int hiddenLayerSize=decoderWeights.size(0);
  int recurrentSize=recurrentWeights.size(0);
  hIn=Nd4j.zeros(sequenceLen,recurrentSize);
  hOut=Nd4j.zeros(sequenceLen,hiddenLayerSize);
  iFogZ=Nd4j.zeros(sequenceLen,hiddenLayerSize * 4);
  iFogA=Nd4j.zeros(iFogZ.shape());
  memCellActivations=Nd4j.zeros(sequenceLen,hiddenLayerSize);
  for (int t=0; t < sequenceLen; t++) {
    prevOutputActivations=t == 0 ? Nd4j.zeros(hiddenLayerSize) : hOut.slice(t - 1);
    prevMemCellActivations=t == 0 ? Nd4j.zeros(hiddenLayerSize) : memCellActivations.slice(t - 1);
    hIn.slice(t).put(t,0,1);
    hIn.slice(t).put(new INDArrayIndex[]{interval(1,1 + hiddenLayerSize),interval(t,t + 1)},input.slice(t));
    hIn.slice(t).put(new INDArrayIndex[]{interval(1 + hiddenLayerSize,hIn.columns()),interval(0,1)},prevOutputActivations);
    iFogZ.slice(t).put(new INDArrayIndex[]{interval(0,hiddenLayerSize * 4),interval(0,1)},hIn.slice(t).mmul(recurrentWeights));
    iFogA.slice(t).put(new INDArrayIndex[]{interval(0,3 * hiddenLayerSize)},sigmoid(iFogZ.slice(t).get(interval(0,3 * hiddenLayerSize))));
    iFogA.slice(t).put(new INDArrayIndex[]{interval(3 * hiddenLayerSize,iFogA.columns() - 1)},tanh(iFogZ.slice(t).get(interval(3 * hiddenLayerSize,iFogZ.columns() - 1))));
    memCellActivations.slice(t).put(new INDArrayIndex[]{interval(0,hiddenLayerSize)},iFogA.slice(t).get(interval(0,hiddenLayerSize)).mul(iFogA.slice(t).get(interval(3 * hiddenLayerSize,iFogA.columns()))));
    if (t > 0)     memCellActivations.slice(t).addi(iFogA.slice(t).get(interval(hiddenLayerSize,2 * hiddenLayerSize)).mul(prevMemCellActivations));
    if (conf.getLayer().getActivationFunction().equals("tanh")) {
      hOut.slice(t).assign(iFogA.slice(t).get(interval(2 * hiddenLayerSize,3 * hiddenLayerSize)).mul(tanh(memCellActivations.slice(t))));
    }
 else {
      hOut.slice(t).assign(iFogA.slice(t).get(interval(2 * hiddenLayerSize,3 * hiddenLayerSize)).mul(memCellActivations.slice(t)));
    }
  }
  if (conf.isUseDropConnect() && training) {
    if (conf.getLayer().getDropOut() > 0) {
      u2=Dropout.applyDropout(hOut,conf.getLayer().getDropOut(),u2);
      hOut.muli(u2);
    }
  }
  outputActivations=hOut.get(interval(1,hOut.rows())).mmul(decoderWeights).addiRowVector(decoderBias);
  return outputActivations;
}
