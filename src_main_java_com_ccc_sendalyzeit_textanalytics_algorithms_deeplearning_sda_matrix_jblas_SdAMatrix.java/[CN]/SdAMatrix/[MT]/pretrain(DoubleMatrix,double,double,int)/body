{
  for (int i=0; i < n_layers; i++) {
    log.info("Layer " + i);
    final int copyI=i;
    DoubleMatrix layer_input=null;
    DoubleMatrix prev_layer_input;
    for (int epoch=0; epoch < epochs; epoch++) {
      log.info("Epoch " + (epoch + 1));
      for (int n=0; n < N; n++) {
        for (int l=0; l <= copyI; l++) {
          if (l == 0)           layer_input=train_X.getRow(n).transpose();
 else {
            prev_layer_input=layer_input.dup();
            layer_input=sigmoid_layers[l - 1].sample_h_given_v(prev_layer_input,hidden_layer_sizes[copyI]);
          }
        }
        dA_layers[copyI].train(layer_input,lr,corruption_level);
      }
    }
  }
}
