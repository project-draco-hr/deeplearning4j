{
  if (vertexInputs.length == 1)   return vertexInputs[0];
  InputType first=vertexInputs[0];
  if (first.getType() != InputType.Type.CNN) {
    for (int i=1; i < vertexInputs.length; i++) {
      if (vertexInputs[i].getType() != first.getType()) {
        throw new InvalidInputTypeException("Invalid input: MergeVertex cannot merge activations of different types:" + " first type = " + first.getType() + ", input type "+ (i + 1)+ " = "+ vertexInputs[i].getType());
      }
    }
    return first;
  }
 else {
    InputType.InputTypeConvolutional firstConv=(InputType.InputTypeConvolutional)first;
    int fd=firstConv.getDepth();
    int fw=firstConv.getWidth();
    int fh=firstConv.getHeight();
    int depthSum=fd;
    for (int i=1; i < vertexInputs.length; i++) {
      if (vertexInputs[i].getType() != InputType.Type.CNN) {
        throw new InvalidInputTypeException("Invalid input: MergeVertex cannot process activations of different types:" + " first type = " + InputType.Type.CNN + ", input type "+ (i + 1)+ " = "+ vertexInputs[i].getType());
      }
      InputType.InputTypeConvolutional otherConv=(InputType.InputTypeConvolutional)vertexInputs[i];
      int od=otherConv.getDepth();
      int ow=otherConv.getWidth();
      int oh=otherConv.getHeight();
      if (fw != ow || fh != oh) {
        throw new InvalidInputTypeException("Invalid input: MergeVertex cannot merge CNN activations of different width/heights:" + "first [depth,width,height] = [" + fd + ","+ fw+ ","+ fh+ "], input "+ i+ " = ["+ od+ ","+ ow+ ","+ oh+ "]");
      }
      depthSum+=od;
    }
    return InputType.convolutional(depthSum,fw,fh);
  }
}
