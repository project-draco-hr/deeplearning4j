{
  log.info("Start training ...");
  final JavaSparkContext sc=new JavaSparkContext(corpusRDD.context());
  Map<String,Object> tokenizerVarMap=getTokenizerVarMap();
  Map<String,Object> word2vecVarMap=getWord2vecVarMap();
  final JavaRDD<AtomicLong> sentenceWordsCountRDD;
  final JavaRDD<List<VocabWord>> vocabWordListRDD;
  final JavaPairRDD<List<VocabWord>,Long> vocabWordListSentenceCumSumRDD;
  final VocabCache vocabCache;
  final Broadcast<VocabCache> vocabCacheBroadcast;
  final JavaRDD<Long> sentenceCumSumCountRDD;
  log.info("Tokenization and building VocabCache ...");
  Broadcast<Map<String,Object>> broadcastTokenizerVarMap=sc.broadcast(tokenizerVarMap);
  TextPipeline pipeline=new TextPipeline(corpusRDD,broadcastTokenizerVarMap);
  pipeline.buildVocabCache();
  pipeline.buildVocabWordListRDD();
  word2vecVarMap.put("totalWordCount",pipeline.getTotalWordCount());
  sentenceWordsCountRDD=pipeline.getSentenceCountRDD();
  vocabWordListRDD=pipeline.getVocabWordListRDD();
  vocabCache=pipeline.getVocabCache();
  vocabCacheBroadcast=pipeline.getBroadCastVocabCache();
  log.info("Building Huffman Tree ...");
  Huffman huffman=new Huffman(vocabCache.vocabWords());
  huffman.build();
  log.info("Calculating cumulative sum of sentence counts ...");
  sentenceCumSumCountRDD=new CountCumSum(sentenceWordsCountRDD).buildCumSum();
  log.info("Mapping to RDD(vocabWordList, cumulative sentence count) ...");
  vocabWordListSentenceCumSumRDD=vocabWordListRDD.zip(sentenceCumSumCountRDD).setName("vocabWordListSentenceCumSumRDD").cache();
  log.info("Broadcasting word2vec variables to workers ...");
  Broadcast<Map<String,Object>> word2vecVarMapBroadcast=sc.broadcast(word2vecVarMap);
  Broadcast<double[]> expTableBroadcast=sc.broadcast(expTable);
  log.info("Training word2vec sentences ...");
  FlatMapFunction firstIterFunc=new FirstIterationFunction(word2vecVarMapBroadcast,expTableBroadcast);
  @SuppressWarnings("unchecked") JavaRDD<Pair<Integer,INDArray>> pointSyn0Vec=vocabWordListSentenceCumSumRDD.mapPartitions(firstIterFunc).flatMap(new FlatMapSyn0VecFunction());
  final Accumulator<Pair<Integer,INDArray>> syn0Acc=sc.accumulator(new Pair<>(0,Nd4j.zeros(vectorLength)),new Syn0Accumulator(vectorLength));
  pointSyn0Vec.foreach(new UpdateSyn0AccumulatorFunction(syn0Acc));
  INDArray syn0=syn0Acc.value().getSecond();
  InMemoryLookupTable inMemoryLookupTable=new InMemoryLookupTable();
  inMemoryLookupTable.setSyn0(syn0);
  inMemoryLookupTable.setVocab(vocabCache);
  lookupTable=inMemoryLookupTable;
}
