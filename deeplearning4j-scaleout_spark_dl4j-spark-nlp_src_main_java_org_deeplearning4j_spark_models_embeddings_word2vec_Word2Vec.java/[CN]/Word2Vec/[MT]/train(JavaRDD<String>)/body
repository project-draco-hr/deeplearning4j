{
  final JavaSparkContext sc=new JavaSparkContext(corpusRDD.context());
  final SparkConf conf=sc.getConf();
  int vectorLength=assignVar(VECTOR_LENGTH,conf,Integer.class);
  boolean useAdaGrad=assignVar(ADAGRAD,conf,Boolean.class);
  double negative=assignVar(NEGATIVE,conf,Double.class);
  int numWords=assignVar(NUM_WORDS,conf,Integer.class);
  int window=assignVar(WINDOW,conf,Integer.class);
  double alpha=assignVar(ALPHA,conf,Double.class);
  double minAlpha=assignVar(MIN_ALPHA,conf,Double.class);
  int iterations=assignVar(ITERATIONS,conf,Integer.class);
  int nGrams=assignVar(N_GRAMS,conf,Integer.class);
  String tokenizer=assignVar(TOKENIZER,conf,String.class);
  String tokenPreprocessor=assignVar(TOKEN_PREPROCESSOR,conf,String.class);
  boolean removeStop=assignVar(REMOVE_STOPWORDS,conf,Boolean.class);
  final JavaRDD<AtomicLong> sentenceWordsCountRDD;
  final JavaRDD<List<VocabWord>> vocabWordListRDD;
  final Long totalWordCount;
  final JavaPairRDD<List<VocabWord>,Long> vocabWordListSentenceCumSumRDD;
  final VocabCache vocabCache;
  final Broadcast<VocabCache> vocabCacheBroadcast;
  final JavaRDD<Long> sentenceCumSumCountRDD;
  log.info("Tokenization and building VocabCache ...");
  TextPipeline pipeline=new TextPipeline(corpusRDD,numWords,nGrams,tokenizer,tokenPreprocessor,removeStop);
  pipeline.buildVocabCache();
  totalWordCount=pipeline.getTotalWordCount();
  sentenceWordsCountRDD=pipeline.getSentenceCountRDD();
  vocabWordListRDD=pipeline.getvocabWordListRDD();
  vocabCache=pipeline.getVocabCache();
  vocabCacheBroadcast=pipeline.getBroadCastVocabCache();
  log.info("Building Huffman Tree ...");
  Huffman huffman=new Huffman(vocabCache.vocabWords());
  huffman.build();
  log.info("Calculating cumulative sum of sentence counts ...");
  sentenceCumSumCountRDD=new CountCumSum(sentenceWordsCountRDD).buildCumSum();
  log.info("Mapping to RDD(vocabWordList, cumulative sentence count) ...");
  vocabWordListSentenceCumSumRDD=vocabWordListRDD.zip(sentenceCumSumCountRDD);
  log.info("Building Word2VecParams ...");
  final InMemoryLookupTable lookupTable;
  if (table != null) {
    lookupTable=table;
  }
 else {
    lookupTable=(InMemoryLookupTable)new InMemoryLookupTable.Builder().cache(vocabCache).vectorLength(vectorLength).negative(negative).build();
    lookupTable.resetWeights();
  }
  final Word2VecParam param=new Word2VecParam.Builder().negative(negative).window(window).expTable(sc.broadcast(lookupTable.getExpTable())).setAlpha(alpha).setMinAlpha(minAlpha).setVectorLength(vectorLength).useAdaGrad(useAdaGrad).weights(lookupTable).build();
  param.setTotalWords(totalWordCount.intValue());
  log.info("Calculating word frequencies...");
  JavaRDD<List<VocabWord>> words=r.map(new Function<Pair<List<VocabWord>,AtomicLong>,List<VocabWord>>(){
    @Override public List<VocabWord> call(    Pair<List<VocabWord>,AtomicLong> listAtomicLongPair) throws Exception {
      return listAtomicLongPair.getFirst();
    }
  }
);
  JavaPairRDD<List<VocabWord>,Long> wordsAndWordsSeen=words.zipWithIndex().mapToPair(new PairFunction<Tuple2<List<VocabWord>,Long>,List<VocabWord>,Long>(){
    @Override public Tuple2<List<VocabWord>,Long> call(    Tuple2<List<VocabWord>,Long> listLongTuple2) throws Exception {
      return new Tuple2<>(listLongTuple2._1(),wordsSeen.get(listLongTuple2._2().intValue()));
    }
  }
).cache();
  log.info("Training word 2vec");
  for (int i=0; i < conf.getInt(Word2VecPerformerVoid.ITERATIONS,5); i++) {
    final Broadcast<Word2VecParam> finalParamBroadcast=sc.broadcast(param);
    if (finalParamBroadcast.value() == null)     throw new IllegalStateException("Value not found for param broadcast");
    JavaRDD<Word2VecFuncCall> call=wordsAndWordsSeen.map(new Word2VecSetup(finalParamBroadcast));
    JavaRDD<Word2VecChange> change2=call.map(new SentenceBatch());
    change2.foreach(new VoidFunction<Word2VecChange>(){
      @Override public void call(      Word2VecChange change) throws Exception {
        change.apply(lookupTable);
      }
    }
);
    change2.unpersist();
    log.info("Iteration " + i);
  }
  super.lookupTable=lookupTable;
  super.vocab=vocabCacheBroadcast.getValue();
  return new Pair<VocabCache,WeightLookupTable>(vocabCacheBroadcast.getValue(),lookupTable);
}
