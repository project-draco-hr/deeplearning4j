{
  Set<String> encountered=new HashSet<>();
  if (message instanceof VocabWork) {
    VocabWork work=(VocabWork)message;
    if (work.getWork() == null || work.getWork().isEmpty())     return;
    work.getCount().incrementAndGet();
    String sentence=work.getWork();
    if (sentence.isEmpty() || sentence.length() <= 2) {
      work.countDown();
      return;
    }
    Tokenizer t=tokenizer.create(sentence);
    while (t.hasMoreTokens()) {
      String token=t.nextToken();
      if (token.length() < 2)       continue;
      if (stopWords.contains(token))       token="STOP";
      cache.incrementWordCount(token);
      if (!encountered.contains(token)) {
        cache.incrementDocCount(token,1);
        encountered.add(token);
      }
      if (!Util.matchesAnyStopWord(stopWords,token) && token != null && !token.isEmpty()) {
        if (!cache.containsWord(token) && cache.wordFrequency(token) >= minWordFrequency) {
          VocabWord word=new VocabWord(cache.wordFrequency(token),token);
          int idx=cache.numWords();
          word.setIndex(idx);
          cache.putVocabWord(token,word);
        }
      }
 else       if (Util.matchesAnyStopWord(stopWords,token) && token != null && !token.isEmpty()) {
        token="STOP";
        if (!cache.containsWord(token) && cache.wordFrequency(token) >= minWordFrequency) {
          VocabWord word=new VocabWord(cache.wordFrequency(token),token);
          int idx=cache.numWords();
          word.setIndex(idx);
          cache.putVocabWord(token,word);
        }
      }
    }
    work.countDown();
    lastUpdate.getAndSet(System.currentTimeMillis());
  }
 else   if (message instanceof StreamWork) {
    StreamWork work=(StreamWork)message;
    InputStream is=work.getIs();
    boolean tryRead=false;
    try {
      if (is.available() > 0) {
        tryRead=true;
      }
    }
 catch (    Exception e) {
      tryRead=false;
    }
    if (!tryRead)     return;
    Tokenizer t=tokenizer.create(is);
    while (t.hasMoreTokens()) {
      String token=t.nextToken();
      if (stopWords.contains(token))       token="STOP";
      cache.incrementWordCount(token);
      if (!encountered.contains(token)) {
        cache.incrementDocCount(token,1);
        encountered.add(token);
      }
      if (!Util.matchesAnyStopWord(stopWords,token) && token != null && !token.isEmpty()) {
        if (!cache.containsWord(token) && cache.wordFrequency(token) >= minWordFrequency) {
          VocabWord word=new VocabWord(cache.wordFrequency(token),token);
          int idx=cache.numWords();
          word.setIndex(idx);
          cache.putVocabWord(token,word);
        }
 else         if (Util.matchesAnyStopWord(stopWords,token) && token != null && !token.isEmpty()) {
          token="STOP";
          if (!cache.containsWord(token) && cache.wordFrequency(token) >= minWordFrequency) {
            VocabWord word=new VocabWord(cache.wordFrequency(token),token);
            int idx=cache.numWords();
            word.setIndex(idx);
            cache.putVocabWord(token,word);
          }
        }
      }
    }
    IOUtils.closeQuietly(is);
    work.countDown();
    lastUpdate.getAndSet(System.currentTimeMillis());
  }
 else   unhandled(message);
}
